0001: 0000         ;     File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
0002: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm
0003: 0000         ; CCP.asm
0004: 0000         ;
0005: 0000         ; 2017-03-02 Refactored the CP/M Suite
0006: 0000         ; 2014-01-16
0007: 0000         ; 2014-05-01  :  Frank Martyn
0008: 0000
0009: 0000         ; replace systemFile with fcbSystemFileIndex
0010: 0000
0011: 0000                        Include ./stdHeader.Z80
0012: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0013: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0014: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0015: 0000         ; stdHeader.asm
0016: 0000         ; standard equates
0017: 0000
0018: 0000         ; 2017-03-02 Refactored the CP/M Suite
0019: 0000
0020: 0000
0021: 0000             TRUE       EQU    -1                   ; not false
0022: 0000             FALSE      EQU    0000H
0023: 0000             ON         EQU    -1
0024: 0000             OFF        EQU    0000H
0025: 0000             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0026: 0000
0027: 0000             BYTE       EQU    1                    ; number of bytes for "byte" type
0028: 0000             WORD       EQU    2                    ; number of bytes for "word" type
0029: 0000
0030: 0000
0031: 0000             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0032: 0000             ZERO       EQU    00H                  ; Zero
0033: 0000             EndOfMessage EQU    00H
0034: 0000
0035: 0000             CTRL_C     EQU    03H                  ; ETX
0036: 0000             CTRL_E     EQU    05H                  ; physical eol
0037: 0000             CTRL_H     EQU    08H                  ; backspace
0038: 0000             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0039: 0000             CTRL_L     EQU    0CH                  ; FF - Form feed
0040: 0000             CTRL_P     EQU    10H                  ; prnt toggle
0041: 0000             CTRL_R     EQU    12H                  ; repeat line
0042: 0000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0043: 0000             CTRL_U     EQU    15H                  ; line delete
0044: 0000             CTRL_X     EQU    18H                  ; =ctl-u
0045: 0000             CTRL_Z     EQU    1AH                  ; end of file
0046: 0000
0047: 0000             NULL       EQU    00H                  ; Null
0048: 0000             SOH        EQU    01H                  ; Start of Heading
0049: 0000             BELL       EQU    07H                  ; Bell
0050: 0000             TAB        EQU    09H                  ; Tab
0051: 0000             LF         EQU    0AH                  ; Line Feed
0052: 0000             CR         EQU    0DH                  ; Carriage Return
0053: 0000             SPACE      EQU    20H                  ; Space
0054: 0000             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0055: 0000             HASH_TAG   EQU    23H                  ; Sharp sign #
0056: 0000             DOLLAR     EQU    24H                  ; Dollar Sign
0057: 0000             PERCENT    EQU    25H                  ; Percent Sign
0058: 0000             L_PAREN    EQU    28H                  ; Left Paenthesis (
0059: 0000             R_PAREN    EQU    29H                  ; Right Paenthesis )
0060: 0000             ASTERISK   EQU    2AH                  ; Asterisk *
0061: 0000             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0062: 0000             COMMA      EQU    2CH                  ; Comma
0063: 0000             DASH       EQU    2DH                  ; Dash Hyphen -
0064: 0000             PERIOD     EQU    2EH                  ; Period
0065: 0000             SLASH      EQU    2FH                  ; /
0066: 0000             ASCII_ZERO EQU    30H                  ; zero
0067: 0000             COLON      EQU    3AH                  ; Colon
0068: 0000
0069: 0000             SEMICOLON  EQU    3BH                  ; Semi Colon
0070: 0000             LESS_THAN  EQU    3CH                  ; Less Than <
0071: 0000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0072: 0000             GREATER_THAN EQU    3EH                  ; Greater Than >
0073: 0000             QMARK      EQU    3FH                  ; Question Mark
0074: 0000             UNDER_SCORE EQU    5FH                  ; under score _
0075: 0000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0076: 0000             RUBOUT     EQU    7FH                  ; Delete Key
0077: 0000
0078: 0000
0079: 0000             ASCII_A    EQU    'A'
0080: 0000             ASCII_C    EQU    'C'
0081: 0000             ASCII_K    EQU    'K'
0082: 0000             ASCII_N    EQU    'N'
0083: 0000             ASCII_Q    EQU    'Q'
0084: 0000             ASCII_R    EQU    'R'
0085: 0000             ASCII_W    EQU    'W'
0086: 0000             ASCII_Y    EQU    'Y'
0087: 0000             CARET      EQU    '^'
0088: 0000             ASCII_LO_A EQU    'a'
0089: 0000             ASCII_LO_K EQU    'k'
0090: 0000             ASCII_LO_P EQU    'p'
0091: 0000             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0092: 0000
0093: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0094: 0000                        Include ./osHeader.Z80
0095: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0096: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0097: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0098: 0000         ; osHeader.asm
0099: 0000
0100: 0000         ; 2017-03-02 Refactored the CP/M Suite
0101: 0000
0102: 0000         ; Contains the Equates used by the CP/M system
0103: 0000
0104: 0000         ;------------------------Page Zero Constants ---------------------------------
0105: 0000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0106: 0000
0107: 0000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0108: 0000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0109: 0000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0110: 0000
0111: 0000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0112: 0000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0113: 0000
0114: 0000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0115: 0000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0116: 0000
0117: 0000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0118: 0000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0119: 0000
0120: 0000             ComTail    EQU    RAM + 080H           ; Complete command tail
0121: 0000             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0122: 0000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0123: 0000         ;-----------------------------------------------------------------------
0124: 0000
0125: 0000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0126: 0000         ;-----------------------------------------------------------------------
0127: 0000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0128: 0000         ;-----------------------------------------------------------------------
0129: 0000             END_OF_FILE EQU    1AH                  ; end of file
0130: 0000         ;-----------------------------------------------------------------------
0131: 0000
0132: 0000         ;--------------- CP/M Constants -----------------------------------------
0133: 0000
0134: 0000             CCPLength  EQU    0800H                ; Constant
0135: 0000             BDOSLength EQU    0E00H                ; Constant 0E00H
0136: 0000             BIOSLength EQU    0A00H                ; Constant 0900H
0137: 0000
0138: 0000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0139: 0000             LengthInK  EQU    (LengthInBytes/1024) + 1
0140: 0000
0141: 0000             MemorySize EQU    64
0142: 0000
0143: 0000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0144: 0000
0145: 0000             BDOSBase   EQU    CCPEntry + CCPLength
0146: 0000             BDOSEntry  EQU    BDOSBase + 6
0147: 0000
0148: 0000             BIOSBase   EQU    BDOSBase + BDOSLength
0149: 0000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0150: 0000         ;-----------------------------------------------------------------------
0151: 0000
0152: 0000         ;------------------- BDOS System Call Equates --------------------------
0153: 0000             fConsoleIn EQU    01H                  ; rcharf - Console Input
0154: 0000             fConsoleOut EQU    02H                  ; pcharf - Console Output
0155: 0000             fPrintString EQU    09H                  ; pbuff	- Print String
0156: 0000             fReadString EQU    0AH                  ; rbuff	- Read Console String
0157: 0000             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0158: 0000             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0159: 0000             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0160: 0000             fSelectDisk EQU    0EH                  ; self	- Select Disk
0161: 0000             fOpenFile  EQU    0FH                  ; openf	- Open File
0162: 0000             fCloseFile EQU    10H                  ; closef - Close File
0163: 0000             fSearchFirst EQU    11H                  ; searf	- Search For First
0164: 0000             fSearchNext EQU    12H                  ; searnf - Search for Next
0165: 0000             fDeleteFile EQU    13H                  ; delf - Delete File
0166: 0000             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0167: 0000             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0168: 0000             fMakeFile  EQU    16H                  ; makef	- Make File
0169: 0000             fRenameFile EQU    17H                  ; renf	- Rename File
0170: 0000             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0171: 0000             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0172: 0000             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0173: 0000             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0174: 0000         ;-----------------------------------------------------------------------
0175: 0000
0176: 0000
0177: 0000
0178: 0000
0179: 0000
0180: 0000         ;*******************************************************************************
0181: 0000         ; These are the values handed over by the BDOS when it calls the Writer operation
0182: 0000         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0183: 0000         ; unallocated allocation block (it only indicates this for the first 128 byte
0184: 0000         ; sector write) or to an allocation block that has already been allocated to a
0185: 0000         ; file. The BDOS also indicates if it is set to write to the file directory
0186: 0000         ;*******************************************************************************
0187: 0000             WriteAllocated EQU    00H
0188: 0000             WriteDirectory EQU    01H
0189: 0000             WriteUnallocated EQU    02H
0190: 0000
0191: 0000
0192: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0193: 0000                        Include ./diskHeader.Z80
0194: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0195: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0196: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0197: 0000         ; diskHeader.asm
0198: 0000
0199: 0000         ; 2017-03-02 Refactored the CP/M Suite
0200: 0000
0201: 0000         ; needs osHeader.asm declared before this is used !!!!!!!
0202: 0000
0203: 0000         ; Contains the Equates used by the CP/M system to handle disks
0204: 0000
0205: 0000
0206: 0000         ;*******************************************************************************
0207: 0000         ;
0208: 0000         ;     Disk related values
0209: 0000         ;
0210: 0000         ;
0211: 0000         ;*******************************************************************************
0212: 0000             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0213: 0000             DiskControlByte EQU    045H                 ; control byte for disk I/O
0214: 0000             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0215: 0000         ; for boot
0216: 0000             DiskControlTable EQU    0040H
0217: 0000
0218: 0000             DiskReadCode EQU    01H                  ; Code for Read
0219: 0000             DiskWriteCode EQU    02H                  ; Code for Write
0220: 0000
0221: 0000
0222: 0000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0223: 0000             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0224: 0000             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0225: 0000
0226: 0000             DirEntrySize EQU    20H                  ; (32)
0227: 0000             DirBuffSize EQU    cpmRecordSize
0228: 0000
0229: 0000             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0230: 0000
0231: 0000             RecordsPerExtent EQU    080H                 ; extent Record capacity
0232: 0000
0233: 0000
0234: 0000         ;-------------------------------------------------------------------------------------
0235: 0000             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0236: 0000
0237: 0000         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0238: 0000             NumberOfHeads EQU    02H                  ; number of heads
0239: 0000             TracksPerHead EQU    50H                  ; 80
0240: 0000             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0241: 0000             SectorsPerBlock EQU    04H                  ; 2048 bytes
0242: 0000             DirectoryBlockCount EQU    02H                  ;
0243: 0000         ;-----------------------------------------------------------------------
0244: 0000
0245: 0000             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0246: 0000
0247: 0000             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0248: 0000
0249: 0000             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0250: 0000             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0251: 0000             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0252: 0000
0253: 0000             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0254: 0000             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0255: 0000             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0256: 0000             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0257: 0000
0258: 0000         ;-----------------------------------------------------------------------
0259: 0000         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0260: 0000         ;-----------------------------------------------------------------------
0261: 0000         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0262: 0000             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0263: 0000             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0264: 0000             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0265: 0000             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0266: 0000             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0267: 0000             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0268: 0000             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0269: 0000             dpb3hdAL1  EQU    00H                  ;  for each file directory
0270: 0000             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0271: 0000             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0272: 0000             dpb3hdNOH  EQU    NumberOfHeads
0273: 0000
0274: 0000         ;*******************************************************************************
0275: 0000
0276: 0000             SectorMask EQU    SectorsPerBlock - 1
0277: 0000
0278: 0000         ;***************************************************************************
0279: 0000
0280: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0281: 0000
0282: 0000
0283: 0000             fcbSystemFileIndex EQU    0AH                  ; extent number field index
0284: 0000             iFunctionNameSize EQU    04                   ; size of intrinsic function names
0285: 0000
0286: 0000
0287: 0000
0288: 0000                        ORG    CCPEntry
0289: E000
0290: E000             CcpBoundary EQU    $
0291: E000
0292: E000 C3 03 E0               JP     CcpStart             ;start ccp with possible initial command
0293: E003         ;*****************************************************************
0294: E003         ;enter here from boot loader
0295: E003             CcpStart:
0296: E003 31 F0 E7               LD     SP,Stack
0297: E006 C5                     PUSH   BC                   ; save initial disk number
0298: E007         ; (high order 4bits=user code, low 4bits=disk#)
0299: E007 79                     LD     A,C
0300: E008 1F                     RRA
0301: E009 1F                     RRA
0302: E00A 1F                     RRA
0303: E00B 1F                     RRA
0304: E00C E6 0F                  AND    LO_NIBBLE_MASK       ; user code
0305: E00E 5F                     LD     E,A
0306: E00F CD 01 E1               CALL   SetUser              ; user code selected
0307: E012         ; initialize for this user, get $ flag
0308: E012 CD 06 E1               CALL   Initialize           ; 0ffh in accum if $ file present
0309: E015 32 E7 E6               LD     (submitFlag),A       ; submit flag set if $ file present
0310: E018 C1                     POP    BC                   ; recall user code and disk number
0311: E019 79                     LD     A,C
0312: E01A E6 0F                  AND    LO_NIBBLE_MASK       ; disk number in accumulator
0313: E01C 32 04 00               LD     (Pg0CurentDisk),A    ; clears low memory user code nibble
0314: E01F CD 0B E1               CALL   SelectDisk           ; proper disk is selected, now check sub files
0315: E022         ; check for initial command
0316: E022 3A 14 E7               LD     A,(CommandLength)
0317: E025 B7                     OR     A
0318: E026 C2 3F E0               JP     NZ,Ccp0              ;assume typed already
0319: E029
0320: E029             Ccp:                            ;enter here on each command or error condition
0321: E029 31 F0 E7               LD     SP,Stack
0322: E02C CD 14 E3               CALL   CrLf                 ; print d> prompt, where d is disk name
0323: E02F CD 11 E1               CALL   GetSelectedDrive     ; get current disk number
0324: E032 C6 41                  ADD    A,ASCII_A
0325: E034 CD 24 E3               CALL   PrintChar
0326: E037 3E 3E                  LD     A,GREATER_THAN
0327: E039 CD 24 E3               CALL   PrintChar
0328: E03C CD 76 E0               CALL   ReadCommand          ; command buffer filled
0329: E03F             Ccp0:                           ; ccp0 enter here from initialization with command full
0330: E03F 11 80 00               LD     DE,DMABuffer
0331: E042 CD 5C E1               CALL   SetDMA               ; default dma address at DMABuffer
0332: E045 CD 11 E1               CALL   GetSelectedDrive
0333: E048 32 0E E7               LD     (currentDisk),A      ; current disk number saved
0334: E04B CD AA E1               CALL   FillFCB0             ; command fcb filled
0335: E04E C4 7C E3               CALL   NZ,CommandError      ; the name cannot be an ambiguous reference
0336: E051 3A 0F E7               LD     A,(selectedDisk)
0337: E054 B7                     OR     A
0338: E055 C2 F7 E5               JP     NZ,ccpUserFunction
0339: E058
0340: E058 CD E5 E2               CALL   IntrinsicFunction    ; check for an intrinsic function
0341: E05B 21 68 E0               LD     HL,intrinsicFunctionsVector ; index is in the accumulator
0342: E05E 5F                     LD     E,A
0343: E05F 16 00                  LD     D,0
0344: E061 19                     ADD    HL,DE
0345: E062 19                     ADD    HL,DE                ; index in d,e
0346: E063 7E                     LD     A,(HL)
0347: E064 23                     INC    HL
0348: E065 66                     LD     H,(HL)
0349: E066 6F                     LD     L,A
0350: E067 E9                     JP     (HL)                 ; pc changes to the proper intrinsic or user function
0351: E068         ;.................................................
0352: E068         ;.................................................
0353: E068
0354: E068             intrinsicFunctionsVector:                      ; jmptab
0355: E068 C9 E3                  DW     ccpDirectory         ; directory search
0356: E06A 71 E4                  DW     ccpErase             ; file erase
0357: E06C AF E4                  DW     ccpType              ; type file
0358: E06E FF E4                  DW     ccpSave              ; save memory image
0359: E070 62 E5                  DW     ccpRename            ; file rename
0360: E072 E0 E5                  DW     ccpUser              ; user number
0361: E074 F7 E5                  DW     ccpUserFunction      ; user-defined function
0362: E076
0363: E076         ;----------------------------------------------------------------
0364: E076         ;----------------------------------------------------------------
0365: E076         ;read the next command into the command buffer
0366: E076         ;check for submit file
0367: E076             ReadCommand:
0368: E076 3A E7 E6               LD     A,(submitFlag)
0369: E079 B7                     OR     A
0370: E07A CA D3 E0               JP     Z,NotSubmitFile
0371: E07D         ; scanning a submit file change drives to open and read the file
0372: E07D 3A 0E E7               LD     A,(currentDisk)
0373: E080 B7                     OR     A
0374: E081 3E 00                  LD     A,0
0375: E083 C4 0B E1               CALL   NZ,SelectDisk
0376: E086         ; have to open again in case xsub present
0377: E086 11 E8 E6               LD     DE,submitFCB
0378: E089 CD 16 E1               CALL   OpenFile
0379: E08C CA D3 E0               JP     Z,NotSubmitFile      ; skip if no submit file
0380: E08F 3A EA E6               LD     A,(subRecordCount)
0381: E092 3D                     DEC    A                    ; read last record(s) first
0382: E093 32 EB E6               LD     (subCurrentRecord),A ; current record to read
0383: E096 11 E8 E6               LD     DE,submitFCB
0384: E099 CD 34 E1               CALL   DiskRead             ; end of file if last record
0385: E09C C2 D3 E0               JP     NZ,NotSubmitFile
0386: E09F         ; disk read is ok, transfer to commandBuffer
0387: E09F 11 14 E7               LD     DE,CommandLength
0388: E0A2 21 80 00               LD     HL,DMABuffer
0389: E0A5 06 80                  LD     B,cpmRecordSize      ; number of bytes to Copy
0390: E0A7 CD 4B E3               CALL   CopyHL2DEforB
0391: E0AA         ; line is transferred, close the file with a deleted record
0392: E0AA 21 E9 E6               LD     HL,subModuleNumber
0393: E0AD 36 00                  LD     (HL),0               ; clear fwflag
0394: E0AF 23                     INC    HL
0395: E0B0 35                     DEC    M                    ; one less record
0396: E0B1 11 E8 E6               LD     DE,submitFCB
0397: E0B4 CD 25 E1               CALL   CloseFile
0398: E0B7 CA D3 E0               JP     Z,NotSubmitFile
0399: E0BA         ; CloseFile went ok, return to original drive
0400: E0BA 3A 0E E7               LD     A,(currentDisk)
0401: E0BD B7                     OR     A
0402: E0BE C4 0B E1               CALL   NZ,SelectDisk
0403: E0C1         ; print to the 00
0404: E0C1 21 15 E7               LD     HL,commandBuffer
0405: E0C4 CD 2F E3               CALL   PrintStringNull
0406: E0C7 CD 6E E1               CALL   CheckForConsoleChar
0407: E0CA CA E4 E0               JP     Z,NoRead
0408: E0CD CD 7C E1               CALL   DeleteSubmitFile
0409: E0D0 C3 7C E1               JP     DeleteSubmitFile     ; break key depressed
0410: E0D3
0411: E0D3             NotSubmitFile:
0412: E0D3 CD 7C E1               CALL   DeleteSubmitFile
0413: E0D6         ; translate to upper case, store zero at end
0414: E0D6 CD 94 E1               CALL   SaveUser             ; user # save in case control c
0415: E0D9 0E 0A                  LD     C,fReadString
0416: E0DB 11 13 E7               LD     DE,MaxBufferLength
0417: E0DE CD 05 00               CALL   BDOSE
0418: E0E1 CD A3 E1               CALL   SetPage0CurDisk      ; no control c, so restore Pg0CurentDisk
0419: E0E4
0420: E0E4             NoRead:
0421: E0E4         ; set the last character to zero for later scans
0422: E0E4 21 14 E7               LD     HL,CommandLength
0423: E0E7 46                     LD     B,(HL)               ; length is in b
0424: E0E8             ReadCommand1:                      ; readcom0
0425: E0E8 23                     INC    HL
0426: E0E9 78                     LD     A,B
0427: E0EA B7                     OR     A                    ; end of scan?
0428: E0EB CA F7 E0               JP     Z,ReadCommand2
0429: E0EE 7E                     LD     A,(HL)               ; get character and translate
0430: E0EF CD 62 E3               CALL   UpCase
0431: E0F2 77                     LD     (HL),A
0432: E0F3 05                     DEC    B
0433: E0F4 C3 E8 E0               JP     ReadCommand1
0434: E0F7
0435: E0F7         ;end of scan, h,l address end of command
0436: E0F7             ReadCommand2:
0437: E0F7 77                     LD     (HL),A               ;store a zero
0438: E0F8 21 15 E7               LD     HL,commandBuffer
0439: E0FB 22 95 E7               LD     (commandAddress),HL  ; ready to scan to zero
0440: E0FE C9                     RET
0441: E0FF         ;----------------------------------------------------------------
0442: E0FF
0443: E0FF         ;----------------------------------------------------------------
0444: E0FF         ;----------------------------------------------------------------
0445: E0FF         ;----------------------------------------------------------------
0446: E0FF         ;----------------------------------------------------------------
0447: E0FF         ;return current user code in A
0448: E0FF             GetUser:
0449: E0FF 1E FF                  LD     E,0FFH               ; drop through to setuser
0450: E101         ;------
0451: E101             SetUser:
0452: E101 0E 20                  LD     C,fGetSetUserNumber
0453: E103 C3 05 00               JP     BDOSE                ; sets user number
0454: E106         ;-----------------------------
0455: E106             Initialize:
0456: E106 0E 0D                  LD     C,fResetSystem
0457: E108 C3 05 00               JP     BDOSE
0458: E10B         ;-----------------------------
0459: E10B             SelectDisk:
0460: E10B 5F                     LD     E,A
0461: E10C 0E 0E                  LD     C,fSelectDisk
0462: E10E C3 05 00               JP     BDOSE
0463: E111         ;-----------------------------
0464: E111         ;get the currently selected drive number to A
0465: E111             GetSelectedDrive:
0466: E111 0E 19                  LD     C,fGetCurrentDisk
0467: E113 C3 05 00               JP     BDOSE
0468: E116         ;-----------------------------
0469: E116         ;open the file given by (DE)
0470: E116             OpenFile:
0471: E116 0E 0F                  LD     C,fOpenFile
0472: E118 C3 66 E1               JP     BDOSandIncA
0473: E11B         ;--------
0474: E11B         ;open file for Command FCB
0475: E11B             OpenFile4CmdFCB:
0476: E11B AF                     XOR    A
0477: E11C 32 0C E7               LD     (currentRecord),A    ; clear next record to read
0478: E11F 11 EC E6               LD     DE,commandFCB
0479: E122 C3 16 E1               JP     OpenFile
0480: E125         ;-----------------------------
0481: E125         ;close the file given by (DE)
0482: E125             CloseFile:
0483: E125 0E 10                  LD     C,fCloseFile
0484: E127 C3 66 E1               JP     BDOSandIncA
0485: E12A         ;-----------------------------
0486: E12A         ;delete the file given by (DE)
0487: E12A             DeleteFile:
0488: E12A 0E 13                  LD     C,fDeleteFile
0489: E12C C3 05 00               JP     BDOSE
0490: E12F         ;-----------------------------
0491: E12F         ;make the file given by (DE)
0492: E12F             MakeFile:
0493: E12F 0E 16                  LD     C,fMakeFile
0494: E131 C3 66 E1               JP     BDOSandIncA
0495: E134         ;-----------------------------
0496: E134         ;read the next record from the file given by d,e
0497: E134             DiskRead:
0498: E134 0E 14                  LD     C,fReadSeq
0499: E136 C3 61 E1               JP     BDOSsetFlags
0500: E139         ;-----------
0501: E139         ;read next record from Command FCB
0502: E139             DiskReadCmdFCB:
0503: E139 11 EC E6               LD     DE,commandFCB
0504: E13C C3 34 E1               JP     DiskRead
0505: E13F         ;-----------------------------
0506: E13F         ;write the next record to the file given by (DE)
0507: E13F             DiskWrite:
0508: E13F 0E 15                  LD     C,fWriteSeq
0509: E141 C3 61 E1               JP     BDOSsetFlags
0510: E144         ;-----------------------------
0511: E144         ;search for the file given by d,e
0512: E144             SearchForFirst:
0513: E144 0E 11                  LD     C,fSearchFirst
0514: E146 C3 66 E1               JP     BDOSandIncA
0515: E149         ;-----
0516: E149         ;search for commandFCB file
0517: E149             Searc4CmdFcbFile:
0518: E149 11 EC E6               LD     DE,commandFCB
0519: E14C C3 44 E1               JP     SearchForFirst
0520: E14F         ;-----------------------------
0521: E14F         ;search for the next occurrence of the file given by d,e
0522: E14F             SearchForNext:
0523: E14F 0E 12                  LD     C,fSearchNext
0524: E151 C3 66 E1               JP     BDOSandIncA
0525: E154         ;-----------------------------
0526: E154         ; rename a file give bu (DE)
0527: E154             RenameFile:
0528: E154 0E 17                  LD     C,fRenameFile
0529: E156 C3 05 00               JP     BDOSE
0530: E159         ;-----------------------------
0531: E159         ;set default buffer dma address
0532: E159             SetDefaultDMA:
0533: E159 11 80 00               LD     DE,DMABuffer
0534: E15C         ;---------
0535: E15C         ;set dma address to d,e
0536: E15C             SetDMA:
0537: E15C 0E 1A                  LD     C,fSetDMA
0538: E15E C3 05 00               JP     BDOSE
0539: E161         ;-----------------------------
0540: E161         ; call BDOS and set Flags
0541: E161             BDOSsetFlags:
0542: E161 CD 05 00               CALL   BDOSE
0543: E164 B7                     OR     A                    ; set return code flags
0544: E165 C9                     RET
0545: E166         ;-----------------------------
0546: E166         ;call BDOS  - increment result - store in directory count
0547: E166             BDOSandIncA:
0548: E166 CD 05 00               CALL   BDOSE
0549: E169 32 0D E7               LD     (directoryCount),A
0550: E16C 3C                     INC    A
0551: E16D C9                     RET
0552: E16E         ;----------------------------------------------------------------
0553: E16E         ;----------------------------------------------------------------
0554: E16E         ;----------------------------------------------------------------
0555: E16E         ;check for a character ready at the console
0556: E16E             CheckForConsoleChar:
0557: E16E 0E 0B                  LD     C,fGetConsoleStatus
0558: E170 CD 05 00               CALL   BDOSE
0559: E173 B7                     OR     A
0560: E174 C8                     RET    Z                    ; return no char waiting
0561: E175 0E 01                  LD     C,fConsoleIn
0562: E177 CD 05 00               CALL   BDOSE                ; character cleared
0563: E17A B7                     OR     A
0564: E17B C9                     RET
0565: E17C         ;-----------------------------
0566: E17C         ;delete the submit file, and set submit flag to false
0567: E17C             DeleteSubmitFile:
0568: E17C 21 E7 E6               LD     HL,submitFlag
0569: E17F 7E                     LD     A,(HL)
0570: E180 B7                     OR     A
0571: E181 C8                     RET    Z                    ; return if no sub file
0572: E182 36 00                  LD     (HL),0               ; submit flag is set to false
0573: E184 AF                     XOR    A
0574: E185 CD 0B E1               CALL   SelectDisk           ; on drive a to erase file
0575: E188 11 E8 E6               LD     DE,submitFCB
0576: E18B CD 2A E1               CALL   DeleteFile
0577: E18E 3A 0E E7               LD     A,(currentDisk)
0578: E191 C3 0B E1               JP     SelectDisk           ;back to original drive
0579: E194         ;-----------------------------
0580: E194         ;save user#/disk# before possible ^c or transient
0581: E194             SaveUser:
0582: E194 CD FF E0               CALL   GetUser              ; code to a
0583: E197 87                     ADD    A,A
0584: E198 87                     ADD    A,A
0585: E199 87                     ADD    A,A
0586: E19A 87                     ADD    A,A                  ; rotate left
0587: E19B 21 0E E7               LD     HL,currentDisk
0588: E19E B6                     OR     M                    ; msn 4b=user - lsn 4b=disk
0589: E19F 32 04 00               LD     (Pg0CurentDisk),A    ; stored away in memory for later
0590: E1A2 C9                     RET
0591: E1A3         ;-----------------------------
0592: E1A3         ; set Pg0CurentDisk to current disk
0593: E1A3             SetPage0CurDisk:
0594: E1A3 3A 0E E7               LD     A,(currentDisk)
0595: E1A6 32 04 00               LD     (Pg0CurentDisk),A    ; user/disk
0596: E1A9 C9                     RET
0597: E1AA         ;-----------------------------
0598: E1AA         ;equivalent to fillfcb(0)
0599: E1AA             FillFCB0:
0600: E1AA 3E 00                  LD     A,0
0601: E1AC             FillFCB:
0602: E1AC 21 EC E6               LD     HL,commandFCB
0603: E1AF CD 54 E3               CALL   AddA2HL
0604: E1B2 E5                     PUSH   HL
0605: E1B3 E5                     PUSH   HL                   ; fcb rescanned at end
0606: E1B4 AF                     XOR    A
0607: E1B5 32 0F E7               LD     (selectedDisk),A     ; clear selected disk (in case A:...)
0608: E1B8 2A 95 E7               LD     HL,(commandAddress)
0609: E1BB EB                     EX     DE,HL                ; command address in d,e
0610: E1BC CD 5C E2               CALL   NextNonBlankChar     ; move to first non-blank character
0611: E1BF EB                     EX     DE,HL
0612: E1C0 22 11 E7               LD     (fillFCBStart),HL    ; in case of errors
0613: E1C3 EB                     EX     DE,HL
0614: E1C4 E1                     POP    HL                   ; d,e has command, h,l has fcb address
0615: E1C5         ; look for preceding file name A: B: ...
0616: E1C5 1A                     LD     A,(DE)
0617: E1C6 B7                     OR     A
0618: E1C7 CA D5 E1               JP     Z,FillSetCurrentDisk ; use current disk if empty command
0619: E1CA DE 40                  SBC    A,040H               ; ASCII_A-1
0620: E1CC 47                     LD     B,A                  ; disk name held in b if : follows
0621: E1CD 13                     INC    DE
0622: E1CE 1A                     LD     A,(DE)
0623: E1CF FE 3A                  CP     COLON
0624: E1D1 CA DC E1               JP     Z,FillSetDiskName    ; set disk name if :
0625: E1D4
0626: E1D4             setcur:
0627: E1D4 1B                     DEC    DE                   ; back to first character of command
0628: E1D5
0629: E1D5             FillSetCurrentDisk:
0630: E1D5 3A 0E E7               LD     A,(currentDisk)
0631: E1D8 77                     LD     (HL),A
0632: E1D9 C3 E2 E1               JP     SetFileName
0633: E1DC
0634: E1DC         ;set disk to name in register b
0635: E1DC             FillSetDiskName:
0636: E1DC 78                     LD     A,B
0637: E1DD 32 0F E7               LD     (selectedDisk),A     ; mark as disk selected
0638: E1E0 70                     LD     (HL),B
0639: E1E1 13                     INC    DE                   ; past the :
0640: E1E2         ;set the file name field
0641: E1E2             SetFileName:
0642: E1E2 06 08                  LD     B,8                  ; file name length (max)
0643: E1E4             SetFileName1:
0644: E1E4 CD 66 E2               CALL   NextDelimiter
0645: E1E7 CA 05 E2               JP     Z,PadTheName         ; not a delimiter
0646: E1EA 23                     INC    HL
0647: E1EB FE 2A                  CP     ASTERISK
0648: E1ED C2 F5 E1               JP     NZ,SetFileName2      ; must be ?'s
0649: E1F0 36 3F                  LD     (HL),QMARK
0650: E1F2 C3 F7 E1               JP     SetFileName3         ; to dec count
0651: E1F5
0652: E1F5             SetFileName2:
0653: E1F5 77                     LD     (HL),A               ; store character to fcb
0654: E1F6 13                     INC    DE
0655: E1F7             SetFileName3:
0656: E1F7 05                     DEC    B                    ; count down length
0657: E1F8 C2 E4 E1               JP     NZ,SetFileName1
0658: E1FB             TruncateName:
0659: E1FB CD 66 E2               CALL   NextDelimiter
0660: E1FE CA 0C E2               JP     Z,SetTypeField       ; set type field if delimiter
0661: E201 13                     INC    DE
0662: E202 C3 FB E1               JP     TruncateName
0663: E205
0664: E205             PadTheName:
0665: E205 23                     INC    HL
0666: E206 36 20                  LD     (HL),SPACE
0667: E208 05                     DEC    B
0668: E209 C2 05 E2               JP     NZ,PadTheName
0669: E20C             SetTypeField:
0670: E20C 06 03                  LD     B,3
0671: E20E FE 2E                  CP     PERIOD
0672: E210 C2 35 E2               JP     NZ,PadTypeField      ; skip the type field if no .
0673: E213 13                     INC    DE                   ; past the ., to the file type field
0674: E214             SetTypeField1:
0675: E214 CD 66 E2               CALL   NextDelimiter
0676: E217 CA 35 E2               JP     Z,PadTypeField
0677: E21A 23                     INC    HL
0678: E21B FE 2A                  CP     ASTERISK
0679: E21D C2 25 E2               JP     NZ,SetTypeField2
0680: E220 36 3F                  LD     (HL),QMARK           ;since * specified
0681: E222 C3 27 E2               JP     SetTypeField3
0682: E225
0683: E225         ;  not a *, so copy to type field
0684: E225             SetTypeField2:
0685: E225 77                     LD     (HL),A
0686: E226 13                     INC    DE
0687: E227             SetTypeField3:
0688: E227 05                     DEC    B
0689: E228 C2 14 E2               JP     NZ,SetTypeField1
0690: E22B         ; end of type field, truncate the rest
0691: E22B             TruncateType:
0692: E22B CD 66 E2               CALL   NextDelimiter
0693: E22E CA 3C E2               JP     Z,FillRestofFCB
0694: E231 13                     INC    DE
0695: E232 C3 2B E2               JP     TruncateType
0696: E235
0697: E235             PadTypeField:
0698: E235 23                     INC    HL
0699: E236 36 20                  LD     (HL),SPACE
0700: E238 05                     DEC    B
0701: E239 C2 35 E2               JP     NZ,PadTypeField
0702: E23C         ; fill end of the filename/filetype fill, save command address
0703: E23C             FillRestofFCB:
0704: E23C         ; fill the remaining fields for the fcb
0705: E23C 06 03                  LD     B,3
0706: E23E             FillRestofFCB1:
0707: E23E 23                     INC    HL
0708: E23F 36 00                  LD     (HL),0
0709: E241 05                     DEC    B
0710: E242 C2 3E E2               JP     NZ,FillRestofFCB1
0711: E245 EB                     EX     DE,HL
0712: E246 22 95 E7               LD     (commandAddress),HL  ; set new starting point
0713: E249         ; recover the start address of the fcb and count ?'s
0714: E249 E1                     POP    HL
0715: E24A 01 0B 00               LD     BC,11                ; b=0, c=8+3
0716: E24D             QuestionMarkCount:
0717: E24D 23                     INC    HL
0718: E24E 7E                     LD     A,(HL)
0719: E24F FE 3F                  CP     QMARK
0720: E251 C2 55 E2               JP     NZ,QuestionMarkCount1
0721: E254         ; ? found, count it in b
0722: E254 04                     INC    B
0723: E255             QuestionMarkCount1:
0724: E255 0D                     DEC    C
0725: E256 C2 4D E2               JP     NZ,QuestionMarkCount
0726: E259         ; number of ?'s in c, move to a and return with flags set
0727: E259 78                     LD     A,B
0728: E25A B7                     OR     A
0729: E25B C9                     RET
0730: E25C         ;-----------------------------
0731: E25C         ;find the next non blank character in line pointed to by DE
0732: E25C             NextNonBlankChar:
0733: E25C 1A                     LD     A,(DE)
0734: E25D B7                     OR     A
0735: E25E C8                     RET    Z                    ; treat end of line as blank
0736: E25F FE 20                  CP     SPACE
0737: E261 C0                     RET    NZ
0738: E262 13                     INC    DE
0739: E263 C3 5C E2               JP     NextNonBlankChar
0740: E266         ;-----------------------------
0741: E266         ;find thedelimiter in line pointed to by DE
0742: E266             NextDelimiter:
0743: E266 1A                     LD     A,(DE)
0744: E267 B7                     OR     A
0745: E268 C8                     RET    Z                    ; not the last element
0746: E269 FE 20                  CP     SPACE
0747: E26B DA 7C E3               JP     C,CommandError       ; non graphic
0748: E26E C8                     RET    Z                    ; treat blank as delimiter
0749: E26F FE 3D                  CP     EQUAL_SIGN
0750: E271 C8                     RET    Z
0751: E272 FE 5F                  CP     UNDER_SCORE          ; left arrow ?
0752: E274 C8                     RET    Z
0753: E275 FE 2E                  CP     PERIOD
0754: E277 C8                     RET    Z
0755: E278 FE 3A                  CP     COLON
0756: E27A C8                     RET    Z
0757: E27B FE 3B                  CP     SEMICOLON
0758: E27D C8                     RET    Z
0759: E27E FE 3C                  CP     LESS_THAN
0760: E280 C8                     RET    Z
0761: E281 FE 3E                  CP     GREATER_THAN
0762: E283 C8                     RET    Z
0763: E284 C9                     RET                         ; delimiter not found
0764: E285         ;-----------------------------
0765: E285         ; get number from the command line
0766: E285             GetNumberFromCmdLine:
0767: E285 CD AA E1               CALL   FillFCB0             ; should be number
0768: E288 3A 0F E7               LD     A,(selectedDisk)
0769: E28B B7                     OR     A
0770: E28C C2 7C E3               JP     NZ,CommandError      ; cannot be prefixed
0771: E28F         ; convert the byte value in commandFCB to binary
0772: E28F 21 ED E6               LD     HL,commandFCB+1
0773: E292 01 0B 00               LD     BC,11                ;(b=0, c=11)
0774: E295         ; value accumulated in b, c counts name length to zero
0775: E295             GetNumericValue:
0776: E295 7E                     LD     A,(HL)
0777: E296 FE 20                  CP     SPACE
0778: E298 CA C0 E2               JP     Z,GetNumericValue1
0779: E29B         ; more to scan, convert char to binary and add
0780: E29B 23                     INC    HL
0781: E29C D6 30                  SUB    ASCII_ZERO
0782: E29E FE 0A                  CP     10
0783: E2A0 D2 7C E3               JP     NC,CommandError      ; valid?
0784: E2A3 57                     LD     D,A                  ; save value
0785: E2A4 78                     LD     A,B                  ; mult by 10
0786: E2A5 E6 E0                  AND    11100000B
0787: E2A7 C2 7C E3               JP     NZ,CommandError
0788: E2AA 78                     LD     A,B                  ; recover value
0789: E2AB 07                     RLCA
0790: E2AC 07                     RLCA
0791: E2AD 07                     RLCA                        ; *8
0792: E2AE 80                     ADD    A,B
0793: E2AF DA 7C E3               JP     C,CommandError
0794: E2B2 80                     ADD    A,B
0795: E2B3 DA 7C E3               JP     C,CommandError       ; *8+*2 = *10
0796: E2B6 82                     ADD    A,D
0797: E2B7 DA 7C E3               JP     C,CommandError       ; +digit
0798: E2BA 47                     LD     B,A
0799: E2BB 0D                     DEC    C
0800: E2BC C2 95 E2               JP     NZ,GetNumericValue   ; for another digit
0801: E2BF C9                     RET
0802: E2C0             GetNumericValue1:                      ; conv1 end of digits, check for all blanks
0803: E2C0 7E                     LD     A,(HL)
0804: E2C1 FE 20                  CP     SPACE
0805: E2C3 C2 7C E3               JP     NZ,CommandError      ;blanks?
0806: E2C6 23                     INC    HL
0807: E2C7 0D                     DEC    C
0808: E2C8 C2 C0 E2               JP     NZ,GetNumericValue1
0809: E2CB 78                     LD     A,B                  ;recover value
0810: E2CC C9                     RET
0811: E2CD         ;-----------------------------
0812: E2CD         ;-----------------------------
0813: E2CD         ;intrinsic function names four characters each
0814: E2CD             intrinsicFunctionNames:
0815: E2CD 44 49 52 20                DB     'DIR '
0816: E2D1 45 52 41 20                DB     'ERA '
0817: E2D5 54 59 50 45                DB     'TYPE'
0818: E2D9 53 41 56 45                DB     'SAVE'
0819: E2DD 52 45 4E 20                DB     'REN '
0820: E2E1 55 53 45 52                DB     'USER'
0821: E2E5             IntrinsicFunctionCount EQU    (($-intrinsicFunctionNames)/iFunctionNameSize) + 1
0822: E2E5         ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
0823: E2E5
0824: E2E5
0825: E2E5         ;-----------------------------
0826: E2E5         ;look for intrinsic functions (commandFCB has been filled)
0827: E2E5             IntrinsicFunction:
0828: E2E5 21 CD E2               LD     HL,intrinsicFunctionNames
0829: E2E8 0E 00                  LD     C,0
0830: E2EA             IntrinsicFunction1:
0831: E2EA 79                     LD     A,C
0832: E2EB FE 06                  CP     IntrinsicFunctionCount
0833: E2ED D0                     RET    NC                   ; exit if done
0834: E2EE 11 ED E6               LD     DE,commandFCB+1      ; beginning of name
0835: E2F1 06 04                  LD     B,iFunctionNameSize  ; length of match is in b
0836: E2F3             IntrinsicFunction2:
0837: E2F3 1A                     LD     A,(DE)
0838: E2F4 BE                     CP     M                    ; match?
0839: E2F5 C2 06 E3               JP     NZ,IntrinsicFunction3 ; skip if no match
0840: E2F8 13                     INC    DE
0841: E2F9 23                     INC    HL
0842: E2FA 05                     DEC    B
0843: E2FB C2 F3 E2               JP     NZ,IntrinsicFunction2 ; loop while matching
0844: E2FE         ; complete match on name, check for blank in fcb
0845: E2FE 1A                     LD     A,(DE)
0846: E2FF FE 20                  CP     SPACE
0847: E301 C2 0B E3               JP     NZ,IntrinsicFunction4 ; otherwise matched
0848: E304 79                     LD     A,C
0849: E305 C9                     RET                         ; with intrinsic number in A
0850: E306
0851: E306             IntrinsicFunction3:
0852: E306 23                     INC    HL
0853: E307 05                     DEC    B
0854: E308 C2 06 E3               JP     NZ,IntrinsicFunction3
0855: E30B
0856: E30B             IntrinsicFunction4:                      ; try next intrinsic
0857: E30B 0C                     INC    C
0858: E30C C3 EA E2               JP     IntrinsicFunction1   ; for another round
0859: E30F         ;-----------------------------
0860: E30F         ;*****************************************************************
0861: E30F         ;************************ Utilities ******************************
0862: E30F         ;*****************************************************************
0863: E30F         ;-----------------------------
0864: E30F             PrintSpace:
0865: E30F 3E 20                  LD     A,SPACE
0866: E311 C3 1E E3               JP     PrintSaveBC
0867: E314         ;-----------------------------
0868: E314             CrLf:
0869: E314 3E 0D                  LD     A,CR
0870: E316 CD 1E E3               CALL   PrintSaveBC
0871: E319 3E 0A                  LD     A,LF
0872: E31B C3 1E E3               JP     PrintSaveBC
0873: E31E         ;-----------------------------
0874: E31E         ;print character, but save b,c registers
0875: E31E             PrintSaveBC:
0876: E31E C5                     PUSH   BC
0877: E31F CD 24 E3               CALL   PrintChar
0878: E322 C1                     POP    BC
0879: E323 C9                     RET
0880: E324         ;-----------------------------
0881: E324             PrintChar:
0882: E324 5F                     LD     E,A
0883: E325 0E 02                  LD     C,fConsoleOut
0884: E327 C3 05 00               JP     BDOSE
0885: E32A         ;-----------------------------
0886: E32A         ;print CRLF then null terminated string at (BC)
0887: E32A             PrintCrLfStringNull:
0888: E32A C5                     PUSH   BC
0889: E32B CD 14 E3               CALL   CrLf
0890: E32E E1                     POP    HL                   ;now print the string
0891: E32F         ;print null terminated string at (HL)
0892: E32F             PrintStringNull:
0893: E32F 7E                     LD     A,(HL)
0894: E330 B7                     OR     A
0895: E331 C8                     RET    Z                    ; stop on 00
0896: E332 23                     INC    HL
0897: E333 E5                     PUSH   HL                   ; ready for next
0898: E334 CD 24 E3               CALL   PrintChar
0899: E337 E1                     POP    HL                   ; character printed
0900: E338 C3 2F E3               JP     PrintStringNull      ;for
0901: E33B         ;-----------------------------
0902: E33B         ;print no file message
0903: E33B             PrintNoFile:
0904: E33B 01 41 E3               LD     BC,msgNoFile
0905: E33E C3 2A E3               JP     PrintCrLfStringNull
0906: E341
0907: E341 4E 4F 20 46 49 4C 45 00     msgNoFile: DB     'NO FILE',0
0908: E349         ;-----------------------------
0909: E349         ;move 3 characters from h,l to d,e addresses
0910: E349             CopyHL2DE3:
0911: E349 06 03                  LD     B,3
0912: E34B             CopyHL2DEforB:
0913: E34B 7E                     LD     A,(HL)
0914: E34C 12                     LD     (DE),AE
0915: E34D 23                     INC    HL
0916: E34E 13                     INC    DE
0917: E34F 05                     DEC    B
0918: E350 C2 4B E3               JP     NZ,CopyHL2DEforB
0919: E353 C9                     RET
0920: E354         ;-----------------------------
0921: E354         ;return (HL) = (A) + (HL)
0922: E354             AddA2HL:
0923: E354 85                     ADD    A,L
0924: E355 6F                     LD     L,A
0925: E356 D0                     RET    NC
0926: E357 24                     INC    H
0927: E358 C9                     RET
0928: E359         ;-----------------------------
0929: E359         ;DMABuffer + a + c to h,l followed by fetch
0930: E359             GetByteAtAandCandDMA:
0931: E359 21 80 00               LD     HL,DMABuffer         ; 0080H
0932: E35C 81                     ADD    A,C
0933: E35D CD 54 E3               CALL   AddA2HL
0934: E360 7E                     LD     A,(HL)
0935: E361 C9                     RET
0936: E362         ;-----------------------------
0937: E362         ;convert character in register A to upper case
0938: E362             UpCase:
0939: E362 FE 61                  CP     061H
0940: E364 D8                     RET    C                    ;return if below lower case a
0941: E365 FE 7B                  CP     07BH
0942: E367 D0                     RET    NC                   ;return if above lower case z
0943: E368 E6 5F                  AND    05FH
0944: E36A C9                     RET
0945: E36B         ;-----------------------------
0946: E36B         ;-----------------------------
0947: E36B         ;*****************************************************************
0948: E36B         ;************************ Error messages ******************************
0949: E36B         ;*****************************************************************
0950: E36B         ;print the read error message
0951: E36B             PrintReadError:
0952: E36B 01 71 E3               LD     BC,msgReadErr
0953: E36E C3 2A E3               JP     PrintCrLfStringNull
0954: E371             msgReadErr:
0955: E371 52 45 41 44 20 45 52 52 4F 52 00                DB     'READ ERROR',0
0956: E37C         ;-----------------------------
0957: E37C
0958: E37C
0959: E37C         ;*****************************************************************
0960: E37C         ;-----------------------------
0961: E37C         ;error in command string
0962: E37C         ;starting at position;'fillFCBStart' and ending with first delimiter
0963: E37C
0964: E37C             CommandError:
0965: E37C CD 14 E3               CALL   CrLf                 ; space to next line
0966: E37F 2A 11 E7               LD     HL,(fillFCBStart)    ; h,l address first to print
0967: E382             CommandError1:                      ; print characters until blank or zero
0968: E382 7E                     LD     A,(HL)
0969: E383 FE 20                  CP     SPACE
0970: E385 CA 95 E3               JP     Z,CommandError2      ; not blank
0971: E388 B7                     OR     A
0972: E389 CA 95 E3               JP     Z,CommandError2      ; not zero, so print it
0973: E38C E5                     PUSH   HL
0974: E38D CD 24 E3               CALL   PrintChar
0975: E390 E1                     POP    HL
0976: E391 23                     INC    HL
0977: E392 C3 82 E3               JP     CommandError1        ; for another character
0978: E395             CommandError2:                      ; print question mark,and delete sub file
0979: E395 3E 3F                  LD     A,QMARK
0980: E397 CD 24 E3               CALL   PrintChar
0981: E39A CD 14 E3               CALL   CrLf
0982: E39D CD 7C E1               CALL   DeleteSubmitFile
0983: E3A0 C3 29 E0               JP     Ccp                  ; restart with next command
0984: E3A3         ;--------------------------------------------------------
0985: E3A3         ;reset disk
0986: E3A3             ResetDisk:
0987: E3A3 3A 0F E7               LD     A,(selectedDisk)
0988: E3A6 B7                     OR     A
0989: E3A7 C8                     RET    Z                    ; no action if not selected
0990: E3A8 3D                     DEC    A
0991: E3A9 21 0E E7               LD     HL,currentDisk
0992: E3AC BE                     CP     M
0993: E3AD C8                     RET    Z                    ; same disk
0994: E3AE 3A 0E E7               LD     A,(currentDisk)
0995: E3B1 C3 0B E1               JP     SelectDisk
0996: E3B4         ;--------------------------------------------------------
0997: E3B4         ;reset disk before end of command check
0998: E3B4             ResetDiskAtCmdEnd:
0999: E3B4 CD A3 E3               CALL   ResetDisk
1000: E3B7         ;end of intrinsic command
1001: E3B7             EndCommand:
1002: E3B7 CD AA E1               CALL   FillFCB0             ; to check for garbage at end of line
1003: E3BA 3A ED E6               LD     A,(commandFCB)+1
1004: E3BD D6 20                  SUB    SPACE
1005: E3BF 21 0F E7               LD     HL,selectedDisk
1006: E3C2 B6                     OR     M
1007: E3C3         ; 0 in accumulator if no disk selected, and blank fcb
1008: E3C3 C2 7C E3               JP     NZ,CommandError
1009: E3C6 C3 29 E0               JP     Ccp
1010: E3C9         ;*****************************************************************
1011: E3C9         ;************************ CCP Commands ***************************
1012: E3C9         ;*****************************************************************
1013: E3C9
1014: E3C9         ;******************** Directory Listing ***************************
1015: E3C9         ;Directory Listing
1016: E3C9             ccpDirectory:
1017: E3C9 CD AA E1               CALL   FillFCB0             ; commandFCB gets file name
1018: E3CC CD D5 E6               CALL   SetDisk4Cmd          ; change disk drives if requested
1019: E3CF 21 ED E6               LD     HL,commandFCB+1
1020: E3D2 7E                     LD     A,(HL)               ; may be empty request
1021: E3D3 FE 20                  CP     SPACE
1022: E3D5 C2 E1 E3               JP     NZ,ccpDir2           ; skip fill of ??? if not blank
1023: E3D8         ; set commandFCB to all ??? for current disk
1024: E3D8 06 0B                  LD     B,11                 ; length of fill ????????.???
1025: E3DA             ccpDir1:
1026: E3DA 36 3F                  LD     (HL),QMARK
1027: E3DC 23                     INC    HL
1028: E3DD 05                     DEC    B
1029: E3DE C2 DA E3               JP     NZ,ccpDir1
1030: E3E1         ; not a blank request, must be in commandFCB
1031: E3E1             ccpDir2:
1032: E3E1 1E 00                  LD     E,0
1033: E3E3 D5                     PUSH   DE                   ; E counts directory entries
1034: E3E4 CD 49 E1               CALL   Searc4CmdFcbFile     ; first one has been found
1035: E3E7 CC 3B E3               CALL   Z,PrintNoFile        ; not found message
1036: E3EA             ccpDir3:
1037: E3EA CA 6D E4               JP     Z,ccpDirEnd
1038: E3ED         ; found, but may be system file
1039: E3ED 3A 0D E7               LD     A,(directoryCount)   ; get the location of the element
1040: E3F0 0F                     RRCA
1041: E3F1 0F                     RRCA
1042: E3F2 0F                     RRCA
1043: E3F3 E6 60                  AND    1100000B
1044: E3F5 4F                     LD     C,A
1045: E3F6         ; c contains base index into DMABuffer for dir entry
1046: E3F6 3E 0A                  LD     A,fcbSystemFileIndex ; System File Location in FCB
1047: E3F8 CD 59 E3               CALL   GetByteAtAandCandDMA ; value to A
1048: E3FB 17                     RLA
1049: E3FC DA 61 E4               JP     C,ccpDir7            ; skip if system file c holds index into buffer
1050: E3FF         ;  another fcb found, new line?
1051: E3FF D1                     POP    DE                   ; get directory entry count (E)
1052: E400 7B                     LD     A,E
1053: E401 1C                     INC    E
1054: E402 D5                     PUSH   DE                   ; save dir entry count
1055: E403 E6 03                  AND    11B                  ; e=0,1,2,3,...new line if mod 4 = 0
1056: E405 F5                     PUSH   AF                   ; and save the test
1057: E406 C2 1E E4               JP     NZ,ccpDirHeader      ; header on current line
1058: E409         ; print the header drive with Colon ie A:
1059: E409 CD 14 E3               CALL   CrLf
1060: E40C C5                     PUSH   BC
1061: E40D CD 11 E1               CALL   GetSelectedDrive
1062: E410 C1                     POP    BC
1063: E411 C6 41                  ADD    A,ASCII_A
1064: E413 CD 1E E3               CALL   PrintSaveBC
1065: E416 3E 3A                  LD     A,COLON
1066: E418 CD 1E E3               CALL   PrintSaveBC          ; just printed drive with Colon ie A:
1067: E41B C3 26 E4               JP     ccpDirHeader1        ; skip current line hdr
1068: E41E
1069: E41E             ccpDirHeader:
1070: E41E CD 0F E3               CALL   PrintSpace           ; after last one
1071: E421 3E 3A                  LD     A,COLON
1072: E423 CD 1E E3               CALL   PrintSaveBC
1073: E426             ccpDirHeader1:
1074: E426 CD 0F E3               CALL   PrintSpace
1075: E429         ; compute position of name in buffer
1076: E429 06 01                  LD     B,1                  ; start with first character of name
1077: E42B             ccpDir4:
1078: E42B 78                     LD     A,B
1079: E42C CD 59 E3               CALL   GetByteAtAandCandDMA ; DMABuffer+a+c fetched
1080: E42F E6 7F                  AND    ASCII_MASK           ; mask flags
1081: E431         ; may delete trailing blanks
1082: E431 FE 20                  CP     SPACE
1083: E433 C2 4B E4               JP     NZ,ccpDir5           ; check for blank type
1084: E436 F1                     POP    AF
1085: E437 F5                     PUSH   AF                   ; may be 3rd item
1086: E438 FE 03                  CP     3
1087: E43A C2 49 E4               JP     NZ,ccpDirSpace       ; place blank at end if not
1088: E43D 3E 09                  LD     A,9
1089: E43F CD 59 E3               CALL   GetByteAtAandCandDMA ; first char of type
1090: E442 E6 7F                  AND    ASCII_MASK
1091: E444 FE 20                  CP     SPACE
1092: E446 CA 60 E4               JP     Z,ccpDir6
1093: E449         ; not a blank in the file type field
1094: E449             ccpDirSpace:
1095: E449 3E 20                  LD     A,SPACE              ; restore trailing filename chr
1096: E44B             ccpDir5:
1097: E44B CD 1E E3               CALL   PrintSaveBC          ; char printed
1098: E44E 04                     INC    B
1099: E44F 78                     LD     A,B
1100: E450 FE 0C                  CP     12
1101: E452 D2 60 E4               JP     NC,ccpDir6
1102: E455         ; check for break between names
1103: E455 FE 09                  CP     9
1104: E457 C2 2B E4               JP     NZ,ccpDir4           ; for another char
1105: E45A
1106: E45A CD 0F E3               CALL   PrintSpace           ; print a blank between names
1107: E45D C3 2B E4               JP     ccpDir4
1108: E460
1109: E460             ccpDir6:                        ; end of current entry
1110: E460 F1                     POP    AF                   ; discard the directory counter (mod 4)
1111: E461             ccpDir7:
1112: E461 CD 6E E1               CALL   CheckForConsoleChar  ; check for interrupt at keyboard
1113: E464 C2 6D E4               JP     NZ,ccpDirEnd         ; abort directory search
1114: E467 CD 4F E1               CALL   SearchForNext
1115: E46A C3 EA E3               JP     ccpDir3              ; for another entry
1116: E46D             ccpDirEnd:
1117: E46D D1                     POP    DE                   ; discard directory counter
1118: E46E C3 B4 E3               JP     ResetDiskAtCmdEnd
1119: E471         ;
1120: E471
1121: E471         ;*****************************************************************
1122: E471             ccpErase:
1123: E471 CD AA E1               CALL   FillFCB0             ; cannot be all ???'s
1124: E474 FE 0B                  CP     11
1125: E476 C2 94 E4               JP     NZ,ccpEraseAll
1126: E479         ; erasing all of the disk
1127: E479 01 A4 E4               LD     BC,msgEraseAll
1128: E47C CD 2A E3               CALL   PrintCrLfStringNull
1129: E47F
1130: E47F CD 76 E0               CALL   ReadCommand
1131: E482 21 14 E7               LD     HL,CommandLength
1132: E485 35                     DEC    M
1133: E486 C2 29 E0               JP     NZ,Ccp               ;bad input
1134: E489 23                     INC    HL
1135: E48A 7E                     LD     A,(HL)
1136: E48B FE 59                  CP     ASCII_Y
1137: E48D C2 29 E0               JP     NZ,Ccp
1138: E490         ; ok, erase the entire diskette
1139: E490 23                     INC    HL
1140: E491 22 95 E7               LD     (commandAddress),HL  ; otherwise error at ResetDiskAtCmdEnd
1141: E494             ccpEraseAll:
1142: E494 CD D5 E6               CALL   SetDisk4Cmd
1143: E497 11 EC E6               LD     DE,commandFCB
1144: E49A CD 2A E1               CALL   DeleteFile
1145: E49D 3C                     INC    A                    ; 255 returned if not found
1146: E49E CC 3B E3               CALL   Z,PrintNoFile        ; no file message if so
1147: E4A1 C3 B4 E3               JP     ResetDiskAtCmdEnd
1148: E4A4         ;
1149: E4A4             msgEraseAll:
1150: E4A4 41 4C 4C 20 28 59 2F 4E 29 3F 00                DB     'ALL (Y/N)?',0
1151: E4AF         ;*****************************************************************
1152: E4AF         ; Type file
1153: E4AF             ccpType:
1154: E4AF CD AA E1               CALL   FillFCB0
1155: E4B2 C2 7C E3               JP     NZ,CommandError      ; don't allow ?'s in file name
1156: E4B5 CD D5 E6               CALL   SetDisk4Cmd
1157: E4B8 CD 1B E1               CALL   OpenFile4CmdFCB      ; open the file
1158: E4BB CA F9 E4               JP     Z,ccpTypeError       ; zero flag indicates not found
1159: E4BE         ; file opened, read 'til eof
1160: E4BE CD 14 E3               CALL   CrLf
1161: E4C1 21 10 E7               LD     HL,bufferPointer
1162: E4C4 36 FF                  LD     (HL),255             ; read first buffer
1163: E4C6             ccpType1:                       ; loop on bufferPointer
1164: E4C6 21 10 E7               LD     HL,bufferPointer
1165: E4C9 7E                     LD     A,(HL)
1166: E4CA FE 80                  CP     128                  ; end buffer
1167: E4CC DA D9 E4               JP     C,ccpType2
1168: E4CF E5                     PUSH   HL                   ; carry if 0,1,...,127
1169: E4D0         ; read another buffer full
1170: E4D0 CD 39 E1               CALL   DiskReadCmdFCB
1171: E4D3 E1                     POP    HL                   ; recover address of bufferPointer
1172: E4D4 C2 F2 E4               JP     NZ,ccpTypeEOF        ; hard end of file
1173: E4D7 AF                     XOR    A
1174: E4D8 77                     LD     (HL),A               ; bufferPointer = 0
1175: E4D9         ; read character at bufferPointer and print
1176: E4D9             ccpType2:
1177: E4D9 34                     INC    M                    ; bufferPointer = bufferPointer + 1
1178: E4DA 21 80 00               LD     HL,DMABuffer
1179: E4DD CD 54 E3               CALL   AddA2HL              ; h,l addresses char
1180: E4E0 7E                     LD     A,(HL)
1181: E4E1 FE 1A                  CP     END_OF_FILE
1182: E4E3 CA B4 E3               JP     Z,ResetDiskAtCmdEnd
1183: E4E6 CD 24 E3               CALL   PrintChar
1184: E4E9 CD 6E E1               CALL   CheckForConsoleChar
1185: E4EC C2 B4 E3               JP     NZ,ResetDiskAtCmdEnd ; abort if break
1186: E4EF C3 C6 E4               JP     ccpType1             ; for another character
1187: E4F2
1188: E4F2             ccpTypeEOF:
1189: E4F2 3D                     DEC    A
1190: E4F3 CA B4 E3               JP     Z,ResetDiskAtCmdEnd
1191: E4F6 CD 6B E3               CALL   PrintReadError
1192: E4F9             ccpTypeError:
1193: E4F9 CD A3 E3               CALL   ResetDisk
1194: E4FC C3 7C E3               JP     CommandError
1195: E4FF         ;*****************************************************************
1196: E4FF         ; save save memory image
1197: E4FF         ;*****************************************************************
1198: E4FF             ccpSave:
1199: E4FF CD 85 E2               CALL   GetNumberFromCmdLine ; value to register a
1200: E502 F5                     PUSH   AF                   ; save it for later
1201: E503         ; should be followed by a file to save the memory image
1202: E503 CD AA E1               CALL   FillFCB0
1203: E506 C2 7C E3               JP     NZ,CommandError      ; cannot be ambiguous
1204: E509 CD D5 E6               CALL   SetDisk4Cmd          ; may be a disk change
1205: E50C 11 EC E6               LD     DE,commandFCB
1206: E50F D5                     PUSH   DE
1207: E510 CD 2A E1               CALL   DeleteFile           ; existing file removed
1208: E513 D1                     POP    DE
1209: E514 CD 2F E1               CALL   MakeFile             ; create a new file on disk
1210: E517 CA 4D E5               JP     Z,ccpSaveError       ; no directory space
1211: E51A AF                     XOR    A
1212: E51B 32 0C E7               LD     (currentRecord),A    ; clear next record field
1213: E51E F1                     POP    AF                   ; #pages to write is in a, change to #sectors
1214: E51F 6F                     LD     L,A
1215: E520 26 00                  LD     H,0
1216: E522 29                     ADD    HL,HL
1217: E523
1218: E523 11 00 01               LD     DE,TPA               ; h,l is sector count, d,e is load address
1219: E526             ccpSave1:                       ; save0 check for sector count zero
1220: E526 7C                     LD     A,H
1221: E527 B5                     OR     L
1222: E528 CA 43 E5               JP     Z,ccpSave2           ; may be completed
1223: E52B 2B                     DEC    HL                   ; sector count = sector count - 1
1224: E52C E5                     PUSH   HL                   ; save it for next time around
1225: E52D 21 80 00               LD     HL,cpmRecordSize
1226: E530 19                     ADD    HL,DE
1227: E531 E5                     PUSH   HL                   ; next dma address saved
1228: E532 CD 5C E1               CALL   SetDMA               ; current dma address set
1229: E535 11 EC E6               LD     DE,commandFCB
1230: E538 CD 3F E1               CALL   DiskWrite
1231: E53B D1                     POP    DE
1232: E53C E1                     POP    HL                   ; dma address, sector count
1233: E53D C2 4D E5               JP     NZ,ccpSaveError      ; may be disk full case
1234: E540 C3 26 E5               JP     ccpSave1             ; for another sector
1235: E543
1236: E543         ;  end of dump, close the file
1237: E543             ccpSave2:
1238: E543 11 EC E6               LD     DE,commandFCB
1239: E546 CD 25 E1               CALL   CloseFile
1240: E549 3C                     INC    A                    ; 255 becomes 00 if error
1241: E54A C2 53 E5               JP     NZ,ccpSaveExit       ; for another command
1242: E54D             ccpSaveError:                      ; saverr must be full or read only disk
1243: E54D 01 59 E5               LD     BC,msgNoSpace
1244: E550 CD 2A E3               CALL   PrintCrLfStringNull
1245: E553             ccpSaveExit:
1246: E553 CD 59 E1               CALL   SetDefaultDMA        ; reset dma buffer
1247: E556 C3 B4 E3               JP     ResetDiskAtCmdEnd
1248: E559
1249: E559             msgNoSpace:
1250: E559 4E 4F 20 53 50 41 43 45 00                DB     'NO SPACE',0
1251: E562         ;*****************************************************************
1252: E562             ccpRename:
1253: E562 CD AA E1               CALL   FillFCB0
1254: E565 C2 7C E3               JP     NZ,CommandError      ; must be unambiguous
1255: E568 3A 0F E7               LD     A,(selectedDisk)
1256: E56B F5                     PUSH   AF                   ; save for later compare
1257: E56C CD D5 E6               CALL   SetDisk4Cmd          ; disk selected
1258: E56F CD 49 E1               CALL   Searc4CmdFcbFile     ; is new name already there?
1259: E572 C2 CB E5               JP     NZ,ccpRenameError3
1260: E575         ; file doesn't exist, move to second half of fcb
1261: E575 21 EC E6               LD     HL,commandFCB
1262: E578 11 FC E6               LD     DE,commandFCB+16
1263: E57B 06 10                  LD     B,16
1264: E57D CD 4B E3               CALL   CopyHL2DEforB
1265: E580         ; check for = or left arrow
1266: E580 2A 95 E7               LD     HL,(commandAddress)
1267: E583 EB                     EX     DE,HL
1268: E584 CD 5C E2               CALL   NextNonBlankChar
1269: E587 FE 3D                  CP     EQUAL_SIGN
1270: E589 CA 91 E5               JP     Z,ccpRename1         ; ok if =
1271: E58C FE 5F                  CP     LEFT_ARROW           ; la
1272: E58E C2 C5 E5               JP     NZ,ccpRenameError2
1273: E591             ccpRename1:
1274: E591 EB                     EX     DE,HL
1275: E592 23                     INC    HL
1276: E593 22 95 E7               LD     (commandAddress),HL  ; past delimiter
1277: E596         ; proper delimiter found
1278: E596 CD AA E1               CALL   FillFCB0
1279: E599 C2 C5 E5               JP     NZ,ccpRenameError2
1280: E59C         ; check for drive conflict
1281: E59C F1                     POP    AF
1282: E59D 47                     LD     B,A                  ; previous drive number
1283: E59E 21 0F E7               LD     HL,selectedDisk
1284: E5A1 7E                     LD     A,(HL)
1285: E5A2 B7                     OR     A
1286: E5A3 CA AB E5               JP     Z,ccpRename2
1287: E5A6         ; drive name was specified.  same one?
1288: E5A6 B8                     CP     B
1289: E5A7 70                     LD     (HL),B
1290: E5A8 C2 C5 E5               JP     NZ,ccpRenameError2
1291: E5AB             ccpRename2:
1292: E5AB 70                     LD     (HL),B               ; store the name in case drives switched
1293: E5AC AF                     XOR    A
1294: E5AD 32 EC E6               LD     (commandFCB),A
1295: E5B0 CD 49 E1               CALL   Searc4CmdFcbFile     ; is old file there?
1296: E5B3 CA BF E5               JP     Z,ccpRenameError1
1297: E5B6         ; everything is ok, rename the file
1298: E5B6 11 EC E6               LD     DE,commandFCB
1299: E5B9 CD 54 E1               CALL   RenameFile
1300: E5BC C3 B4 E3               JP     ResetDiskAtCmdEnd
1301: E5BF
1302: E5BF             ccpRenameError1:                      ; no file on disk
1303: E5BF CD 3B E3               CALL   PrintNoFile
1304: E5C2 C3 B4 E3               JP     ResetDiskAtCmdEnd
1305: E5C5             ccpRenameError2:                      ; ambigous reference/name conflict
1306: E5C5 CD A3 E3               CALL   ResetDisk
1307: E5C8 C3 7C E3               JP     CommandError
1308: E5CB             ccpRenameError3:                      ; file already exists
1309: E5CB 01 D4 E5               LD     BC,msgFileExists
1310: E5CE CD 2A E3               CALL   PrintCrLfStringNull
1311: E5D1 C3 B4 E3               JP     ResetDiskAtCmdEnd
1312: E5D4
1313: E5D4             msgFileExists:
1314: E5D4 46 49 4C 45 20 45 58 49 53 54 53 00                DB     'FILE EXISTS',0
1315: E5E0
1316: E5E0         ;*****************************************************************
1317: E5E0             ccpUser:
1318: E5E0 CD 85 E2               CALL   GetNumberFromCmdLine ; leaves the value in the accumulator
1319: E5E3 FE 10                  CP     16
1320: E5E5 D2 7C E3               JP     NC,CommandError      ; must be between 0 and 15
1321: E5E8 5F                     LD     E,A                  ; save for SetUser call
1322: E5E9 3A ED E6               LD     A,(commandFCB)+1
1323: E5EC FE 20                  CP     SPACE
1324: E5EE CA 7C E3               JP     Z,CommandError
1325: E5F1 CD 01 E1               CALL   SetUser              ;new user number set
1326: E5F4 C3 B7 E3               JP     EndCommand
1327: E5F7         ;*****************************************************************
1328: E5F7         ;User defined function
1329: E5F7         ;*****************************************************************
1330: E5F7             ccpUserFunction:
1331: E5F7
1332: E5F7 3A ED E6               LD     A,(commandFCB)+1
1333: E5FA FE 20                  CP     SPACE
1334: E5FC C2 13 E6               JP     NZ,ccpUserFunction1
1335: E5FF         ; no file name, but may be disk switch
1336: E5FF 3A 0F E7               LD     A,(selectedDisk)
1337: E602 B7                     OR     A
1338: E603 CA B7 E3               JP     Z,EndCommand         ; no disk named if 0
1339: E606 3D                     DEC    A                    ; adjust so A=>0, B=>1, C=>2 ......
1340: E607 32 0E E7               LD     (currentDisk),A      ; update current Disk indicator
1341: E60A CD A3 E1               CALL   SetPage0CurDisk      ; set user/disk
1342: E60D CD 0B E1               CALL   SelectDisk
1343: E610 C3 B7 E3               JP     EndCommand
1344: E613
1345: E613         ;  file name is present
1346: E613             ccpUserFunction1:
1347: E613 11 F5 E6               LD     DE,commandFCB+9
1348: E616 1A                     LD     A,(DE)
1349: E617 FE 20                  CP     SPACE
1350: E619 C2 7C E3               JP     NZ,CommandError      ; type SPACE
1351: E61C D5                     PUSH   DE
1352: E61D CD D5 E6               CALL   SetDisk4Cmd
1353: E620 D1                     POP    DE
1354: E621 21 D2 E6               LD     HL,comFileType       ; .com
1355: E624 CD 49 E3               CALL   CopyHL2DE3           ; file type is set to .com
1356: E627 CD 1B E1               CALL   OpenFile4CmdFCB
1357: E62A CA BA E6               JP     Z,ccpUserFunctionError1
1358: E62D         ; file opened properly, read it into memory
1359: E62D 21 00 01               LD     HL,TPA               ; transient program base
1360: E630             ccpUserFunction2:
1361: E630 E5                     PUSH   HL                   ;save dma address
1362: E631 EB                     EX     DE,HL
1363: E632 CD 5C E1               CALL   SetDMA
1364: E635 11 EC E6               LD     DE,commandFCB
1365: E638 CD 34 E1               CALL   DiskRead
1366: E63B C2 50 E6               JP     NZ,ccpUserFunction3
1367: E63E         ; sector loaded, set new dma address and compare
1368: E63E E1                     POP    HL
1369: E63F 11 80 00               LD     DE,cpmRecordSize
1370: E642 19                     ADD    HL,DE
1371: E643 11 00 E0               LD     DE,CcpBoundary       ; has the load overflowed?
1372: E646 7D                     LD     A,L
1373: E647 93                     SUB    E
1374: E648 7C                     LD     A,H
1375: E649 9A                     SBC    A,D
1376: E64A D2 C0 E6               JP     NC,ccpUserFunctionError2
1377: E64D C3 30 E6               JP     ccpUserFunction2     ; for another sector
1378: E650
1379: E650             ccpUserFunction3:
1380: E650 E1                     POP    HL
1381: E651 3D                     DEC    A
1382: E652 C2 C0 E6               JP     NZ,ccpUserFunctionError2 ; end file is 1
1383: E655 CD A3 E3               CALL   ResetDisk            ; back to original disk
1384: E658 CD AA E1               CALL   FillFCB0
1385: E65B 21 0F E7               LD     HL,selectedDisk
1386: E65E E5                     PUSH   HL
1387: E65F 7E                     LD     A,(HL)
1388: E660 32 EC E6               LD     (commandFCB),A       ; drive number set
1389: E663 3E 10                  LD     A,16
1390: E665 CD AC E1               CALL   FillFCB              ; move entire fcb to memory
1391: E668 E1                     POP    HL
1392: E669 7E                     LD     A,(HL)
1393: E66A 32 FC E6               LD     (commandFCB+16),A
1394: E66D AF                     XOR    A
1395: E66E 32 0C E7               LD     (currentRecord),A    ; record number set to zero
1396: E671 11 5C 00               LD     DE,FCB1              ; default FCB in page 0
1397: E674 21 EC E6               LD     HL,commandFCB
1398: E677 06 21                  LD     B,33
1399: E679 CD 4B E3               CALL   CopyHL2DEforB
1400: E67C         ; move command line to buff
1401: E67C 21 15 E7               LD     HL,commandBuffer
1402: E67F             ccpUserFunction4:
1403: E67F 7E                     LD     A,(HL)
1404: E680 B7                     OR     A
1405: E681 CA 8D E6               JP     Z,ccpUserFunction5
1406: E684 FE 20                  CP     SPACE
1407: E686 CA 8D E6               JP     Z,ccpUserFunction5
1408: E689 23                     INC    HL
1409: E68A C3 7F E6               JP     ccpUserFunction4     ; for another scan
1410: E68D         ; first blank position found
1411: E68D             ccpUserFunction5:
1412: E68D 06 00                  LD     B,0
1413: E68F 11 81 00               LD     DE,DMABuffer+1
1414: E692         ; ready for the move
1415: E692             ccpUserFunction6:
1416: E692 7E                     LD     A,(HL)
1417: E693 12                     LD     (DE),AE
1418: E694 B7                     OR     A
1419: E695 CA 9E E6               JP     Z,ccpUserFunction7
1420: E698         ;more to move
1421: E698 04                     INC    B
1422: E699 23                     INC    HL
1423: E69A 13                     INC    DE
1424: E69B C3 92 E6               JP     ccpUserFunction6
1425: E69E             ccpUserFunction7:                      ; B has character count
1426: E69E 78                     LD     A,B
1427: E69F 32 80 00               LD     (DMABuffer),A
1428: E6A2 CD 14 E3               CALL   CrLf
1429: E6A5         ; now go to the loaded program
1430: E6A5 CD 59 E1               CALL   SetDefaultDMA        ; default dma
1431: E6A8 CD 94 E1               CALL   SaveUser             ; user code saved
1432: E6AB         ; low memory diska contains user code
1433: E6AB CD 00 01               CALL   TPA                  ; gone to the loaded program
1434: E6AE 31 F0 E7               LD     SP,Stack             ; may come back here
1435: E6B1 CD A3 E1               CALL   SetPage0CurDisk
1436: E6B4 CD 0B E1               CALL   SelectDisk
1437: E6B7 C3 29 E0               JP     Ccp
1438: E6BA
1439: E6BA             ccpUserFunctionError1:
1440: E6BA CD A3 E3               CALL   ResetDisk
1441: E6BD C3 7C E3               JP     CommandError
1442: E6C0
1443: E6C0             ccpUserFunctionError2:                      ; cannot load the program
1444: E6C0 01 C9 E6               LD     BC,msgBadLoad
1445: E6C3 CD 2A E3               CALL   PrintCrLfStringNull
1446: E6C6 C3 B4 E3               JP     ResetDiskAtCmdEnd
1447: E6C9
1448: E6C9             msgBadLoad:
1449: E6C9 42 41 44 20 4C 4F 41 44 00                DB     'BAD LOAD',0
1450: E6D2             comFileType:
1451: E6D2 43 4F 4D                DB     'COM'                ;for com files
1452: E6D5         ;
1453: E6D5
1454: E6D5         ;*****************************************************************
1455: E6D5         ;*****************************************************************
1456: E6D5         ;change disks for this command, if requested
1457: E6D5             SetDisk4Cmd:
1458: E6D5 AF                     XOR    A
1459: E6D6 32 EC E6               LD     (commandFCB),A       ; clear disk name from fcb
1460: E6D9 3A 0F E7               LD     A,(selectedDisk)
1461: E6DC B7                     OR     A
1462: E6DD C8                     RET    Z                    ; no action if not specified
1463: E6DE 3D                     DEC    A
1464: E6DF 21 0E E7               LD     HL,currentDisk
1465: E6E2 BE                     CP     M
1466: E6E3 C8                     RET    Z                    ;already selected
1467: E6E4 C3 0B E1               JP     SelectDisk
1468: E6E7         ;*****************************************************************
1469: E6E7
1470: E6E7         ;*****************************************************************
1471: E6E7         ;************************ Data Area ******************************
1472: E6E7         ;*****************************************************************
1473: E6E7         ;	'submit' file control block
1474: E6E7 00          submitFlag: DB     00H                  ; 00 if no submit file, ff if submitting
1475: E6E8 00          submitFCB: DB     00H                  ; file name is $$$
1476: E6E9
1477: E6E9 00          subModuleNumber: DB     00H                  ; module number
1478: E6EA 00          subRecordCount: DB     00H                  ; record count filed
1479: E6EB 00          subCurrentRecord: DB     00H                  ; current record to read
1480: E6EC         ;;
1481: E6EC         ;;	command file control block
1482: E6EC             commandFCB: DS     32                   ; fields filled in later
1483: E70C 00          currentRecord: DB     00H                  ; current record to read/write
1484: E70D 00          directoryCount: DB     00H                  ; disk directory count (used for error codes)
1485: E70E 00          currentDisk: DB     00H                  ; current disk
1486: E70F 00          selectedDisk: DB     00H                  ; selected disk for current operation none=0, a=1, b=2 ...
1487: E710         ;
1488: E710 00          bufferPointer: DB     00H                  ; buffer pointer
1489: E711         ;------------------------------------
1490: E711 00 00       fillFCBStart: DW     0000H                ; staddr starting address of current FillFCB request
1491: E713         ;----------------------------
1492: E713         ; (command executed initially if CommandLength non zero)
1493: E713
1494: E713 7F          MaxBufferLength: DB     127                  ; maxlen max buffer length
1495: E714 00          CommandLength: DB     0                    ; comlen command length (filled in by dos)
1496: E715             commandBuffer:                      ; combuf:
1497: E715 20 20 20 20 20 20 20 20                DB     '        '           ; 8 character fill
1498: E71D 20 20 20 20 20 20 20 20                DB     '        '           ; 8 character fill
1499: E725 43 4F 50 59 52 49 47 48 54 20 28 43 29 20 31 39 37 39 20 44 49 47 49 54 41 4C 20 52 45 53 45 41 52 43 48 20 20                DB     'COPYRIGHT (C) 1979 DIGITAL RESEARCH  ' ; 38
1500: E74A             restOfCmdBuffer:
1501: E74A                        DS     cpmRecordSize-(restOfCmdBuffer-commandBuffer)
1502: E795 15 E7       commandAddress: DW     commandBuffer        ; comaddr address of next to char to scan
1503: E797
1504: E797             endOfCommandBuffer:
1505: E797         ;-------------------------------
1506: E797         ;	DS	16									; 8 level stack
1507: E797                        ORG    BDOSBase-10H
1508: E7F0             Stack:                          ; stack
1509: E7F0
1510: E7F0
1511: E7F0
1512: E7F0
1513: E7F0
           ************************   Xref   ************************
0000: $               E7F0   0821
0922: AddA2HL         E354   0603 0933 1179
0079: ASCII_A         0041   0324 1063
0080: ASCII_C         0043
0081: ASCII_K         004B
0088: ASCII_LO_A      0061
0089: ASCII_LO_K      006B
0090: ASCII_LO_P      0070
0031: ASCII_MASK      007F   1080 1090
0082: ASCII_N         004E
0083: ASCII_Q         0051
0084: ASCII_R         0052
0085: ASCII_W         0057
0086: ASCII_Y         0059   1136
0066: ASCII_ZERO      0030   0781
0060: ASTERISK        002A   0647 0678
0547: BDOSandIncA     E166   0472 0484 0494 0514 0524
0145: BDOSBase        E800   0146 0148 1507
0114: BDOSE           0005   0115 0417 0453 0457 0462 0467 0489 0529 0538 0542 0548 0558 0562 0884
0146: BDOSEntry       E806
0135: BDOSLength      0E00   0138 0148 0149
0541: BDOSsetFlags    E161   0499 0509
0049: BELL            0007
0148: BIOSBase        F600
0136: BIOSLength      0A00   0138
0108: BIOSPAGE        0002
0149: BIOSStart       F600
0245: BlockSize       0800   0267
1488: bufferPointer   E710   1161 1164
0027: BYTE            0001
0087: CARET           005E
0320: Ccp             E029   0983 1009 1133 1137 1437
0329: Ccp0            E03F   0318
0290: CcpBoundary     E000   1371
1025: ccpDir1         E3DA   1029
1031: ccpDir2         E3E1   1022
1036: ccpDir3         E3EA   1115
1077: ccpDir4         E42B   1104 1107
1096: ccpDir5         E44B   1083
1109: ccpDir6         E460   1092 1101
1111: ccpDir7         E461   1049
1016: ccpDirectory    E3C9   0355
1116: ccpDirEnd       E46D   1037 1113
1069: ccpDirHeader    E41E   1057
1073: ccpDirHeader1   E426   1067
1094: ccpDirSpace     E449   1087
0143: CCPEntry        E000   0145 0149 0288
1122: ccpErase        E471   0356
1141: ccpEraseAll     E494   1125
0134: CCPLength       0800   0138 0145 0149
1252: ccpRename       E562   0359
1273: ccpRename1      E591   1270
1291: ccpRename2      E5AB   1286
1302: ccpRenameError1 E5BF   1296
1305: ccpRenameError2 E5C5   1272 1279 1290
1308: ccpRenameError3 E5CB   1259
1198: ccpSave         E4FF   0358
1219: ccpSave1        E526   1234
1237: ccpSave2        E543   1222
1242: ccpSaveError    E54D   1210 1233
1245: ccpSaveExit     E553   1241
0295: CcpStart        E003   0292
1153: ccpType         E4AF   0357
1163: ccpType1        E4C6   1186
1176: ccpType2        E4D9   1167
1188: ccpTypeEOF      E4F2   1172
1192: ccpTypeError    E4F9   1158
1317: ccpUser         E5E0   0360
1330: ccpUserFunction E5F7   0338 0361
1346: ccpUserFunction1 E613   1334
1360: ccpUserFunction2 E630   1377
1379: ccpUserFunction3 E650   1366
1402: ccpUserFunction4 E67F   1409
1411: ccpUserFunction5 E68D   1405 1407
1415: ccpUserFunction6 E692   1424
1425: ccpUserFunction7 E69E   1419
1439: ccpUserFunctionError1 E6BA   1357
1443: ccpUserFunctionError2 E6C0   1376 1382
0556: CheckForConsoleChar E16E   0406 1112 1184
0482: CloseFile       E125   0397 1239
0067: COLON           003A   0623 0755 1065 1071
1450: comFileType     E6D2   1354
0062: COMMA           002C
1502: commandAddress  E795   0439 0608 0712 1140 1266 1276
1496: commandBuffer   E715   0404 0438 1401 1501 1502
0964: CommandError    E37C   0335 0747 0770 0783 0787 0793 0795 0797 0805 1008 1155 1194 1203 1254 1307 1320 1324 1350 1441
0967: CommandError1   E382   0977
0978: CommandError2   E395   0970 0972
1482: commandFCB      E6EC   0478 0503 0518 0602 0772 0834 1003 1019 1143 1205 1229 1238 1261 1262 1294 1298 1322 1332 1347 1364 1388 1393 1397 1459
1495: CommandLength   E714   0316 0387 0422 1131
0120: ComTail         0080   0121
0122: ComTailChars    0082
0121: ComTailCount    0081   0122
0910: CopyHL2DE3      E349   1355
0912: CopyHL2DEforB   E34B   0390 0918 1264 1399
0222: cpmRecordSize   0080   0224 0227 0229 0389 1225 1369 1501
0052: CR              000D   0869
0868: CrLf            E314   0322 0889 0965 0981 1059 1160 1428
0035: CTRL_C          0003
0036: CTRL_E          0005
0037: CTRL_H          0008
0038: CTRL_K          000B
0039: CTRL_L          000C
0040: CTRL_P          0010
0041: CTRL_R          0012
0042: CTRL_S          0013
0043: CTRL_U          0015
0044: CTRL_X          0018
0045: CTRL_Z          001A
1485: currentDisk     E70E   0333 0372 0400 0577 0587 0594 0630 0991 0994 1340 1464
1483: currentRecord   E70C   0477 1212 1395
0063: DASH            002D
0256: DataBlocks      02C7   0266
0255: DataSectors     0B1C   0256
0487: DeleteFile      E12A   0576 1144 1207
0567: DeleteSubmitFile E17C   0408 0409 0412 0982
0227: DirBuffSize     0080
0242: DirectoryBlockCount 0002   0267
1484: directoryCount  E70D   0549 1039
0229: DirectoryEntryPerRecord 0004   0270
0226: DirEntrySize    0020   0229 0267
0214: DiskCommandBlock 0046
0213: DiskControlByte 0045
0216: DiskControlTable 0040
0497: DiskRead        E134   0384 0504 1365
0502: DiskReadCmdFCB  E139   1170
0218: DiskReadCode    0001
0223: diskSectorSize  0200   0224 0245 0253
0212: DiskStatusLocation 0043
0507: DiskWrite       E13F   1230
0219: DiskWriteCode   0002
0125: DMABuffer       0080   0330 0388 0533 0931 1178 1413 1427
0056: DOLLAR          0024
0268: dpb3hdAL0       00C0
0269: dpb3hdAL1       0000
0264: dpb3hdBLM       000F
0263: dpb3hdBSH       0004
0270: dpb3hdCKS       0020
0267: dpb3hdDRM       007F   0270
0266: dpb3hdDSM       02C6
0265: dpb3hdEXM       0000
0272: dpb3hdNOH       0002
0271: dpb3hdOFF       0001
0262: dpb3hdSPT       0090
0129: END_OF_FILE     001A   1181
1001: EndCommand      E3B7   1326 1338 1343
1504: endOfCommandBuffer E797
0033: EndOfMessage    0000
0071: EQUAL_SIGN      003D   0749 1269
0054: EXCLAIM_POINT   0021
0022: FALSE           0000
0117: FCB1            005C   0118 1396
0118: FCB2            006C
0283: fcbSystemFileIndex 000A   1046
0162: fCloseFile      0010   0483
0153: fConsoleIn      0001   0561
0154: fConsoleOut     0002   0883
0165: fDeleteFile     0013   0488
0157: fGetConsoleStatus 000B   0557
0171: fGetCurrentDisk 0019   0466
0170: fGetLoginVector 0018
0173: fGetSetUserNumber 0020   0452
0158: fGetVersion     000C
0601: FillFCB         E1AC   1390
0599: FillFCB0        E1AA   0334 0767 1002 1017 1123 1154 1202 1253 1278 1384
1490: fillFCBStart    E711   0612 0966
0703: FillRestofFCB   E23C   0693
0706: FillRestofFCB1  E23E   0710
0629: FillSetCurrentDisk E1D5   0618
0635: FillSetDiskName E1DC   0624
0168: fMakeFile       0016   0493
0161: fOpenFile       000F   0471
0155: fPrintString    0009
0166: fReadSeq        0014   0498
0156: fReadString     000A   0415
0169: fRenameFile     0017   0528
0159: fResetSystem    000D   0456
0163: fSearchFirst    0011   0513
0164: fSearchNext     0012   0523
0160: fSelectDisk     000E   0461
0172: fSetDMA         001A   0537
0167: fWriteSeq       0015   0508
0930: GetByteAtAandCandDMA E359   1047 1079 1089
0766: GetNumberFromCmdLine E285   1199 1318
0775: GetNumericValue E295   0800
0802: GetNumericValue1 E2C0   0778 0808
0465: GetSelectedDrive E111   0323 0332 1061
0448: GetUser         E0FF   0582
0072: GREATER_THAN    003E   0326 0761
0055: HASH_TAG        0023
0284: iFunctionNameSize 0004   0821 0835
0455: Initialize      E106   0308
0827: IntrinsicFunction E2E5   0340
0830: IntrinsicFunction1 E2EA   0858
0836: IntrinsicFunction2 E2F3   0843
0851: IntrinsicFunction3 E306   0839 0854
0856: IntrinsicFunction4 E30B   0847
0821: IntrinsicFunctionCount 0006   0832
0814: intrinsicFunctionNames E2CD   0821 0828
0354: intrinsicFunctionsVector E068   0341
0109: IOBYTE          0003
0058: L_PAREN         0028
0075: LEFT_ARROW      005F   1271
0091: LEFT_CURLY      007B
0138: LengthInBytes   2000   0139 0143 0253
0139: LengthInK       0009
0070: LESS_THAN       003C   0759
0051: LF              000A   0871
0025: LO_NIBBLE_MASK  000F   0304 0312
0492: MakeFile        E12F   1209
1494: MaxBufferLength E713   0416
0141: MemorySize      0040   0143
1448: msgBadLoad      E6C9   1444
1149: msgEraseAll     E4A4   1127
1313: msgFileExists   E5D4   1309
0907: msgNoFile       E341   0904
1249: msgNoSpace      E559   1243
0954: msgReadErr      E371   0952
0254: myOffset        0001   0255 0271
0742: NextDelimiter   E266   0644 0659 0675 0692
0732: NextNonBlankChar E25C   0610 0739 1268
0420: NoRead          E0E4   0407
0411: NotSubmitFile   E0D3   0370 0379 0385 0398
0047: NULL            0000
0238: NumberOfHeads   0002   0249 0251 0262 0272
0235: NumberOfLogicalDisks 0004
0024: OFF             0000
0023: ON              FFFF
0470: OpenFile        E116   0378 0479
0475: OpenFile4CmdFCB E11B   1157 1356
0664: PadTheName      E205   0645 0668
0697: PadTypeField    E235   0672 0676 0701
0057: PERCENT         0025
0064: PERIOD          002E   0671 0753
0112: Pg0CurentDisk   0004   0313 0589 0595
0111: Pg0CurentUser   0004   0112
0061: PLUS_SIGN       002B
0881: PrintChar       E324   0325 0327 0877 0898 0974 0980 1183
0887: PrintCrLfStringNull E32A   0905 0953 1128 1244 1310 1445
0903: PrintNoFile     E33B   1035 1146 1303
0951: PrintReadError  E36B   1191
0875: PrintSaveBC     E31E   0866 0870 0872 1064 1066 1072 1097
0864: PrintSpace      E30F   1070 1074 1106
0892: PrintStringNull E32F   0405 0900
0073: QMARK           003F   0649 0680 0719 0979 1026
0716: QuestionMarkCount E24D   0725
0723: QuestionMarkCount1 E255   0720
0059: R_PAREN         0029
0105: RAM             0000   0107 0108 0109 0111 0114 0117 0120 0125 0127
0367: ReadCommand     E076   0328 1130
0424: ReadCommand1    E0E8   0433
0436: ReadCommand2    E0F7   0428
0247: RecordsPerBlock 0010
0231: RecordsPerExtent 0080
0224: recordsPerSector 0004   0247 0262
0527: RenameFile      E154   1299
0986: ResetDisk       E3A3   0999 1193 1306 1383 1440
0998: ResetDiskAtCmdEnd E3B4   1118 1147 1182 1185 1190 1247 1300 1304 1311 1446
1500: restOfCmdBuffer E74A   1501
0076: RUBOUT          007F
0581: SaveUser        E194   0414 1431
0517: Searc4CmdFcbFile E149   1034 1258 1295
0512: SearchForFirst  E144   0519
0522: SearchForNext   E14F   1114
0276: SectorMask      0003
0241: SectorsPerBlock 0004   0245 0247 0250 0256 0276
0251: SectorsPerCylinder 0024   0254 0255
0240: SectorsPerTrack 0012   0249 0251 0262
0459: SelectDisk      E10B   0314 0375 0402 0574 0578 0995 1342 1436 1467
1486: selectedDisk    E70F   0336 0607 0637 0768 0987 1005 1255 1283 1336 1385 1460
0069: SEMICOLON       003B   0757
0626: setcur          E1D4
0532: SetDefaultDMA   E159   1246 1430
1457: SetDisk4Cmd     E6D5   1018 1142 1156 1204 1257 1352
0536: SetDMA          E15C   0331 1228 1363
0641: SetFileName     E1E2   0632
0643: SetFileName1    E1E4   0657
0652: SetFileName2    E1F5   0648
0655: SetFileName3    E1F7   0650
0593: SetPage0CurDisk E1A3   0418 1341 1435
0669: SetTypeField    E20C   0660
0674: SetTypeField1   E214   0689
0684: SetTypeField2   E225   0679
0687: SetTypeField3   E227   0681
0451: SetUser         E101   0306 1325
0065: SLASH           002F
0048: SOH             0001
0053: SPACE           0020   0666 0699 0736 0746 0777 0804 0846 0865 0969 1004 1021 1082 1091 1095 1323 1333 1349 1406
1508: Stack           E7F0   0296 0321 1434
1479: subCurrentRecord E6EB   0382
1475: submitFCB       E6E8   0377 0383 0396 0575
1474: submitFlag      E6E7   0309 0368 0568
1477: subModuleNumber E6E9   0392
1478: subRecordCount  E6EA   0380
0253: SystemSectors   0011   0254
0050: TAB             0009
0115: TopRAM          0007
0250: TotalNumberOfBlocks 02D0
0249: TotalNumberOfSectors 0B40   0250 0255
0127: TPA             0100   1218 1359 1433
0239: TracksPerHead   0050   0249
0021: TRUE            FFFF
0658: TruncateName    E1FB   0662
0691: TruncateType    E22B   0695
0074: UNDER_SCORE     005F   0751
0938: UpCase          E362   0430
0107: WarmBoot        0000
0028: WORD            0002
0187: WriteAllocated  0000
0188: WriteDirectory  0001
0189: WriteUnallocated 0002
0032: ZERO            0000
