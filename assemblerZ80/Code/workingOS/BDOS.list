0001: 0000         ;     File created by MakeZ80Source on Tue Sep 18 12:41:03 EDT 2018 from:
0002: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BDOSX.asm
0003: 0000         ; BDOS.asm
0004: 0000
0005: 0000         ; 2017-03-31 added vector for BDOS Call 5 -ListOut
0006: 0000         ; 2017-03-02 Refactored the CP/M Suite
0007: 0000         ; 2017-02-12 fixed allocate 16 bit problem
0008: 0000         ; 2014-01-16 extended from part of newOS (newBDOS)
0009: 0000         ; 2014-03-14  :  Frank Martyn
0010: 0000
0011: 0000
0012: 0000                        Include ./stdHeader.Z80
0013: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0014: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0015: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0016: 0000         ; stdHeader.asm
0017: 0000         ; standard equates
0018: 0000
0019: 0000         ; 2017-03-02 Refactored the CP/M Suite
0020: 0000
0021: 0000
0022: 0000             TRUE       EQU    -1                   ; not false
0023: 0000             FALSE      EQU    0000H
0024: 0000             ON         EQU    -1
0025: 0000             OFF        EQU    0000H
0026: 0000             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0027: 0000
0028: 0000             BYTE       EQU    1                    ; number of bytes for "byte" type
0029: 0000             WORD       EQU    2                    ; number of bytes for "word" type
0030: 0000
0031: 0000
0032: 0000             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0033: 0000             ZERO       EQU    00H                  ; Zero
0034: 0000             EndOfMessage EQU    00H
0035: 0000
0036: 0000             CTRL_C     EQU    03H                  ; ETX
0037: 0000             CTRL_E     EQU    05H                  ; physical eol
0038: 0000             CTRL_H     EQU    08H                  ; backspace
0039: 0000             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0040: 0000             CTRL_L     EQU    0CH                  ; FF - Form feed
0041: 0000             CTRL_P     EQU    10H                  ; prnt toggle
0042: 0000             CTRL_R     EQU    12H                  ; repeat line
0043: 0000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0044: 0000             CTRL_U     EQU    15H                  ; line delete
0045: 0000             CTRL_X     EQU    18H                  ; =ctl-u
0046: 0000             CTRL_Z     EQU    1AH                  ; end of file
0047: 0000
0048: 0000             NULL       EQU    00H                  ; Null
0049: 0000             SOH        EQU    01H                  ; Start of Heading
0050: 0000             BELL       EQU    07H                  ; Bell
0051: 0000             TAB        EQU    09H                  ; Tab
0052: 0000             LF         EQU    0AH                  ; Line Feed
0053: 0000             CR         EQU    0DH                  ; Carriage Return
0054: 0000             SPACE      EQU    20H                  ; Space
0055: 0000             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0056: 0000             HASH_TAG   EQU    23H                  ; Sharp sign #
0057: 0000             DOLLAR     EQU    24H                  ; Dollar Sign
0058: 0000             PERCENT    EQU    25H                  ; Percent Sign
0059: 0000             L_PAREN    EQU    28H                  ; Left Paenthesis (
0060: 0000             R_PAREN    EQU    29H                  ; Right Paenthesis )
0061: 0000             ASTERISK   EQU    2AH                  ; Asterisk *
0062: 0000             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0063: 0000             COMMA      EQU    2CH                  ; Comma
0064: 0000             DASH       EQU    2DH                  ; Dash Hyphen -
0065: 0000             PERIOD     EQU    2EH                  ; Period
0066: 0000             SLASH      EQU    2FH                  ; /
0067: 0000             ASCII_ZERO EQU    30H                  ; zero
0068: 0000             COLON      EQU    3AH                  ; Colon
0069: 0000
0070: 0000             SEMICOLON  EQU    3BH                  ; Semi Colon
0071: 0000             LESS_THAN  EQU    3CH                  ; Less Than <
0072: 0000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0073: 0000             GREATER_THAN EQU    3EH                  ; Greater Than >
0074: 0000             QMARK      EQU    3FH                  ; Question Mark
0075: 0000             UNDER_SCORE EQU    5FH                  ; under score _
0076: 0000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0077: 0000             RUBOUT     EQU    7FH                  ; Delete Key
0078: 0000
0079: 0000
0080: 0000             ASCII_A    EQU    'A'
0081: 0000             ASCII_C    EQU    'C'
0082: 0000             ASCII_K    EQU    'K'
0083: 0000             ASCII_N    EQU    'N'
0084: 0000             ASCII_Q    EQU    'Q'
0085: 0000             ASCII_R    EQU    'R'
0086: 0000             ASCII_W    EQU    'W'
0087: 0000             ASCII_Y    EQU    'Y'
0088: 0000             CARET      EQU    '^'
0089: 0000             ASCII_LO_A EQU    'a'
0090: 0000             ASCII_LO_K EQU    'k'
0091: 0000             ASCII_LO_P EQU    'p'
0092: 0000             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0093: 0000
0094: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0095: 0000                        Include ./osHeader.Z80
0096: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0097: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0098: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0099: 0000         ; osHeader.asm
0100: 0000
0101: 0000         ; 2017-03-02 Refactored the CP/M Suite
0102: 0000
0103: 0000         ; Contains the Equates used by the CP/M system
0104: 0000
0105: 0000         ;------------------------Page Zero Constants ---------------------------------
0106: 0000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0107: 0000
0108: 0000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0109: 0000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0110: 0000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0111: 0000
0112: 0000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0113: 0000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0114: 0000
0115: 0000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0116: 0000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0117: 0000
0118: 0000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0119: 0000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0120: 0000
0121: 0000             ComTail    EQU    RAM + 080H           ; Complete command tail
0122: 0000             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0123: 0000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0124: 0000         ;-----------------------------------------------------------------------
0125: 0000
0126: 0000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0127: 0000         ;-----------------------------------------------------------------------
0128: 0000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0129: 0000         ;-----------------------------------------------------------------------
0130: 0000             END_OF_FILE EQU    1AH                  ; end of file
0131: 0000         ;-----------------------------------------------------------------------
0132: 0000
0133: 0000         ;--------------- CP/M Constants -----------------------------------------
0134: 0000
0135: 0000             CCPLength  EQU    0800H                ; Constant
0136: 0000             BDOSLength EQU    0E00H                ; Constant 0E00H
0137: 0000             BIOSLength EQU    0A00H                ; Constant 0900H
0138: 0000
0139: 0000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0140: 0000             LengthInK  EQU    (LengthInBytes/1024) + 1
0141: 0000
0142: 0000             MemorySize EQU    64
0143: 0000
0144: 0000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0145: 0000
0146: 0000             BDOSBase   EQU    CCPEntry + CCPLength
0147: 0000             BDOSEntry  EQU    BDOSBase + 6
0148: 0000
0149: 0000             BIOSBase   EQU    BDOSBase + BDOSLength
0150: 0000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0151: 0000         ;-----------------------------------------------------------------------
0152: 0000
0153: 0000         ;------------------- BDOS System Call Equates --------------------------
0154: 0000             fConsoleIn EQU    01H                  ; rcharf - Console Input
0155: 0000             fConsoleOut EQU    02H                  ; pcharf - Console Output
0156: 0000             fPrintString EQU    09H                  ; pbuff	- Print String
0157: 0000             fReadString EQU    0AH                  ; rbuff	- Read Console String
0158: 0000             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0159: 0000             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0160: 0000             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0161: 0000             fSelectDisk EQU    0EH                  ; self	- Select Disk
0162: 0000             fOpenFile  EQU    0FH                  ; openf	- Open File
0163: 0000             fCloseFile EQU    10H                  ; closef - Close File
0164: 0000             fSearchFirst EQU    11H                  ; searf	- Search For First
0165: 0000             fSearchNext EQU    12H                  ; searnf - Search for Next
0166: 0000             fDeleteFile EQU    13H                  ; delf - Delete File
0167: 0000             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0168: 0000             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0169: 0000             fMakeFile  EQU    16H                  ; makef	- Make File
0170: 0000             fRenameFile EQU    17H                  ; renf	- Rename File
0171: 0000             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0172: 0000             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0173: 0000             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0174: 0000             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0175: 0000         ;-----------------------------------------------------------------------
0176: 0000
0177: 0000
0178: 0000
0179: 0000
0180: 0000
0181: 0000         ;*******************************************************************************
0182: 0000         ; These are the values handed over by the BDOS when it calls the Writer operation
0183: 0000         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0184: 0000         ; unallocated allocation block (it only indicates this for the first 128 byte
0185: 0000         ; sector write) or to an allocation block that has already been allocated to a
0186: 0000         ; file. The BDOS also indicates if it is set to write to the file directory
0187: 0000         ;*******************************************************************************
0188: 0000             WriteAllocated EQU    00H
0189: 0000             WriteDirectory EQU    01H
0190: 0000             WriteUnallocated EQU    02H
0191: 0000
0192: 0000
0193: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0194: 0000                        Include ./diskHeader.Z80
0195: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0196: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0197: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0198: 0000         ; diskHeader.asm
0199: 0000
0200: 0000         ; 2017-03-02 Refactored the CP/M Suite
0201: 0000
0202: 0000         ; needs osHeader.asm declared before this is used !!!!!!!
0203: 0000
0204: 0000         ; Contains the Equates used by the CP/M system to handle disks
0205: 0000
0206: 0000
0207: 0000         ;*******************************************************************************
0208: 0000         ;
0209: 0000         ;     Disk related values
0210: 0000         ;
0211: 0000         ;
0212: 0000         ;*******************************************************************************
0213: 0000             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0214: 0000             DiskControlByte EQU    045H                 ; control byte for disk I/O
0215: 0000             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0216: 0000         ; for boot
0217: 0000             DiskControlTable EQU    0040H
0218: 0000
0219: 0000             DiskReadCode EQU    01H                  ; Code for Read
0220: 0000             DiskWriteCode EQU    02H                  ; Code for Write
0221: 0000
0222: 0000
0223: 0000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0224: 0000             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0225: 0000             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0226: 0000
0227: 0000             DirEntrySize EQU    20H                  ; (32)
0228: 0000             DirBuffSize EQU    cpmRecordSize
0229: 0000
0230: 0000             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0231: 0000
0232: 0000             RecordsPerExtent EQU    080H                 ; extent Record capacity
0233: 0000
0234: 0000
0235: 0000         ;-------------------------------------------------------------------------------------
0236: 0000             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0237: 0000
0238: 0000         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0239: 0000             NumberOfHeads EQU    02H                  ; number of heads
0240: 0000             TracksPerHead EQU    50H                  ; 80
0241: 0000             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0242: 0000             SectorsPerBlock EQU    04H                  ; 2048 bytes
0243: 0000             DirectoryBlockCount EQU    02H                  ;
0244: 0000         ;-----------------------------------------------------------------------
0245: 0000
0246: 0000             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0247: 0000
0248: 0000             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0249: 0000
0250: 0000             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0251: 0000             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0252: 0000             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0253: 0000
0254: 0000             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0255: 0000             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0256: 0000             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0257: 0000             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0258: 0000
0259: 0000         ;-----------------------------------------------------------------------
0260: 0000         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0261: 0000         ;-----------------------------------------------------------------------
0262: 0000         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0263: 0000             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0264: 0000             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0265: 0000             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0266: 0000             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0267: 0000             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0268: 0000             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0269: 0000             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0270: 0000             dpb3hdAL1  EQU    00H                  ;  for each file directory
0271: 0000             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0272: 0000             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0273: 0000             dpb3hdNOH  EQU    NumberOfHeads
0274: 0000
0275: 0000         ;*******************************************************************************
0276: 0000
0277: 0000             SectorMask EQU    SectorsPerBlock - 1
0278: 0000
0279: 0000         ;***************************************************************************
0280: 0000
0281: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0282: 0000
0283: 0000             VERSION    EQU    20H                  ; dvers version 2.0
0284: 0000             STACK_SIZE EQU    20H                  ; make stak big enough
0285: 0000             EOD        EQU    -1                   ; enddir End of Directory
0286: 0000
0287: 0000         ;------------------- BIOS Function Constants ---------------------------
0288: 0000
0289: 0000             bcBoot     EQU    BIOSStart+3*0        ; bootf	cold boot function
0290: 0000             bcWboot    EQU    BIOSStart+3*1        ; wbootf	warm boot function
0291: 0000             bcConst    EQU    BIOSStart+3*2        ; constf	console status function
0292: 0000             bcConin    EQU    BIOSStart+3*3        ; coninf	console input function
0293: 0000             bcConout   EQU    BIOSStart+3*4        ; conoutf	console output function
0294: 0000             bcList     EQU    BIOSStart+3*5        ; listf	list output function
0295: 0000             bcPunch    EQU    BIOSStart+3*6        ; punchf	punch output function
0296: 0000             bcReader   EQU    BIOSStart+3*7        ; readerf	reader input function
0297: 0000             bcHome     EQU    BIOSStart+3*8        ; homef	disk home function
0298: 0000             bcSeldsk   EQU    BIOSStart+3*9        ; seldskf	select disk function
0299: 0000             bcSettrk   EQU    BIOSStart+3*10       ; settrkf	set track function
0300: 0000             bcSetsec   EQU    BIOSStart+3*11       ; setsecf	set sector function
0301: 0000             bcSetdma   EQU    BIOSStart+3*12       ; setdmaf	set dma function
0302: 0000             bcRead     EQU    BIOSStart+3*13       ; readf	read disk function
0303: 0000             bcWrite    EQU    BIOSStart+3*14       ; writef	write disk function
0304: 0000             bcListst   EQU    BIOSStart+3*15       ; liststf	list status function
0305: 0000             bcSectran  EQU    BIOSStart+3*16       ; sectran	sector translate
0306: 0000         ;--------------------------------------------------------------------------------
0307: 0000
0308: 0000                        ORG    BDOSBase
0309: E800             CodeStart:
0310: E800                        DS     6                    ; dead space
0311: E806
0312: E806
0313: E806         ; Enter here from the user's program with function number in c,
0314: E806         ; and information address in d,e
0315: E806         ;BDOSEntry:
0316: E806 C3 09 E8               JP     BdosStart            ;past parameter block
0317: E809
0318: E809             BdosStart:
0319: E809 79                     LD     A,C
0320: E80A 32 77 F5               LD     (Cvalue),A
0321: E80D EB                     EX     DE,HL                ; swap DE and HL
0322: E80E 22 34 F5               LD     (paramDE),HL         ; save the original value of DE
0323: E811 EB                     EX     DE,HL                ; restore DE
0324: E812 7B                     LD     A,E                  ; Byte argument
0325: E813 32 5D F5               LD     (paramE),A
0326: E816 21 00 00               LD     HL,0000H
0327: E819 22 36 F5               LD     (statusBDOSReturn),HL ; assume alls well for return
0328: E81C         ; Save users Stack pointer
0329: E81C 39                     ADD    HL,SP
0330: E81D 22 7D F5               LD     (usersStack),HL
0331: E820 31 BF F5               LD     SP,bdosStack         ; use our own stack area
0332: E823         ; initialize variables
0333: E823 AF                     XOR    A
0334: E824 32 6B F5               LD     (fcbDisk),A          ; initalize to 00
0335: E827 32 69 F5               LD     (fResel),A           ; clear reselection flag
0336: E82A 21 40 E8               LD     HL,RetCaller         ; exit to caller vector
0337: E82D E5                     PUSH   HL                   ; makes a JMP to RetCaller = RET
0338: E82E
0339: E82E 79                     LD     A,C                  ; get the Function Number
0340: E82F FE 28                  CP     functionCount        ; make sure its a good number
0341: E831 D0                     RET    NC                   ; exit if not a valid function
0342: E832
0343: E832 4B                     LD     C,E                  ; might be a single byte argument
0344: E833 21 67 E8               LD     HL,functionTable     ; get table base
0345: E836 5F                     LD     E,A                  ; function number in E
0346: E837 16 00                  LD     D,0                  ; setting up DE = function number
0347: E839 19                     ADD    HL,DE
0348: E83A 19                     ADD    HL,DE                ; Vector is (2 * Function number) + table base
0349: E83B 5E                     LD     E,(HL)               ; get LSB of vector
0350: E83C 23                     INC    HL
0351: E83D 56                     LD     D,(HL)               ; get MSB of vector
0352: E83E EB                     EX     DE,HL                ; Vector now in HL
0353: E83F E9                     JP     (HL)                 ; move vector to Program Counter ie JMP (HL)
0354: E840         ;*****************************************************************
0355: E840         ;arrive here at end of processing to return to user
0356: E840             RetCaller:                      ; goback
0357: E840 3A 69 F5               LD     A,(fResel)           ; get reselction flag
0358: E843 B7                     OR     A                    ; is it set?
0359: E844 CA 5D E8               JP     Z,RetDiskMon
0360: E847         ;reselection may have taken place
0361: E847 2A 34 F5               LD     HL,(paramDE)
0362: E84A 36 00                  LD     (HL),0
0363: E84C 3A 6B F5               LD     A,(fcbDisk)
0364: E84F B7                     OR     A                    ; Disk = 0?
0365: E850 CA 5D E8               JP     Z,RetDiskMon         ; exit if yes
0366: E853
0367: E853 77                     LD     (HL),A
0368: E854 3A 6A F5               LD     A,(entryDisk)        ; get back original Disk
0369: E857 32 5D F5               LD     (paramE),A           ; and select it
0370: E85A CD BD EB               CALL   SelectCurrent
0371: E85D
0372: E85D         ; return from the disk monitor
0373: E85D             RetDiskMon:
0374: E85D 2A 7D F5               LD     HL,(usersStack)
0375: E860 F9                     LD     SP,HL                ; restore callers stack
0376: E861 2A 36 F5               LD     HL,(statusBDOSReturn)
0377: E864 7D                     LD     A,L
0378: E865 44                     LD     B,H                  ; BA = statusBDOSReturn
0379: E866 C9                     RET
0380: E867         ;*****************************************************************
0381: E867         ;------------------- Function Table -------------------------------
0382: E867             functionTable:
0383: E867 00 F6                  DW     bcBoot               ; Function  0 - System Reset
0384: E869 BA E8                  DW     vConsoleIn           ; Function  1 - Console Input
0385: E86B C1 E8                  DW     vConsoleOut          ; Function  2 - Console Output
0386: E86D C5 E8                  DW     vReaderIn            ; Function  3 - Reader Input
0387: E86F C9 E8                  DW     vPunchOut            ; Not Implemented	  Function  4 - Punch Output
0388: E871 CA E8                  DW     vListOut             ; Not Implemented	  Function  5 - List Output
0389: E873 CE E8                  DW     vDirectConIO         ; Function  6 - Direct Console I/O
0390: E875 E5 E8                  DW     vGetIOBYTE           ; Function  7 - Get I/O Byte
0391: E877 EC E8                  DW     vSetIOBYTE           ; Function  8 - Set I/O Byte
0392: E879 F1 E8                  DW     vPrintString         ; Function  9 - Print String
0393: E87B FA E8                  DW     vReadString          ; Function  A - Read Console String
0394: E87D FE E8                  DW     vGetConsoleStatus    ; Function  B - Get Console Status
0395: E87F             diskf      EQU    ($-functionTable)/2  ; disk functions
0396: E87F 9D F4                  DW     vGetVersion          ; Function  C - Return Version Number
0397: E881 69 EB                  DW     vResetSystem         ; Function  D - Reset Disk System
0398: E883 82 EB                  DW     vSelectDisk          ; Function  E - Select Disk
0399: E885 AB EE                  DW     vOpenFile            ; Function  F - Open File
0400: E887 B4 EE                  DW     vCloseFile           ; Function 10 - Close File
0401: E889 BA EE                  DW     vFindFirst           ; Function 11 - Search For First
0402: E88B D3 EE                  DW     vFindNext            ; Function 12 - Search for Next
0403: E88D E2 EE                  DW     vDeleteFile          ; Function 13 - Delete File
0404: E88F EB EE                  DW     vReadSeq             ; Function 14 - Read Sequential
0405: E891 F2 EE                  DW     vWriteSeq            ; Function 15 - Write Sequential
0406: E893 F9 EE                  DW     vMakeFile            ; Function 16 - Make File
0407: E895 02 EF                  DW     vRenameFile          ; Function 17 - Rename File
0408: E897 85 EB                  DW     vGetLoginVector      ; Function 18 - Return Login Vector
0409: E899 8C EB                  DW     vGetCurrentDisk      ; Function 19 - Return Current Disk
0410: E89B 93 EB                  DW     vSetDMA              ; Function 1A - Set DMA address
0411: E89D 9C EB                  DW     vGetAllocAddr        ; Function 1B - Get ADDR (ALLOC)
0412: E89F A3 EB                  DW     vWriteProtectDisk    ; Function 1C - Write Protect Disk
0413: E8A1 A6 EB                  DW     vGetRoVector         ; Function 1D - Get Read/Only Vector
0414: E8A3 AD EB                  DW     vSetFileAttributes   ; Function 1E - Set File Attributes ??
0415: E8A5 B6 EB                  DW     vGetDiskParamBlock   ; Function 1F - Get ADDR (Disk Parameters)
0416: E8A7 05 E9                  DW     vGetSetUserNumber    ; Function 20 - Set/Get User Code
0417: E8A9 1A E9                  DW     vReadRandom          ; Function 21 - Read Random
0418: E8AB 20 E9                  DW     vWriteRandom         ; Function 22 - Write Random
0419: E8AD 26 E9                  DW     vComputeFileSize     ; Function 23 - Compute File Size
0420: E8AF 2C E9                  DW     vSetRandomRecord     ; Function 24 - Set Random Record
0421: E8B1 2F E9                  DW     vResetDrive          ; Not Implemented	  Function 25 - Reset Drive
0422: E8B3 B9 E8                  DW     DUMMY                ; Function 26 - Access Drive (not supported)
0423: E8B5 B9 E8                  DW     DUMMY                ; Function 27 - Free Drive (not supported)
0424: E8B7 30 E9                  DW     vWriteRandom0Fill    ; Not Implemented	  Function 28 - Write random w/Fill
0425: E8B9             functionCount EQU    ($-functionTable)/2  ; Number of  functions
0426: E8B9
0427: E8B9             DUMMY:
0428: E8B9 76                     HALT
0429: E8BA         ;*****************************************************************
0430: E8BA         ;**************** IOByte device I/O ******************************
0431: E8BA         ;*****************************************************************
0432: E8BA         ;return CON: character with echo
0433: E8BA             vConsoleIn:                      ; func1 (01 - 01) Console In
0434: E8BA CD 03 F4               CALL   ConsoleInWithEcho
0435: E8BD 32 36 F5               LD     (statusBDOSReturn),A
0436: E8C0 C9                     RET
0437: E8C1         ;----------
0438: E8C1         ; write CON: character with TAB expansion
0439: E8C1             vConsoleOut:                      ; func2 (02 - 02) Console Out
0440: E8C1 CD 55 EB               CALL   TabOut
0441: E8C4 C9                     RET
0442: E8C5         ;----------
0443: E8C5         ; Read next character from RDR: (Paper Tape Reader)
0444: E8C5             vReaderIn:                      ; func3 (03 - 03) Reader Input
0445: E8C5         ; Not Yet Implemented   **************
0446: E8C5 32 36 F5               LD     (statusBDOSReturn),A
0447: E8C8 C9                     RET
0448: E8C9         ;----------
0449: E8C9         ; send char in E directly to PTP: (Paper Tape Punch)
0450: E8C9             vPunchOut:                      ; func4 (04 - 04) Punch Output
0451: E8C9         ; Not Yet Implemented   **************
0452: E8C9 C9                     RET
0453: E8CA         ;----------
0454: E8CA         ; send char in E directly to LST:
0455: E8CA             vListOut:                       ; func5 (05 - 05) List Output
0456: E8CA CD 0F F6               CALL   bcList               ; direct call to BIOS
0457: E8CD C9                     RET
0458: E8CE         ;----------
0459: E8CE         ;direct console i/o - read if 0ffh
0460: E8CE             vDirectConIO:                      ; func6 (06 - 06) get Direct Console Out
0461: E8CE 79                     LD     A,C
0462: E8CF 3C                     INC    A
0463: E8D0 CA D7 E8               JP     Z,fDirectConIn       ; 0ffh => 00h, means input mode, else
0464: E8D3 CD 0C F6               CALL   bcConout             ; direct output function
0465: E8D6 C9                     RET
0466: E8D7             fDirectConIn:
0467: E8D7 CD 06 F6               CALL   bcConst              ; status check
0468: E8DA B7                     OR     A
0469: E8DB CA 5D E8               JP     Z,RetDiskMon         ; skip, return 00 if not ready
0470: E8DE CD 09 F6               CALL   bcConin              ; character is ready, get it to A
0471: E8E1 32 36 F5               LD     (statusBDOSReturn),A
0472: E8E4 C9                     RET
0473: E8E5         ;----------
0474: E8E5         ;return io byte
0475: E8E5             vGetIOBYTE:                      ; func7 (07 - 07) get IOBYTE
0476: E8E5 3A 03 00               LD     A,(IOBYTE)           ; get the byte
0477: E8E8 32 36 F5               LD     (statusBDOSReturn),A
0478: E8EB C9                     RET
0479: E8EC         ;----------
0480: E8EC         ;set i/o byte
0481: E8EC             vSetIOBYTE:                      ; func8 (08 - 08)	set IOBYTE
0482: E8EC 21 03 00               LD     HL,IOBYTE
0483: E8EF 71                     LD     (HL),C               ; put passed value into IOBYTE
0484: E8F0 C9                     RET
0485: E8F1         ;----------
0486: E8F1         ;write line until $ encountered
0487: E8F1             vPrintString:                      ; func9 (09 - 09)	 Print Dollar terminated String
0488: E8F1 2A 34 F5               LD     HL,(paramDE)
0489: E8F4 4D                     LD     C,L
0490: E8F5 44                     LD     B,H                  ; BC=string address
0491: E8F6 CD 58 F4               CALL   Print                ; out to console
0492: E8F9 C9                     RET
0493: E8FA         ;----------
0494: E8FA         ;read String from Console until limit or CR is reached
0495: E8FA         ;In - (DE) = limit
0496: E8FA         ;Out - (DE+1) = count of chars read (DE+2) = characters read
0497: E8FA             vReadString:                      ; func10 (10 - 0A)	read String from console
0498: E8FA CD 50 EA               CALL   ReadString
0499: E8FD C9                     RET
0500: E8FE         ;----------
0501: E8FE         ;check console status
0502: E8FE             vGetConsoleStatus:                      ; func11 (11 - 01)	read Dollar terminated String from console
0503: E8FE CD 11 F4               CALL   ConBreak
0504: E901 32 36 F5               LD     (statusBDOSReturn),A
0505: E904 C9                     RET
0506: E905         ;----------
0507: E905         ;get/set user code
0508: E905         ; IN - (E) = FF its a get else user Number(0-15)
0509: E905         ; OUT - (A) Current user number or no value
0510: E905             vGetSetUserNumber:                      ; func32 (32 - 20)	Get or set User code
0511: E905 3A 5D F5               LD     A,(paramE)
0512: E908 FE FF                  CP     0FFH
0513: E90A C2 14 E9               JP     NZ,SetUserNumber     ; interrogate user code instead
0514: E90D 3A 33 F5               LD     A,(currentUserNumber)
0515: E910 32 36 F5               LD     (lowReturnStatus),A  ; lowReturnStatus=currentUserNumber
0516: E913 C9                     RET
0517: E914
0518: E914             SetUserNumber:                      ; setusrcode
0519: E914 E6 0F                  AND    LO_NIBBLE_MASK
0520: E916 32 33 F5               LD     (currentUserNumber),A
0521: E919 C9                     RET
0522: E91A
0523: E91A         ;*****************************************************************
0524: E91A         ;random disk read
0525: E91A         ;IN  - (DE) FCB address
0526: E91A         ;OUT - (A) 01 = Reading unwritten data
0527: E91A         ;	 02 = N/U
0528: E91A         ;	 03 = Cannot close current extent
0529: E91A         ;	 04 = Seek to unwriten Extent
0530: E91A         ;	 05 = N/U
0531: E91A         ;	 06 = Seek past Physical end of Disk
0532: E91A             vReadRandom:                      ; func33 (33 - 21) Read Random record
0533: E91A CD 40 F2               CALL   Reselect
0534: E91D C3 31 E9               JP     RandomDiskRead       ; to perform the disk read
0535: E920         ;*****************************************************************
0536: E920         ;write random record
0537: E920         ;IN  - (DE) FCB address
0538: E920         ;OUT - (A) 01 = Reading unwritten data
0539: E920         ;	 02 = N/U
0540: E920         ;	 03 = Cannot close current extent
0541: E920         ;	 04 = Seek to unwriten Extent
0542: E920         ;	 05 = Cannot create new Extent because of directory overflow
0543: E920         ;	 06 = Seek past Physical end of Disk
0544: E920             vWriteRandom:                      ; func34 (34 - 22) Write Random record
0545: E920 CD 40 F2               CALL   Reselect
0546: E923 C3 3A E9               JP     RandomDiskWrite      ; to perform the disk write
0547: E926         ;ret ;jmp goback
0548: E926         ;*****************************************************************
0549: E926         ;return file size (0-65536)
0550: E926         ;IN  - (DE) FCB address
0551: E926             vComputeFileSize:                      ; func35 (35 - 23) Compute File Size
0552: E926 CD 40 F2               CALL   Reselect
0553: E929 C3 E7 E9               JP     GetFileSize
0554: E92C         ;*****************************************************************
0555: E92C         ;set random record
0556: E92C         ;IN  - (DE) FCB address
0557: E92C         ;OUT - Random Record Field is set
0558: E92C             vSetRandomRecord:                      ; func36 (36 - 24) Set random Record
0559: E92C C3 D4 E9               JP     SetRandomRecord
0560: E92F         ;*****************************************************************
0561: E92F         ;Reset Drive
0562: E92F         ;IN  - (DE) Drive Vector
0563: E92F         ;OUT - (A) 00
0564: E92F             vResetDrive:                      ; func37 (37 - 25) Reset Drive
0565: E92F         ; Not Yet Implemented   **************
0566: E92F C9                     RET
0567: E930         ;*****************************************************************
0568: E930         ;*****************************************************************
0569: E930         ;Write Random With Zero Fill
0570: E930         ;IN  - (DE) FCB address
0571: E930         ;OUT - (A) Return Code		see Function 34
0572: E930             vWriteRandom0Fill:                      ; func40 (40 - 28) Reset Drive
0573: E930         ; Not Yet Implemented   **************
0574: E930 C9                     RET
0575: E931         ;*****************************************************************
0576: E931         ;******************< Random I/O Stuff ****************************
0577: E931         ;*****************************************************************
0578: E931         ;random disk read
0579: E931             RandomDiskRead:                      ; randiskread
0580: E931 0E FF                  LD     C,TRUE               ; marked as read operation
0581: E933 CD 43 E9               CALL   RandomSeek
0582: E936 CC 32 EF               CALL   Z,DiskRead           ; if seek successful
0583: E939 C9                     RET
0584: E93A         ;*****************************************************************
0585: E93A         ;random disk write
0586: E93A             RandomDiskWrite:                      ; randiskwrite
0587: E93A 0E 00                  LD     C,FALSE              ; marked as read operation
0588: E93C CD 43 E9               CALL   RandomSeek
0589: E93F CC 75 EF               CALL   Z,DiskWrite          ; if seek successful
0590: E942 C9                     RET
0591: E943         ;*****************************************************************
0592: E943         ;*****************************************************************
0593: E943         ;random access seek operation, C=0ffh if read mode
0594: E943         ;fcb is assumed to address an active file control block
0595: E943         ;(fcbS2Index has been set to 11000000b if previous bad seek)
0596: E943             RandomSeek:
0597: E943 AF                     XOR    A
0598: E944 32 63 F5               LD     (seqReadFlag),A      ; marked as random access operation
0599: E947 C5                     PUSH   BC                   ; save r/w flag
0600: E948 2A 34 F5               LD     HL,(paramDE)
0601: E94B EB                     EX     DE,HL                ; DE will hold base of fcb
0602: E94C 21 21 00               LD     HL,RANDOM_REC_FIELD
0603: E94F 19                     ADD    HL,DE                ; HL=.fcb(RANDOM_REC_FIELD)
0604: E950 7E                     LD     A,(HL)
0605: E951 E6 7F                  AND    7FH
0606: E953 F5                     PUSH   AF                   ; record number
0607: E954 7E                     LD     A,(HL)
0608: E955 17                     RLA                         ; cy=lsb of extent#
0609: E956 23                     INC    HL
0610: E957 7E                     LD     A,(HL)
0611: E958 17                     RLA
0612: E959 E6 1F                  AND    11111B               ; A=ext#
0613: E95B 4F                     LD     C,A                  ; C holds extent number, record stacked
0614: E95C 7E                     LD     A,(HL)
0615: E95D 1F                     RRA
0616: E95E 1F                     RRA
0617: E95F 1F                     RRA
0618: E960 1F                     RRA
0619: E961 E6 0F                  AND    1111B                ; mod#
0620: E963 47                     LD     B,A                  ; B holds module#, C holds ext#
0621: E964 F1                     POP    AF                   ; recall sought record #
0622: E965         ;check to insure that high byte of ran rec = 00
0623: E965 23                     INC    HL
0624: E966 6E                     LD     L,(HL)               ; l=high byte (must be 00)
0625: E967 2C                     INC    L
0626: E968 2D                     DEC    L
0627: E969 2E 06                  LD     L,06                 ; zero flag, l=6
0628: E96B         ; produce error 6, seek past physical eod
0629: E96B C2 CC E9               JP     NZ,RandomSeekError
0630: E96E         ; otherwise, high byte = 0, A = sought record
0631: E96E 21 20 00               LD     HL,NEXT_RECORD
0632: E971 19                     ADD    HL,DE                ; HL = .fcb(NEXT_RECORD)
0633: E972 77                     LD     (HL),A               ; sought rec# stored away
0634: E973         ; arrive here with B=mod#, C=ext#, DE=.fcb, rec stored
0635: E973         ; the r/w flag is still stacked.  compare fcb values
0636: E973 21 0C 00               LD     HL,fcbExtIndex       ; extent number field
0637: E976 19                     ADD    HL,DE
0638: E977 79                     LD     A,C                  ; A=seek ext#
0639: E978 96                     SUB    M
0640: E979 C2 87 E9               JP     NZ,RandomSeekClose   ; tests for = extents
0641: E97C         ; extents match, check mod#
0642: E97C 21 0E 00               LD     HL,fcbS2Index
0643: E97F 19                     ADD    HL,DE
0644: E980 78                     LD     A,B                  ; B=seek mod#
0645: E981         ; could be overflow at eof, producing module#
0646: E981         ; of 90H or 10H, so compare all but fwf
0647: E981 96                     SUB    M
0648: E982 E6 7F                  AND    7FH
0649: E984 CA BF E9               JP     Z,RandomSeekExit     ; same?
0650: E987             RandomSeekClose:
0651: E987 C5                     PUSH   BC
0652: E988 D5                     PUSH   DE                   ; save seek mod#,ext#, .fcb
0653: E989 CD 15 F1               CALL   CloseDirEntry        ; current extent closed
0654: E98C D1                     POP    DE
0655: E98D C1                     POP    BC                   ; recall parameters and fill
0656: E98E 2E 03                  LD     L,03                 ; cannot close error #3
0657: E990 3A 36 F5               LD     A,(lowReturnStatus)
0658: E993 3C                     INC    A
0659: E994 CA C5 E9               JP     Z,RandomSeekErrorBadSeek
0660: E997 21 0C 00               LD     HL,fcbExtIndex
0661: E99A 19                     ADD    HL,DE
0662: E99B 71                     LD     (HL),C               ; fcb(fcbExtIndex)=ext#
0663: E99C 21 0E 00               LD     HL,fcbS2Index
0664: E99F 19                     ADD    HL,DE
0665: E9A0 70                     LD     (HL),B               ; fcb(fcbS2Index)=mod#
0666: E9A1 CD 6D F2               CALL   OpenFile             ; is the file present?
0667: E9A4 3A 36 F5               LD     A,(lowReturnStatus)
0668: E9A7 3C                     INC    A
0669: E9A8 C2 BF E9               JP     NZ,RandomSeekExit    ; open successful?
0670: E9AB         ; cannot open the file, read mode?
0671: E9AB C1                     POP    BC                   ; r/w flag to c (=0ffh if read)
0672: E9AC C5                     PUSH   BC                   ; everyone expects this item stacked
0673: E9AD 2E 04                  LD     L,04                 ; seek to unwritten extent #4
0674: E9AF 0C                     INC    C                    ; becomes 00 if read operation
0675: E9B0 CA C5 E9               JP     Z,RandomSeekErrorBadSeek ; skip to error if read operation
0676: E9B3 CD BD F0               CALL   MakeNewFile          ; write operation, make new extent
0677: E9B6 2E 05                  LD     L,05                 ; cannot create new extent #5
0678: E9B8 3A 36 F5               LD     A,(lowReturnStatus)
0679: E9BB 3C                     INC    A
0680: E9BC CA C5 E9               JP     Z,RandomSeekErrorBadSeek ; no dir space
0681: E9BF         ; file make operation successful
0682: E9BF             RandomSeekExit:                      ; seekok:
0683: E9BF C1                     POP    BC                   ; discard r/w flag
0684: E9C0 AF                     XOR    A
0685: E9C1 32 36 F5               LD     (lowReturnStatus),A
0686: E9C4 C9                     RET                         ; with zero set
0687: E9C5
0688: E9C5             RandomSeekErrorBadSeek:
0689: E9C5         ; fcb no longer contains a valid fcb, mark with 11000000b in fcbS2Index field so that it
0690: E9C5         ; appears as overflow with file write flag set
0691: E9C5 E5                     PUSH   HL                   ; save error flag
0692: E9C6 CD 37 F2               CALL   GetModuleNum         ; HL = .fcbS2Index
0693: E9C9 36 C0                  LD     (HL),11000000B
0694: E9CB E1                     POP    HL                   ; and drop through
0695: E9CC             RandomSeekError:                      ; seekerr:
0696: E9CC C1                     POP    BC                   ; discard r/w flag
0697: E9CD 7D                     LD     A,L
0698: E9CE 32 36 F5               LD     (lowReturnStatus),A  ; lowReturnStatus=#, nonzero
0699: E9D1         ; SetFileWriteFlag returns non-zero accumulator for err
0700: E9D1 C3 40 F3               JP     SetFileWriteFlag     ; flag set, so subsequent close ok
0701: E9D4         ;ret
0702: E9D4         ;
0703: E9D4         ;*****************************************************************
0704: E9D4             SetRandomRecord:                      ; setrandom
0705: E9D4 2A 34 F5               LD     HL,(paramDE)
0706: E9D7 11 20 00               LD     DE,NEXT_RECORD       ; ready params for computesize
0707: E9DA CD 23 EA               CALL   GetRandomRecordPosition ; DE=paramDE, A=cy, BC=mmmm eeee errr rrrr
0708: E9DD 21 21 00               LD     HL,RANDOM_REC_FIELD
0709: E9E0 19                     ADD    HL,DE                ; HL = .FCB(RANDOM_REC_FIELD)
0710: E9E1 71                     LD     (HL),C
0711: E9E2 23                     INC    HL
0712: E9E3 70                     LD     (HL),B
0713: E9E4 23                     INC    HL
0714: E9E5 77                     LD     (HL),A               ; to RANDOM_REC_FIELD
0715: E9E6 C9                     RET
0716: E9E7         ;*****************************************************************
0717: E9E7         ;compute logical file size for current fcb
0718: E9E7             GetFileSize:                      ; getfilesize
0719: E9E7 0E 0C                  LD     C,fcbExtIndex
0720: E9E9 CD B0 F2               CALL   Search4DirElement
0721: E9EC         ; zero the receiving Ramdom record field
0722: E9EC 2A 34 F5               LD     HL,(paramDE)
0723: E9EF 11 21 00               LD     DE,RANDOM_REC_FIELD
0724: E9F2 19                     ADD    HL,DE
0725: E9F3 E5                     PUSH   HL                   ; save position
0726: E9F4 72                     LD     (HL),D
0727: E9F5 23                     INC    HL
0728: E9F6 72                     LD     (HL),D
0729: E9F7 23                     INC    HL
0730: E9F8 72                     LD     (HL),D               ; =00 00 00
0731: E9F9             GetFileSize1:                      ; getsize:
0732: E9F9 CD 54 ED               CALL   EndOfDirectory
0733: E9FC CA 21 EA               JP     Z,GetFileSizeExit
0734: E9FF         ; current fcb addressed by dptr
0735: E9FF CD 40 EE               CALL   GetDirElementAddress
0736: EA02 11 0F 00               LD     DE,fcbRCIndex        ; ready for compute size
0737: EA05 CD 23 EA               CALL   GetRandomRecordPosition
0738: EA08         ; A=0000 000? BC = mmmm eeee errr rrrr compare with memory, larger?
0739: EA08 E1                     POP    HL
0740: EA09 E5                     PUSH   HL                   ; recall, replace .fcb(Random record Field)
0741: EA0A 5F                     LD     E,A                  ; save cy
0742: EA0B 79                     LD     A,C
0743: EA0C 96                     SUB    M
0744: EA0D 23                     INC    HL                   ; ls byte
0745: EA0E 78                     LD     A,B
0746: EA0F 9E                     SBC    A,(HL)
0747: EA10 23                     INC    HL                   ; middle byte
0748: EA11 7B                     LD     A,E
0749: EA12 9E                     SBC    A,(HL)               ; carry if .fcb(random record field) > directory
0750: EA13 DA 1B EA               JP     C,GetFileSize2       ; for another try
0751: EA16         ; fcb is less or equal, fill from directory
0752: EA16 73                     LD     (HL),E
0753: EA17 2B                     DEC    HL
0754: EA18 70                     LD     (HL),B
0755: EA19 2B                     DEC    HL
0756: EA1A 71                     LD     (HL),C
0757: EA1B             GetFileSize2:                      ; getnextsize:
0758: EA1B CD C8 F2               CALL   Search4NextDirElement
0759: EA1E C3 F9 E9               JP     GetFileSize1
0760: EA21             GetFileSizeExit:                      ; setsize:
0761: EA21 E1                     POP    HL                   ; discard .fcb(random record field)
0762: EA22 C9                     RET
0763: EA23         ;-----------------------------------------------------------------
0764: EA23         ;compute random record position
0765: EA23             GetRandomRecordPosition:                      ; compute$rr
0766: EA23 EB                     EX     DE,HL
0767: EA24 19                     ADD    HL,DE
0768: EA25         ; DE=.buf(dptr) or .fcb(0), HL = .f(NEXT_RECORD/fcbRCIndex)
0769: EA25 4E                     LD     C,(HL)
0770: EA26 06 00                  LD     B,0                  ; BC = 0000 0000 ?rrr rrrr
0771: EA28 21 0C 00               LD     HL,fcbExtIndex
0772: EA2B 19                     ADD    HL,DE
0773: EA2C 7E                     LD     A,(HL)
0774: EA2D 0F                     RRCA
0775: EA2E E6 80                  AND    80H                  ; A=e000 0000
0776: EA30 81                     ADD    A,C
0777: EA31 4F                     LD     C,A
0778: EA32 3E 00                  LD     A,0
0779: EA34 88                     ADC    A,B
0780: EA35 47                     LD     B,A
0781: EA36         ; BC = 0000 000? errrr rrrr
0782: EA36 7E                     LD     A,(HL)
0783: EA37 0F                     RRCA
0784: EA38 E6 0F                  AND    LO_NIBBLE_MASK
0785: EA3A 80                     ADD    A,B
0786: EA3B 47                     LD     B,A
0787: EA3C         ; BC = 000? eeee errrr rrrr
0788: EA3C 21 0E 00               LD     HL,fcbS2Index
0789: EA3F 19                     ADD    HL,DE
0790: EA40 7E                     LD     A,(HL)               ; A=XXX? mmmm
0791: EA41 87                     ADD    A,A
0792: EA42 87                     ADD    A,A
0793: EA43 87                     ADD    A,A
0794: EA44 87                     ADD    A,A                  ; cy=? A=mmmm 0000
0795: EA45 F5                     PUSH   AF
0796: EA46 80                     ADD    A,B
0797: EA47 47                     LD     B,A
0798: EA48         ; cy=?, BC = mmmm eeee errr rrrr
0799: EA48 F5                     PUSH   AF                   ; possible second carry
0800: EA49 E1                     POP    HL                   ; cy = lsb of L
0801: EA4A 7D                     LD     A,L                  ; cy = lsb of A
0802: EA4B E1                     POP    HL                   ; cy = lsb of L
0803: EA4C B5                     OR     L                    ; cy/cy = lsb of A
0804: EA4D E6 01                  AND    1                    ; A = 0000 000? possible carry-out
0805: EA4F C9                     RET
0806: EA50         ;-----------------------------------------------------------------
0807: EA50
0808: EA50         ;*****************************************************************
0809: EA50         ;****************** Random I/O Stuff >****************************
0810: EA50         ;*****************************************************************
0811: EA50
0812: EA50
0813: EA50         ;read to paramDE address (max length, current length, buffer)
0814: EA50             ReadString:
0815: EA50 3A 7A F5               LD     A,(columnPosition)
0816: EA53 32 79 F5               LD     (startingColumn),A   ; save start for ctl-x, ctl-h
0817: EA56 2A 34 F5               LD     HL,(paramDE)
0818: EA59 4E                     LD     C,(HL)
0819: EA5A 23                     INC    HL
0820: EA5B E5                     PUSH   HL
0821: EA5C 06 00                  LD     B,0
0822: EA5E         ; B = current buffer length,
0823: EA5E         ; C = maximum buffer length,
0824: EA5E         ; HL= next to fill - 1
0825: EA5E
0826: EA5E         ; read next character, BC, HL active
0827: EA5E             ReadNext:
0828: EA5E C5                     PUSH   BC
0829: EA5F E5                     PUSH   HL                   ; blen, cmax, HL saved
0830: EA60             ReadNext0:
0831: EA60 CD E9 F3               CALL   ConIn                ; next char in A
0832: EA63 E6 7F                  AND    ASCII_MASK           ; mask parity bit
0833: EA65 E1                     POP    HL
0834: EA66 C1                     POP    BC                   ; reactivate counters
0835: EA67 FE 0D                  CP     CR
0836: EA69 CA 30 EB               JP     Z,EndRead            ; end of line?
0837: EA6C FE 0A                  CP     LF
0838: EA6E CA 30 EB               JP     Z,EndRead            ; also end of line
0839: EA71 FE 08                  CP     CTRL_H
0840: EA73 C2 85 EA               JP     NZ,NotCtntl_H        ; backspace?
0841: EA76         ; do we have any characters to back over?
0842: EA76 78                     LD     A,B
0843: EA77 B7                     OR     A
0844: EA78 CA 5E EA               JP     Z,ReadNext
0845: EA7B         ; characters remain in buffer, backup one
0846: EA7B 05                     DEC    B                    ; remove one character
0847: EA7C 3A 7A F5               LD     A,(columnPosition)
0848: EA7F 32 78 F5               LD     (compcol),A          ; col > 0
0849: EA82         ; compcol > 0 marks repeat as length compute
0850: EA82 C3 DF EA               JP     LineLengthOrRepeat   ; uses same code as repeat
0851: EA85         ; not a backspace
0852: EA85             NotCtntl_H:
0853: EA85 FE 7F                  CP     RUBOUT
0854: EA87 C2 95 EA               JP     NZ,NotRubout         ; RUBOUT char?
0855: EA8A         ; RUBOUT encountered, RUBOUT if possible
0856: EA8A 78                     LD     A,B
0857: EA8B B7                     OR     A
0858: EA8C CA 5E EA               JP     Z,ReadNext           ; skip if len=0
0859: EA8F         ; buffer has characters, resend last char
0860: EA8F 7E                     LD     A,(HL)
0861: EA90 05                     DEC    B
0862: EA91 2B                     DEC    HL                   ; A = LAST CHAR
0863: EA92         ; BLEN=BLEN-1, NEXT TO FILL - 1 DECREMENTED
0864: EA92 C3 18 EB               JP     ReadEcho1            ; act like this is an echo
0865: EA95         ;
0866: EA95         ; not a RUBOUT character, check end line
0867: EA95             NotRubout:
0868: EA95 FE 05                  CP     CTRL_E
0869: EA97 C2 A6 EA               JP     NZ,NotCtntl_E        ; physical end line?
0870: EA9A         ; yes, save active counters and force eol
0871: EA9A C5                     PUSH   BC
0872: EA9B E5                     PUSH   HL
0873: EA9C CD 4E F4               CALL   showCRLF
0874: EA9F AF                     XOR    A
0875: EAA0 32 79 F5               LD     (startingColumn),A   ; start position = 00
0876: EAA3 C3 60 EA               JP     ReadNext0            ; for another character
0877: EAA6             NotCtntl_E:
0878: EAA6         ; not end of line, list toggle?
0879: EAA6 FE 10                  CP     CTRL_P
0880: EAA8 C2 B7 EA               JP     NZ,NotCtntl_P        ; skip if not CTRL_P
0881: EAAB         ; list toggle - change parity
0882: EAAB E5                     PUSH   HL                   ; save next to fill - 1
0883: EAAC 21 7B F5               LD     HL,listeningToggle   ; HL=.listeningToggle flag
0884: EAAF 3E 01                  LD     A,1
0885: EAB1 96                     SUB    M                    ; True-listeningToggle
0886: EAB2 77                     LD     (HL),A               ; listeningToggle = not listeningToggle
0887: EAB3 E1                     POP    HL
0888: EAB4 C3 5E EA               JP     ReadNext             ; for another char
0889: EAB7         ; not a CTRL_P, line delete?
0890: EAB7             NotCtntl_P:
0891: EAB7 FE 18                  CP     CTRL_X
0892: EAB9 C2 CE EA               JP     NZ,NotCtntl_X
0893: EABC E1                     POP    HL                   ; discard start position
0894: EABD         ; loop while columnPosition > startingColumn
0895: EABD             GoBack:
0896: EABD 3A 79 F5               LD     A,(startingColumn)
0897: EAC0 21 7A F5               LD     HL,columnPosition
0898: EAC3 BE                     CP     M
0899: EAC4 D2 50 EA               JP     NC,ReadString        ; start again
0900: EAC7 35                     DEC    M                    ; columnPosition = columnPosition - 1
0901: EAC8 CD 37 EB               CALL   BackUp               ; one position
0902: EACB C3 BD EA               JP     GoBack
0903: EACE
0904: EACE         ; not a control X, control U?
0905: EACE             NotCtntl_X:
0906: EACE FE 15                  CP     CTRL_U
0907: EAD0 C2 DA EA               JP     NZ,NotCtntl_U        ; skip if not
0908: EAD3         ; delete line (CTRL_U)
0909: EAD3 CD 36 F4               CALL   showHashCRLF         ; physical eol
0910: EAD6 E1                     POP    HL                   ; discard starting position
0911: EAD7 C3 50 EA               JP     ReadString           ; to start all over
0912: EADA             NotCtntl_U:
0913: EADA         ; not line delete, repeat line?
0914: EADA FE 12                  CP     CTRL_R
0915: EADC C2 15 EB               JP     NZ,NotCtntl_R
0916: EADF             LineLengthOrRepeat:
0917: EADF         ; repeat line, or compute line len (CTRL_H) if compcol > 0
0918: EADF C5                     PUSH   BC
0919: EAE0 CD 36 F4               CALL   showHashCRLF         ; save line length
0920: EAE3 C1                     POP    BC
0921: EAE4 E1                     POP    HL
0922: EAE5 E5                     PUSH   HL
0923: EAE6 C5                     PUSH   BC
0924: EAE7         ; bcur, cmax active, beginning buff at HL
0925: EAE7             Repeat:
0926: EAE7 78                     LD     A,B
0927: EAE8 B7                     OR     A
0928: EAE9 CA F9 EA               JP     Z,Repeat1            ; count len to 00
0929: EAEC 23                     INC    HL
0930: EAED 4E                     LD     C,(HL)               ; next to print
0931: EAEE 05                     DEC    B
0932: EAEF C5                     PUSH   BC
0933: EAF0 E5                     PUSH   HL                   ; count length down
0934: EAF1 CD 44 EB               CALL   CaretCout            ; character echoed
0935: EAF4 E1                     POP    HL
0936: EAF5 C1                     POP    BC                   ; recall remaining count
0937: EAF6 C3 E7 EA               JP     Repeat               ; for the next character
0938: EAF9             Repeat1:                        ; rep1:
0939: EAF9         ; end of repeat, recall lengths original BC still remains pushed
0940: EAF9 E5                     PUSH   HL                   ; save next to fill
0941: EAFA 3A 78 F5               LD     A,(compcol)
0942: EAFD B7                     OR     A                    ; >0 if computing length
0943: EAFE CA 60 EA               JP     Z,ReadNext0          ; for another char if so
0944: EB01         ; columnPosition position computed for CTRL_H
0945: EB01 21 7A F5               LD     HL,columnPosition
0946: EB04 96                     SUB    M                    ; diff > 0
0947: EB05 32 78 F5               LD     (compcol),A          ; count down below
0948: EB08         ; move back compcol-columnPosition spaces
0949: EB08
0950: EB08         ; move back one more space
0951: EB08             BackSpace:
0952: EB08 CD 37 EB               CALL   BackUp               ; one space
0953: EB0B 21 78 F5               LD     HL,compcol
0954: EB0E 35                     DEC    M
0955: EB0F C2 08 EB               JP     NZ,BackSpace
0956: EB12 C3 60 EA               JP     ReadNext0            ; for next character
0957: EB15
0958: EB15         ; not a CTRL_R, place into buffer
0959: EB15             NotCtntl_R:
0960: EB15
0961: EB15             ReadEcho:
0962: EB15 23                     INC    HL
0963: EB16 77                     LD     (HL),A               ; character filled to mem
0964: EB17 04                     INC    B                    ; blen = blen + 1
0965: EB18             ReadEcho1:
0966: EB18         ; look for a random control character
0967: EB18 C5                     PUSH   BC
0968: EB19 E5                     PUSH   HL                   ; active values saved
0969: EB1A 4F                     LD     C,A                  ; ready to print
0970: EB1B CD 44 EB               CALL   CaretCout            ; may be up-arrow C
0971: EB1E E1                     POP    HL
0972: EB1F C1                     POP    BC
0973: EB20 7E                     LD     A,(HL)               ; recall char
0974: EB21 FE 03                  CP     CTRL_C               ; set flags for reboot test
0975: EB23 78                     LD     A,B                  ; move length to A
0976: EB24 C2 2C EB               JP     NZ,NotCtntl_C        ; skip if not a control c
0977: EB27 FE 01                  CP     1                    ; control C, must be length 1
0978: EB29 CA 00 00               JP     Z,WarmBoot           ; reboot if blen = 1
0979: EB2C         ; length not one, so skip reboot
0980: EB2C             NotCtntl_C:
0981: EB2C         ; not reboot, are we at end of buffer?
0982: EB2C B9                     CP     C
0983: EB2D DA 5E EA               JP     C,ReadNext           ; go for another if not paramDE
0984: EB30
0985: EB30         ; end of read operation, store blen
0986: EB30             EndRead:
0987: EB30 E1                     POP    HL
0988: EB31 70                     LD     (HL),B               ; M(current len) = B
0989: EB32 0E 0D                  LD     C,CR
0990: EB34 C3 66 F4               JP     ConsoleOut           ; return carriage
0991: EB37
0992: EB37         ;------------------
0993: EB37         ;back-up one screen position
0994: EB37             BackUp:
0995: EB37 CD 3F EB               CALL   PutCntl_H
0996: EB3A 0E 20                  LD     C,SPACE
0997: EB3C CD 0C F6               CALL   bcConout
0998: EB3F         ;send CTRL_H to console without affecting column count
0999: EB3F             PutCntl_H:
1000: EB3F 0E 08                  LD     C,CTRL_H
1001: EB41 C3 0C F6               JP     bcConout
1002: EB44         ;ret
1003: EB44         ;----------------------------------------------------------------
1004: EB44         ;
1005: EB44
1006: EB44
1007: EB44         ;------------------
1008: EB44         ;send C character with possible preceding up-arrow
1009: EB44             CaretCout:
1010: EB44 79                     LD     A,C
1011: EB45 CD F4 F3               CALL   EchoNonGraphicCharacter ; cy if not graphic (or special case)
1012: EB48 D2 55 EB               JP     NC,TabOut            ; skip if graphic, TAB, CR, LF, or CTRL_H
1013: EB4B         ; send preceding up arrow
1014: EB4B F5                     PUSH   AF
1015: EB4C 0E 5E                  LD     C,CARET
1016: EB4E CD 66 F4               CALL   ConsoleOut           ; up arrow
1017: EB51 F1                     POP    AF
1018: EB52 F6 40                  OR     40H                  ; becomes graphic letter
1019: EB54 4F                     LD     C,A                  ; ready to print
1020: EB55
1021: EB55         ;expand tabs to console
1022: EB55             TabOut:
1023: EB55 79                     LD     A,C
1024: EB56 FE 09                  CP     TAB
1025: EB58 C2 66 F4               JP     NZ,ConsoleOut        ; direct to ConsoleOut if not
1026: EB5B         ; TAB encountered, move to next TAB position
1027: EB5B             TabOut0:
1028: EB5B 0E 20                  LD     C,SPACE
1029: EB5D CD 66 F4               CALL   ConsoleOut           ; another blank
1030: EB60 3A 7A F5               LD     A,(columnPosition)
1031: EB63 E6 07                  AND    111b                 ; columnPosition mod 8 = 0 ?
1032: EB65 C2 5B EB               JP     NZ,TabOut0           ; back for another if not
1033: EB68 C9                     RET
1034: EB69         ;--------------------
1035: EB69
1036: EB69
1037: EB69         ;*****************************************************************
1038: EB69         ;********************** Disk  I/O ********************************
1039: EB69         ;*****************************************************************
1040: EB69
1041: EB69         ;reset disk system - initialize to disk 0
1042: EB69             vResetSystem:                      ; func13 (13 - 0D)	 Reset Disk System
1043: EB69 21 00 00               LD     HL,0
1044: EB6C 22 3A F5               LD     (ReadOnlyVector),HL
1045: EB6F 22 3C F5               LD     (loggedDisks),HL     ; clear the vectors for R/O and Logged Disks
1046: EB72 AF                     XOR    A                    ; also clear the current disk
1047: EB73 32 38 F5               LD     (currentDisk),A      ; note that currentUserNumber remains unchanged
1048: EB76 21 80 00               LD     HL,DMABuffer
1049: EB79 22 3E F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = DMABuffer
1050: EB7C CD 45 ED               CALL   SetDataDMA           ; to data dma address
1051: EB7F C3 C9 EB               JP     Select
1052: EB82         ;ret ;jmp goback
1053: EB82         ;-----------------------------------------------------------------
1054: EB82         ;select disk in (E) paramDE
1055: EB82         ; IN - (E) disk number -- 0=A  1=B ...15=P
1056: EB82             vSelectDisk:                      ; func14 (14 - 0E)	Select Current Disk
1057: EB82 C3 BD EB               JP     SelectCurrent
1058: EB85         ;ret ;jmp goba
1059: EB85         ;-----------------------------------------------------------------
1060: EB85         ;return the login vector
1061: EB85         ;OUT - (HL) loggedDisks
1062: EB85             vGetLoginVector:                      ; func24: (24 - 18) Return login Vector
1063: EB85 2A 3C F5               LD     HL,(loggedDisks)
1064: EB88 22 36 F5               LD     (statusBDOSReturn),HL
1065: EB8B C9                     RET
1066: EB8C         ;-----------------------------------------------------------------
1067: EB8C         ;return selected disk number
1068: EB8C         ;OUT - A current disk -- 0=A  1=B ...15=P
1069: EB8C             vGetCurrentDisk:                      ; func25 (25 - 19)	Get Current Disk
1070: EB8C 3A 38 F5               LD     A,(currentDisk)
1071: EB8F 32 36 F5               LD     (lowReturnStatus),A
1072: EB92 C9                     RET
1073: EB93         ;-----------------------------------------------------------------
1074: EB93         ;set the subsequent dma address to paramDE
1075: EB93         ;IN - (HL) value to set as DMA
1076: EB93             vSetDMA:                        ; func26 (25 - 1A) Set Dma Address
1077: EB93 2A 34 F5               LD     HL,(paramDE)
1078: EB96 22 3E F5               LD     (InitDAMAddress),HL  ; InitDAMAddress = paramDE
1079: EB99 C3 45 ED               JP     SetDataDMA           ; to data dma address
1080: EB9C         ;-----------------------------------------------------------------
1081: EB9C         ;return the Allocation Vector Address
1082: EB9C         ;OUT - (HL) Allocation Vector Address
1083: EB9C             vGetAllocAddr:                      ; func27 (27 - 1B) Get Allocation Vector Address
1084: EB9C 2A 4C F5               LD     HL,(caAllocVector)
1085: EB9F 22 36 F5               LD     (statusBDOSReturn),HL
1086: EBA2 C9                     RET
1087: EBA3         ;-----------------------------------------------------------------
1088: EBA3         ;;write protect current disk
1089: EBA3             vWriteProtectDisk:                      ; func28 (28 - 1C) Write protect disk
1090: EBA3 C3 48 EC               JP     SetDiskReadOnly
1091: EBA6         ;-----------------------------------------------------------------
1092: EBA6         ;return r/o bit vector
1093: EBA6         ;OUT - (HL) Read Only Vector Vector
1094: EBA6             vGetRoVector:                      ; func29 (29 - 1D)	Get read Only vector
1095: EBA6 2A 3A F5               LD     HL,(ReadOnlyVector)
1096: EBA9 22 36 F5               LD     (statusBDOSReturn),HL
1097: EBAC C9                     RET
1098: EBAD         ;-----------------------------------------------------------------
1099: EBAD         ;;set file Attributes
1100: EBAD             vSetFileAttributes:                      ; func30 (30 - 1E) Set File Attributes
1101: EBAD CD 40 F2               CALL   Reselect
1102: EBB0 CD 95 EE               CALL   SetAttributes
1103: EBB3 C3 2A F2               JP     DirLocationToReturnLoc ; lowReturnStatus=dirloc
1104: EBB6         ;-----------------------------------------------------------------
1105: EBB6         ;return address of disk parameter block
1106: EBB6         ; OUT - (HL) Disk Parameter Black for current drive
1107: EBB6             vGetDiskParamBlock:                      ; func31 (31 - 1F)
1108: EBB6 2A 48 F5               LD     HL,(caDiskParamBlock)
1109: EBB9 22 36 F5               LD     (statusBDOSReturn),HL
1110: EBBC C9                     RET
1111: EBBD         ;-----------------------------------------------------------------
1112: EBBD
1113: EBBD             SelectCurrent:                      ; curselect
1114: EBBD 3A 5D F5               LD     A,(paramE)
1115: EBC0 21 38 F5               LD     HL,currentDisk
1116: EBC3 BE                     CP     M
1117: EBC4 C8                     RET    Z                    ; exit if parame = Current disk
1118: EBC5 77                     LD     (HL),A
1119: EBC6 C3 C9 EB               JP     Select
1120: EBC9         ;*****************************************************************
1121: EBC9         ; select Login Drive
1122: EBC9             Select:
1123: EBC9 2A 3C F5               LD     HL,(loggedDisks)
1124: EBCC 3A 38 F5               LD     A,(currentDisk)
1125: EBCF 4F                     LD     C,A
1126: EBD0 CD CB F3               CALL   ShiftRightHLbyC      ; see if we already have drive logged in
1127: EBD3 E5                     PUSH   HL                   ; save result
1128: EBD4 EB                     EX     DE,HL                ; send to seldsk
1129: EBD5 CD ED EB               CALL   SelectDisk
1130: EBD8 E1                     POP    HL                   ; get back logged disk vector
1131: EBD9 CC A3 F4               CALL   Z,errSelect
1132: EBDC 7D                     LD     A,L                  ; get logged disks
1133: EBDD 1F                     RRA
1134: EBDE D8                     RET    C                    ; exit if the disk already logged in
1135: EBDF
1136: EBDF 2A 3C F5               LD     HL,(loggedDisks)     ; else log in a differenet disk
1137: EBE2 4D                     LD     C,L
1138: EBE3 44                     LD     B,H                  ; BC has logged disk
1139: EBE4 CD 35 EC               CALL   SetCurrentDiskBit
1140: EBE7 22 3C F5               LD     (loggedDisks),HL     ; save result
1141: EBEA C3 5F EC               JP     InitDisk
1142: EBED         ;*****************************************************************
1143: EBED         ; select the disk drive given by currentDisk, and fill the base addresses
1144: EBED         ; caTrack - caAllocVector, then fill the values of the disk parameter block
1145: EBED             SelectDisk:
1146: EBED 3A 38 F5               LD     A,(currentDisk)
1147: EBF0 4F                     LD     C,A                  ; prepare for Bios Call
1148: EBF1 CD 1B F6               CALL   bcSeldsk
1149: EBF4 7C                     LD     A,H                  ; HL = 0000 if error, otherwise disk headers
1150: EBF5 B5                     OR     L
1151: EBF6 C8                     RET    Z                    ; exit if error, with Zflag set
1152: EBF7 5E                     LD     E,(HL)
1153: EBF8 23                     INC    HL
1154: EBF9 56                     LD     D,(HL)               ; Disk Header Block pointer in DE
1155: EBFA 23                     INC    HL
1156: EBFB 22 40 F5               LD     (caDirMaxValue),HL
1157: EBFE 23                     INC    HL
1158: EBFF 23                     INC    HL
1159: EC00 22 42 F5               LD     (caTrack),HL
1160: EC03 23                     INC    HL
1161: EC04 23                     INC    HL
1162: EC05 22 44 F5               LD     (caSector),HL
1163: EC08 23                     INC    HL
1164: EC09 23                     INC    HL
1165: EC0A EB                     EX     DE,HL                ; DE points at Directory DMA, HL at Skew Table
1166: EC0B 22 5E F5               LD     (caSkewTable),HL
1167: EC0E 21 46 F5               LD     HL,caDirectoryDMA
1168: EC11 0E 08                  LD     C,caListSize
1169: EC13 CD DF F3               CALL   Move                 ; finish filling in address list
1170: EC16
1171: EC16 2A 48 F5               LD     HL,(caDiskParamBlock)
1172: EC19 EB                     EX     DE,HL                ; DE is source
1173: EC1A 21 4E F5               LD     HL,dpbStart          ; start of Disk Parameter Block
1174: EC1D 0E 0F                  LD     C,dpbSize
1175: EC1F CD DF F3               CALL   Move                 ; load the table
1176: EC22 2A 53 F5               LD     HL,(dpbDSM)          ; max entry number
1177: EC25 7C                     LD     A,H                  ; if 00 then < 255
1178: EC26 21 68 F5               LD     HL,single            ; point at the single byte entry flag
1179: EC29 36 FF                  LD     (HL),TRUE            ; assume its less than 255
1180: EC2B B7                     OR     A                    ; assumtion confirmed ?
1181: EC2C CA 31 EC               JP     Z,SelectDisk1        ; skip if yes
1182: EC2F 36 00                  LD     (HL),FALSE           ; correct assumption, set falg to false
1183: EC31
1184: EC31             SelectDisk1:
1185: EC31 3E FF                  LD     A,TRUE
1186: EC33 B7                     OR     A                    ; Set Sign, reset Carry and   Zero
1187: EC34 C9                     RET
1188: EC35
1189: EC35         ;---------------
1190: EC35         ; set a "1" value in currentDisk position of BC
1191: EC35         ; return in HL
1192: EC35             SetCurrentDiskBit:
1193: EC35 C5                     PUSH   BC                   ; save input parameter
1194: EC36 3A 38 F5               LD     A,(currentDisk)
1195: EC39 4F                     LD     C,A                  ; ready parameter for shift
1196: EC3A 21 01 00               LD     HL,1                 ; number to shift
1197: EC3D CD D8 F3               CALL   ShiftLeftHLbyC       ; HL = mask to integrate
1198: EC40 C1                     POP    BC                   ; original mask
1199: EC41 79                     LD     A,C
1200: EC42 B5                     OR     L
1201: EC43 6F                     LD     L,A
1202: EC44 78                     LD     A,B
1203: EC45 B4                     OR     H
1204: EC46 67                     LD     H,A                  ; HL = mask or rol(1,currentDisk)
1205: EC47 C9                     RET
1206: EC48         ;--------------
1207: EC48         ;set current disk to read only
1208: EC48             SetDiskReadOnly:
1209: EC48 21 3A F5               LD     HL,ReadOnlyVector
1210: EC4B 4E                     LD     C,(HL)
1211: EC4C 23                     INC    HL
1212: EC4D 46                     LD     B,(HL)
1213: EC4E CD 35 EC               CALL   SetCurrentDiskBit    ; sets bit to 1
1214: EC51 22 3A F5               LD     (ReadOnlyVector),HL
1215: EC54         ; high water mark in directory goes to max
1216: EC54 2A 55 F5               LD     HL,(dpbDRM)          ; directory max
1217: EC57 EB                     EX     DE,HL                ; DE = directory max
1218: EC58 2A 40 F5               LD     HL,(caDirMaxValue)   ; HL = .Directory max value
1219: EC5B 73                     LD     (HL),E
1220: EC5C 23                     INC    HL
1221: EC5D 72                     LD     (HL),D               ; cdrmax = dpbDRM
1222: EC5E C9                     RET
1223: EC5F         ;----------------------- initialize the current disk
1224: EC5F         ;
1225: EC5F         ;lowReturnStatus = false ;set to true if $ file exists
1226: EC5F         ; compute the length of the allocation vector - 2
1227: EC5F
1228: EC5F             InitDisk:
1229: EC5F 2A 53 F5               LD     HL,(dpbDSM)          ; get max allocation value
1230: EC62 0E 03                  LD     C,3                  ; we want dpbDSM/8
1231: EC64         ; number of bytes in alloc vector is (dpbDSM/8)+1
1232: EC64 CD CB F3               CALL   ShiftRightHLbyC
1233: EC67 23                     INC    HL                   ; HL = dpbDSM/8+1
1234: EC68 44                     LD     B,H
1235: EC69 4D                     LD     C,L                  ; BC has size of AllocationVector
1236: EC6A 2A 4C F5               LD     HL,(caAllocVector)   ; base of allocation vector
1237: EC6D         ;fill the allocation vector with zeros
1238: EC6D             InitDisk0:
1239: EC6D 36 00                  LD     (HL),0
1240: EC6F 23                     INC    HL                   ; alloc(i)=0
1241: EC70 0B                     DEC    BC                   ; count length down
1242: EC71 78                     LD     A,B
1243: EC72 B1                     OR     C
1244: EC73 C2 6D EC               JP     NZ,InitDisk0
1245: EC76         ; set the reserved space for the directory
1246: EC76 2A 57 F5               LD     HL,(dpbDABM)         ; get the directory block reserved bits
1247: EC79 EB                     EX     DE,HL
1248: EC7A 2A 4C F5               LD     HL,(caAllocVector)   ; HL=.alloc()
1249: EC7D 73                     LD     (HL),E
1250: EC7E 23                     INC    HL
1251: EC7F 72                     LD     (HL),D               ; sets reserved directory blks
1252: EC80         ; allocation vector initialized, home disk
1253: EC80 CD 24 ED               CALL   Home
1254: EC83         ; caDirMaxValue = 3 (scans at least one directory record)
1255: EC83 2A 40 F5               LD     HL,(caDirMaxValue)
1256: EC86 36 03                  LD     (HL),3
1257: EC88 23                     INC    HL
1258: EC89 36 00                  LD     (HL),0               ; caDirMaxValue = 0003
1259: EC8B
1260: EC8B CD 3E ED               CALL   SetEndDirectory      ; dirEntryIndex = EOD
1261: EC8E         ; read directory entries and check for allocated storage
1262: EC8E             InitDisk1:
1263: EC8E 0E FF                  LD     C,TRUE
1264: EC90 CD 66 ED               CALL   ReadDirectory
1265: EC93 CD 54 ED               CALL   EndOfDirectory
1266: EC96 C8                     RET    Z                    ; return if end of directory
1267: EC97         ; not end of directory, valid entry?
1268: EC97 CD 40 EE               CALL   GetDirElementAddress ; HL = caDirectoryDMA + dirBlockIndex
1269: EC9A 3E E5                  LD     A,emptyDir
1270: EC9C BE                     CP     M
1271: EC9D CA 8E EC               JP     Z,InitDisk1          ; go get another item
1272: ECA0         ; not emptyDir, user code the same?
1273: ECA0 3A 33 F5               LD     A,(currentUserNumber)
1274: ECA3 BE                     CP     M
1275: ECA4 C2 B2 EC               JP     NZ,InitDisk2
1276: ECA7         ; same user code, check for '$' submit
1277: ECA7 23                     INC    HL
1278: ECA8 7E                     LD     A,(HL)               ; first character
1279: ECA9 D6 24                  SUB    DOLLAR               ; dollar file?
1280: ECAB C2 B2 EC               JP     NZ,InitDisk2
1281: ECAE         ; dollar file found, mark in lowReturnStatus
1282: ECAE 3D                     DEC    A
1283: ECAF 32 36 F5               LD     (lowReturnStatus),A  ; lowReturnStatus = 255
1284: ECB2             InitDisk2:
1285: ECB2         ; now scan the disk map for allocated blocks
1286: ECB2 0E 01                  LD     C,1                  ; set to allocated
1287: ECB4 CD BD EC               CALL   ScanDiskMap
1288: ECB7 CD 49 EE               CALL   SetDirectoryEntry    ; set DirMaxVAlue to dirEntryIndex
1289: ECBA C3 8E EC               JP     InitDisk1            ; for another entry
1290: ECBD         ;
1291: ECBD         ;-------------Scan the disk map for unallocated entry-----------------------------------
1292: ECBD         ; scan the disk map addressed by dptr for non-zero entries.  The allocation
1293: ECBD         ; vector entry corresponding to a non-zero entry is set to the value of C (0,1)
1294: ECBD             ScanDiskMap:
1295: ECBD CD 40 EE               CALL   GetDirElementAddress ; HL = buffa + dptr
1296: ECC0         ; HL addresses the beginning of the directory entry
1297: ECC0 11 10 00               LD     DE,fcbDiskMapIndex
1298: ECC3 19                     ADD    HL,DE                ; hl now addresses the disk map
1299: ECC4 C5                     PUSH   BC                   ; save the set/reset bit
1300: ECC5 0E 11                  LD     C,fcbLength-fcbDiskMapIndex+1 ; size of Disk Allocation Map + 1
1301: ECC7
1302: ECC7             ScanDiskMap0:                      ; loop once for each disk map entry
1303: ECC7 D1                     POP    DE                   ; recall the set/reset bit
1304: ECC8 0D                     DEC    C
1305: ECC9 C8                     RET    Z
1306: ECCA
1307: ECCA D5                     PUSH   DE                   ; save the set/reset bit
1308: ECCB 3A 68 F5               LD     A,(single)           ; single byte entry flag
1309: ECCE B7                     OR     A
1310: ECCF CA DA EC               JP     Z,ScanDiskMap1       ; skip if two byte value
1311: ECD2         ; single byte scan operation
1312: ECD2 C5                     PUSH   BC                   ; save counter
1313: ECD3 E5                     PUSH   HL                   ; save map address
1314: ECD4 4E                     LD     C,(HL)
1315: ECD5 06 00                  LD     B,0                  ; BC=block#
1316: ECD7 C3 E0 EC               JP     ScanDiskMap2
1317: ECDA         ; two byte scan operation
1318: ECDA             ScanDiskMap1:
1319: ECDA 0D                     DEC    C                    ; adjust counter for double byte
1320: ECDB C5                     PUSH   BC                   ; save counter
1321: ECDC         ;	MOV		C,M
1322: ECDC 46                     LD     B,(HL)
1323: ECDD 23                     INC    HL
1324: ECDE         ;	MOV		B,M								; BC=block#
1325: ECDE 4E                     LD     C,(HL)               ; BC=block#
1326: ECDF E5                     PUSH   HL                   ; save map address
1327: ECE0             ScanDiskMap2:                      ; arrive here with BC=block#, E=0/1
1328: ECE0 79                     LD     A,C
1329: ECE1 B0                     OR     B                    ; skip if = 0000
1330: ECE2 C4 12 ED               CALL   NZ,SetAllocBit       ; bit set to 0/1 its in C
1331: ECE5 E1                     POP    HL
1332: ECE6 23                     INC    HL                   ; to next bit position
1333: ECE7 C1                     POP    BC                   ; recall counter
1334: ECE8 C3 C7 EC               JP     ScanDiskMap0         ; for another item
1335: ECEB         ;
1336: ECEB         ;-----------------------------------
1337: ECEB         ;given allocation vector position BC, return with byte
1338: ECEB         ;containing BC shifted so that the least significant
1339: ECEB         ;bit is in the low order accumulator position.  HL is
1340: ECEB         ;the address of the byte for possible replacement in
1341: ECEB         ;memory upon return, and D contains the number of shifts
1342: ECEB         ;required to place the returned value back into position
1343: ECEB
1344: ECEB             GetAllocBit:                      ; getallocbit
1345: ECEB 79                     LD     A,C
1346: ECEC E6 07                  AND    111b
1347: ECEE 3C                     INC    A
1348: ECEF 5F                     LD     E,A
1349: ECF0 57                     LD     D,A
1350: ECF1         ; d and e both contain the number of bit positions to shift
1351: ECF1 79                     LD     A,C
1352: ECF2 0F                     RRCA
1353: ECF3 0F                     RRCA
1354: ECF4 0F                     RRCA
1355: ECF5 E6 1F                  AND    11111b
1356: ECF7 4F                     LD     C,A                  ; C shr 3 to C
1357: ECF8 78                     LD     A,B
1358: ECF9 87                     ADD    A,A
1359: ECFA 87                     ADD    A,A
1360: ECFB 87                     ADD    A,A
1361: ECFC 87                     ADD    A,A
1362: ECFD 87                     ADD    A,A                  ; B shl 5
1363: ECFE B1                     OR     C
1364: ECFF 4F                     LD     C,A                  ; bbbccccc to C
1365: ED00 78                     LD     A,B
1366: ED01 0F                     RRCA
1367: ED02 0F                     RRCA
1368: ED03 0F                     RRCA
1369: ED04 E6 1F                  AND    11111b
1370: ED06 47                     LD     B,A                  ; BC shr 3 to BC
1371: ED07 2A 4C F5               LD     HL,(caAllocVector)   ; base address of allocation vector
1372: ED0A 09                     ADD    HL,BC
1373: ED0B 7E                     LD     A,(HL)               ; byte to A, hl = .alloc(BC shr 3)
1374: ED0C         ;now move the bit to the low order position of A
1375: ED0C             GetAllocBitl:
1376: ED0C 07                     RLCA
1377: ED0D 1D                     DEC    E
1378: ED0E C2 0C ED               JP     NZ,GetAllocBitl
1379: ED11 C9                     RET
1380: ED12
1381: ED12         ;-----------------------------------
1382: ED12         ; BC is the bit position of ALLOC to set or reset.  The
1383: ED12         ; value of the bit is in register E.
1384: ED12             SetAllocBit:
1385: ED12 D5                     PUSH   DE
1386: ED13 CD EB EC               CALL   GetAllocBit          ; shifted val A, count in D
1387: ED16 E6 FE                  AND    11111110b            ; mask low bit to zero (may be set)
1388: ED18 C1                     POP    BC
1389: ED19 B1                     OR     C                    ; low bit of C is masked into A
1390: ED1A C3 1D ED               JP     RotateAndReplace     ; to rotate back into proper position
1391: ED1D         ;ret
1392: ED1D         ;-----------------------------------
1393: ED1D         ; byte value from ALLOC is in register A, with shift count
1394: ED1D         ; in register C (to place bit back into position), and
1395: ED1D         ; target ALLOC position in registers HL, rotate and replace
1396: ED1D             RotateAndReplace:
1397: ED1D 0F                     RRCA
1398: ED1E 15                     DEC    D
1399: ED1F C2 1D ED               JP     NZ,RotateAndReplace  ; back into position
1400: ED22 77                     LD     (HL),A               ; back to ALLOC
1401: ED23 C9                     RET
1402: ED24         ;-----------------------------------
1403: ED24
1404: ED24         ;move to home position, then offset to start of dir
1405: ED24             Home:
1406: ED24 CD 18 F6               CALL   bcHome               ; move to track 00, sector 00 reference
1407: ED27 21 5B F5               LD     HL,dpbOFF            ; get track ofset at begining
1408: ED2A 4E                     LD     C,(HL)
1409: ED2B 23                     INC    HL
1410: ED2C 46                     LD     B,(HL)
1411: ED2D CD 1E F6               CALL   bcSettrk             ; select first directory position
1412: ED30
1413: ED30 AF                     XOR    A                    ; constant zero to accumulator
1414: ED31 2A 42 F5               LD     HL,(caTrack)
1415: ED34 77                     LD     (HL),A
1416: ED35 23                     INC    HL
1417: ED36 77                     LD     (HL),A               ; curtrk=0000
1418: ED37 2A 44 F5               LD     HL,(caSector)
1419: ED3A 77                     LD     (HL),A
1420: ED3B 23                     INC    HL
1421: ED3C 77                     LD     (HL),A               ; currec=0000
1422: ED3D C9                     RET
1423: ED3E
1424: ED3E
1425: ED3E         ;*****************************************************************
1426: ED3E
1427: ED3E         ;*****************************************************************
1428: ED3E         ;*****************************************************************
1429: ED3E         ; set directory counter to end  -1
1430: ED3E             SetEndDirectory:
1431: ED3E 21 FF FF               LD     HL,EOD
1432: ED41 22 73 F5               LD     (dirEntryIndex),HL
1433: ED44 C9                     RET
1434: ED45         ;---------------
1435: ED45             SetDataDMA:                      ; setdata
1436: ED45 21 3E F5               LD     HL,InitDAMAddress
1437: ED48 C3 4E ED               JP     SetDMA               ; to complete the call
1438: ED4B         ;---------------
1439: ED4B             SetDirDMA:                      ; setdir
1440: ED4B 21 46 F5               LD     HL,caDirectoryDMA
1441: ED4E
1442: ED4E             SetDMA:                         ; setdma
1443: ED4E 4E                     LD     C,(HL)
1444: ED4F 23                     INC    HL
1445: ED50 46                     LD     B,(HL)               ; parameter ready
1446: ED51 C3 24 F6               JP     bcSetdma             ; call bios to set
1447: ED54         ;---------------
1448: ED54         ;---------------
1449: ED54         ; return zero flag if at end of directory
1450: ED54         ; non zero if not at end (end of dir if dirEntryIndex = 0ffffh)
1451: ED54             EndOfDirectory:
1452: ED54 21 73 F5               LD     HL,dirEntryIndex
1453: ED57 7E                     LD     A,(HL)               ; may be 0ffh
1454: ED58 23                     INC    HL
1455: ED59 BE                     CP     M                    ; low(dirEntryIndex) = high(dirEntryIndex)?
1456: ED5A C0                     RET    NZ                   ; non zero returned if different
1457: ED5B         ; high and low the same, = 0ffh?
1458: ED5B 3C                     INC    A                    ; 0ffh becomes 00 if so
1459: ED5C C9                     RET
1460: ED5D         ;---------------
1461: ED5D         ; read a directory entry into the directory buffer
1462: ED5D             ReadDirRecord:
1463: ED5D CD 4B ED               CALL   SetDirDMA            ; directory dma
1464: ED60 CD AE F1               CALL   ReadBuffer           ; directory record loaded
1465: ED63 C3 45 ED               JP     SetDataDMA           ; to data dma address
1466: ED66         ;ret
1467: ED66         ;---------------
1468: ED66         ; read next directory entry, with C=true if initializing
1469: ED66             ReadDirectory:
1470: ED66 2A 55 F5               LD     HL,(dpbDRM)
1471: ED69 EB                     EX     DE,HL                ; determine number of directory entries
1472: ED6A 2A 73 F5               LD     HL,(dirEntryIndex)   ; index into directory
1473: ED6D 23                     INC    HL
1474: ED6E 22 73 F5               LD     (dirEntryIndex),HL   ; initialize directory index
1475: ED71         ; continue while dpbDRM >= dirEntryIndex (dpbDRM-dirEntryIndex no cy)
1476: ED71 CD C4 F3               CALL   DEminusHL2HL         ; DE-HL - processed all entries ?
1477: ED74 D2 7B ED               JP     NC,ReadDirectory0    ; no - do it again
1478: ED77         ; yes, set dirEntryIndex to end of directory
1479: ED77 CD 3E ED               CALL   SetEndDirectory
1480: ED7A C9                     RET
1481: ED7B
1482: ED7B         ; not at end of directory, seek next element, initialization flag is in C
1483: ED7B             ReadDirectory0:
1484: ED7B 3A 73 F5               LD     A,(dirEntryIndex)
1485: ED7E E6 03                  AND    dirEntryMask         ; low(dirEntryIndex) and dirEntryMask
1486: ED80 06 05                  LD     B,fcbShift           ; to multiply by fcb size to get the correct index in dir record
1487: ED82             ReadDirectory1:
1488: ED82 87                     ADD    A,A
1489: ED83 05                     DEC    B
1490: ED84 C2 82 ED               JP     NZ,ReadDirectory1
1491: ED87         ; A = (low(dirEntryIndex) and dirEntryMask) shl fcbShift
1492: ED87 32 72 F5               LD     (dirBlockIndex),A    ; ready for next dir operation
1493: ED8A B7                     OR     A
1494: ED8B C0                     RET    NZ                   ; return if not a new record (Directory Block)
1495: ED8C C5                     PUSH   BC                   ; save initialization flag C
1496: ED8D CD 97 ED               CALL   SeekDir              ; seek$dir seek proper record
1497: ED90 CD 5D ED               CALL   ReadDirRecord        ; read the directory record
1498: ED93 C1                     POP    BC                   ; recall initialization flag
1499: ED94 C3 0B EE               JP     CalculateCheckSum    ; checksum the directory elt
1500: ED97         ;---------
1501: ED97         ;seek the record containing the current dir entry
1502: ED97             SeekDir:
1503: ED97 2A 73 F5               LD     HL,(dirEntryIndex)   ; directory counter to HL
1504: ED9A 0E 02                  LD     C,dirEntryShift      ; 4 entries per record
1505: ED9C CD CB F3               CALL   ShiftRightHLbyC      ; value to HL
1506: ED9F 22 70 F5               LD     (currentBlock),HL
1507: EDA2 22 75 F5               LD     (dirRecord),HL       ; ready for seek
1508: EDA5 C3 A8 ED               JP     Seek
1509: EDA8         ;---------------------------
1510: EDA8             Seek:                           ; seek
1511: EDA8         ;seek the track given by currentBlock (actual record number)
1512: EDA8
1513: EDA8 21 70 F5               LD     HL,currentBlock      ; contains the cpm record number
1514: EDAB 4E                     LD     C,(HL)               ; Actual Record Number Low
1515: EDAC 23                     INC    HL
1516: EDAD 46                     LD     B,(HL)               ; Actual Record Number High
1517: EDAE 2A 44 F5               LD     HL,(caSector)        ; Current Sector
1518: EDB1 5E                     LD     E,(HL)               ; Current Sector Number Low
1519: EDB2 23                     INC    HL
1520: EDB3 56                     LD     D,(HL)               ; Current Sector Number High
1521: EDB4 2A 42 F5               LD     HL,(caTrack)         ; Current track
1522: EDB7 7E                     LD     A,(HL)               ; Current track Number Low - temp
1523: EDB8 23                     INC    HL
1524: EDB9 66                     LD     H,(HL)               ; Current track Number High
1525: EDBA 6F                     LD     L,A                  ; Current track Number Low
1526: EDBB         ;(BC) - cpmRecord Number
1527: EDBB         ;(DE) - Current Sector
1528: EDBB         ;(HL) - Current Track
1529: EDBB
1530: EDBB         ;loop while currentBlock < currec   ?????
1531: EDBB             Seek0:
1532: EDBB 79                     LD     A,C                  ;   Current Sector
1533: EDBC 93                     SUB    E                    ;
1534: EDBD 78                     LD     A,B                  ; - cpmRecord Number
1535: EDBE 9A                     SBC    A,D                  ;
1536: EDBF D2 D1 ED               JP     NC,Seek1             ; skip if cpmRecord Number >= Current Sector
1537: EDC2
1538: EDC2 E5                     PUSH   HL
1539: EDC3 2A 4E F5               LD     HL,(dpbSPT)
1540: EDC6 7B                     LD     A,E
1541: EDC7 95                     SUB    L
1542: EDC8 5F                     LD     E,A
1543: EDC9 7A                     LD     A,D
1544: EDCA 9C                     SBC    A,H
1545: EDCB 57                     LD     D,A
1546: EDCC E1                     POP    HL
1547: EDCD 2B                     DEC    HL
1548: EDCE C3 BB ED               JP     Seek0
1549: EDD1
1550: EDD1             Seek1:
1551: EDD1
1552: EDD1 E5                     PUSH   HL                   ; Save Current Track
1553: EDD2 2A 4E F5               LD     HL,(dpbSPT)          ; records per track
1554: EDD5 19                     ADD    HL,DE                ; HL = Current Sector + sectorsPerClynder
1555: EDD6 79                     LD     A,C                  ;     cpmRecord Number
1556: EDD7 95                     SUB    L                    ;
1557: EDD8 78                     LD     A,B                  ;  - HL (above)
1558: EDD9 9C                     SBC    A,H                  ;
1559: EDDA DA E3 ED               JP     C,Seek2              ; skip if cpmRecord Number > HL (above)
1560: EDDD
1561: EDDD EB                     EX     DE,HL
1562: EDDE
1563: EDDE E1                     POP    HL
1564: EDDF 23                     INC    HL
1565: EDE0 C3 D1 ED               JP     Seek1
1566: EDE3
1567: EDE3             Seek2:
1568: EDE3 E1                     POP    HL                   ; retreive Current Track
1569: EDE4 C5                     PUSH   BC                   ; save  cpmRecord Number
1570: EDE5 D5                     PUSH   DE                   ; save  Current Sector
1571: EDE6 E5                     PUSH   HL                   ; save CurrentTrack
1572: EDE7         ; stack contains CurrentTrack , Current Sector, cpmRecord Number
1573: EDE7 EB                     EX     DE,HL                ; DE => CurrentTrack, HL => Current Sector
1574: EDE8 2A 5B F5               LD     HL,(dpbOFF)          ; Block Zero starting Track
1575: EDEB 19                     ADD    HL,DE                ; HL =  actual physical Track number
1576: EDEC 44                     LD     B,H
1577: EDED 4D                     LD     C,L                  ; BC has physical Track number
1578: EDEE CD 1E F6               CALL   bcSettrk             ; track set up
1579: EDF1         ; note that BC - curtrk is difference to move in bios
1580: EDF1 D1                     POP    DE                   ; recall CurrentTrack
1581: EDF2 2A 42 F5               LD     HL,(caTrack)         ; point at current Track
1582: EDF5 73                     LD     (HL),E
1583: EDF6 23                     INC    HL
1584: EDF7 72                     LD     (HL),D               ; current Track updated
1585: EDF8         ; now compute sector as currentBlock-currec
1586: EDF8 D1                     POP    DE                   ; recall Current Sector
1587: EDF9 2A 44 F5               LD     HL,(caSector)        ; point at current Sector
1588: EDFC 73                     LD     (HL),E
1589: EDFD 23                     INC    HL
1590: EDFE 72                     LD     (HL),D               ; current sector updated / DE has currentSector
1591: EDFF C1                     POP    BC                   ; recall cpmRecord Number
1592: EE00 79                     LD     A,C                  ; cpmRecord Number
1593: EE01 93                     SUB    E
1594: EE02 4F                     LD     C,A                  ; - currentSector
1595: EE03 78                     LD     A,B
1596: EE04 9A                     SBC    A,D
1597: EE05 47                     LD     B,A                  ; back into BC
1598: EE06 C3 21 F6               JP     bcSetsec             ; sector selected
1599: EE09         ;ret
1600: EE09         ;************* CheckSum *******************************
1601: EE09         ; compute current checksum record
1602: EE09         ; if C = TRUE , update the allocation vector
1603: EE09         ;
1604: EE09         ; or check for = if not dirRecord < dpbCKS ????
1605: EE09
1606: EE09             NewCheckSum:
1607: EE09 0E FF                  LD     C,TRUE
1608: EE0B
1609: EE0B             CalculateCheckSum:
1610: EE0B 2A 75 F5               LD     HL,(dirRecord)
1611: EE0E EB                     EX     DE,HL
1612: EE0F 2A 59 F5               LD     HL,(dpbCKS)          ; size of checksum vector
1613: EE12 CD C4 F3               CALL   DEminusHL2HL         ; DE-HL
1614: EE15 D0                     RET    NC                   ; skip checksum if past checksum vector size
1615: EE16 C5                     PUSH   BC                   ; save init flag
1616: EE17 CD 33 EE               CALL   ComputeCheckSum      ; check sum value to A
1617: EE1A 2A 4A F5               LD     HL,(caCheckSum)      ; address of check sum vector
1618: EE1D EB                     EX     DE,HL
1619: EE1E 2A 75 F5               LD     HL,(dirRecord)       ; value of dirRecord
1620: EE21 19                     ADD    HL,DE                ; HL = .check(dirRecord)
1621: EE22 C1                     POP    BC                   ; recall true=0ffh or false=00 to C
1622: EE23 0C                     INC    C                    ; 0ffh produces zero flag
1623: EE24 CA 31 EE               JP     Z,SetNewCheckSum
1624: EE27         ; not initializing, compare
1625: EE27 BE                     CP     M                    ; compute$cs=check(dirRecord)?
1626: EE28 C8                     RET    Z                    ; no message if ok
1627: EE29         ; possible checksum error, are we beyond the end of the disk?
1628: EE29 CD 52 EE               CALL   StillInDirectory
1629: EE2C D0                     RET    NC                   ; no message if so
1630: EE2D CD 48 EC               CALL   SetDiskReadOnly      ; read/only disk set
1631: EE30 C9                     RET
1632: EE31
1633: EE31         ;initializing the checksum
1634: EE31             SetNewCheckSum:
1635: EE31 77                     LD     (HL),A
1636: EE32 C9                     RET
1637: EE33         ;------------------
1638: EE33         ;compute checksum for current directory buffer
1639: EE33             ComputeCheckSum:
1640: EE33 0E 80                  LD     C,cpmRecordSize      ; size of directory buffer
1641: EE35 2A 46 F5               LD     HL,(caDirectoryDMA)  ; current directory buffer
1642: EE38 AF                     XOR    A                    ; clear checksum value
1643: EE39             ComputeCheckSum0:
1644: EE39 86                     ADD    A,(HL)
1645: EE3A 23                     INC    HL
1646: EE3B 0D                     DEC    C                    ; cs=cs+buff(cpmRecordSize-C)
1647: EE3C C2 39 EE               JP     NZ,ComputeCheckSum0
1648: EE3F C9                     RET                         ; with checksum in A
1649: EE40         ;*****************************************************************
1650: EE40         ; compute the address of a directory element at positon dirBlockIndex in the buffer
1651: EE40             GetDirElementAddress:
1652: EE40 2A 46 F5               LD     HL,(caDirectoryDMA)
1653: EE43 3A 72 F5               LD     A,(dirBlockIndex)
1654: EE46 C3 BF F3               JP     AddAtoHL
1655: EE49         ;---------------------
1656: EE49         ;if not still in directory set max value
1657: EE49             SetDirectoryEntry:
1658: EE49 CD 52 EE               CALL   StillInDirectory
1659: EE4C D8                     RET    C
1660: EE4D         ; return if yes,otherwise, HL = DirMaxValue+1, DE = directoryCount
1661: EE4D
1662: EE4D 13                     INC    DE
1663: EE4E 72                     LD     (HL),D
1664: EE4F 2B                     DEC    HL
1665: EE50 73                     LD     (HL),E
1666: EE51 C9                     RET
1667: EE52         ; return CY if entry is still in Directory
1668: EE52             StillInDirectory:
1669: EE52 2A 73 F5               LD     HL,(dirEntryIndex)
1670: EE55 EB                     EX     DE,HL                ; DE = directory counter
1671: EE56 2A 40 F5               LD     HL,(caDirMaxValue)   ; HL=caDirMaxValue
1672: EE59 7B                     LD     A,E
1673: EE5A 96                     SUB    M                    ; low(dirEntryIndex) - low(cdrmax)
1674: EE5B 23                     INC    HL                   ; HL = .cdrmax+1
1675: EE5C 7A                     LD     A,D
1676: EE5D 9E                     SBC    A,(HL)               ; hi(dirEntryIndex) - hig(cdrmax)
1677: EE5E         ;condition dirEntryIndex - cdrmax  produces cy if cdrmax>dirEntryIndex
1678: EE5E C9                     RET
1679: EE5F         ;---------------------
1680: EE5F         ;compute fcbRCIndex and NEXT_RECORD addresses for get/setfcb
1681: EE5F         ; returns with DE pointing at RC from FCB
1682: EE5F         ;         with HL pointing at Next Record
1683: EE5F             GetFcbAddress:                      ; getfcba
1684: EE5F 2A 34 F5               LD     HL,(paramDE)
1685: EE62 11 0F 00               LD     DE,fcbRCIndex
1686: EE65 19                     ADD    HL,DE
1687: EE66 EB                     EX     DE,HL                ; DE=.fcb(fcbRCIndex)
1688: EE67 21 11 00               LD     HL,NEXT_RECORD-fcbRCIndex ;RATS
1689: EE6A 19                     ADD    HL,DE                ; HL=.fcb(NEXT_RECORD)
1690: EE6B C9                     RET
1691: EE6C         ;---------------------
1692: EE6C         ;set variables from currently fcb - NEXT_RECORD, RC, EXM
1693: EE6C             SetRecordVars:
1694: EE6C CD 5F EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
1695: EE6F 7E                     LD     A,(HL)
1696: EE70 32 6E F5               LD     (cpmRecord),A        ; cpmRecord=fcb(NEXT_RECORD)
1697: EE73 EB                     EX     DE,HL
1698: EE74 7E                     LD     A,(HL)
1699: EE75 32 6C F5               LD     (fcbRecordCount),A   ; fcbRecordCount=fcb(fcbRCIndex)
1700: EE78 CD 38 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
1701: EE7B 3A 52 F5               LD     A,(dpbEXM)           ; extent mask to a
1702: EE7E A6                     AND    M                    ; fcb(fcbExtIndex) and dpbEXM
1703: EE7F 32 6D F5               LD     (extentValue),A      ; save extent number
1704: EE82 C9                     RET
1705: EE83         ;---------------------
1706: EE83         ;update variables from I/O in  fcb
1707: EE83             UpdateRecordVars:
1708: EE83 CD 5F EE               CALL   GetFcbAddress        ; DE => fcbRCIndex(RC) , HL => NEXT_RECORD
1709: EE86 3A 63 F5               LD     A,(seqReadFlag)
1710: EE89 4F                     LD     C,A                  ; =1 if sequential i/o
1711: EE8A 3A 6E F5               LD     A,(cpmRecord)        ; get NEXT_RECORD
1712: EE8D 81                     ADD    A,C
1713: EE8E 77                     LD     (HL),A               ; fcb(NEXT_RECORD)=cpmRecord+seqReadFlag
1714: EE8F EB                     EX     DE,HL
1715: EE90 3A 6C F5               LD     A,(fcbRecordCount)
1716: EE93 77                     LD     (HL),A               ; fcb(fcbRCIndex)=fcbRecordCount
1717: EE94 C9                     RET
1718: EE95         ;---------------------
1719: EE95         ;set file Attributes for current fcb
1720: EE95             SetAttributes:
1721: EE95 0E 0C                  LD     C,fcbExtIndex
1722: EE97 CD B0 F2               CALL   Search4DirElement    ; through file type
1723: EE9A             SetAttributes1:
1724: EE9A CD 54 ED               CALL   EndOfDirectory
1725: EE9D C8                     RET    Z                    ; exit at end of dir
1726: EE9E 0E 00                  LD     C,0
1727: EEA0 1E 0C                  LD     E,fcbExtIndex        ;copy name
1728: EEA2 CD 71 F3               CALL   CopyDir
1729: EEA5 CD C8 F2               CALL   Search4NextDirElement
1730: EEA8 C3 9A EE               JP     SetAttributes1
1731: EEAB         ;
1732: EEAB         ;*****************************************************************
1733: EEAB
1734: EEAB         ;*****************************************************************
1735: EEAB         ;********************** File  Routines ***************************
1736: EEAB         ;*****************************************************************
1737: EEAB         ;open file
1738: EEAB         ; IN  - (DE)	FCB Address
1739: EEAB         ; OUT - (A)	Directory Code
1740: EEAB         ;	0-3 = success ; 0FFH = File Not Found
1741: EEAB             vOpenFile:                      ;
1742: EEAB CD 31 F2               CALL   ClearModuleNum       ; clear the module number
1743: EEAE CD 40 F2               CALL   Reselect             ; do we need to reselect disk?
1744: EEB1 C3 6D F2               JP     OpenFile
1745: EEB4         ;ret ;jmp goback
1746: EEB4         ;-----------------------------------------------------------------
1747: EEB4         ;close file
1748: EEB4             vCloseFile:                      ; func16: (16 - 10) Close File
1749: EEB4 CD 40 F2               CALL   Reselect
1750: EEB7 C3 15 F1               JP     CloseDirEntry
1751: EEBA         ;-----------------------------------------------------------------
1752: EEBA         ;search for first occurrence of a file
1753: EEBA         ; In - (DE)	FCB Address
1754: EEBA         ; OUT - (A)	Directory Code
1755: EEBA         ;	0-3 = success ; 0FFH = File Not Found
1756: EEBA             vFindFirst:                      ; func17: (17 - 11) Search for first
1757: EEBA 0E 00                  LD     C,0                  ; length assuming '?' true
1758: EEBC 2A 34 F5               LD     HL,(paramDE)
1759: EEBF 7E                     LD     A,(HL)
1760: EEC0 FE 3F                  CP     QMARK                ; no reselect if ?
1761: EEC2 CA CD EE               JP     Z,QMarkSelect        ; skip reselect if so
1762: EEC5
1763: EEC5 CD 31 F2               CALL   ClearModuleNum       ; module number zeroed
1764: EEC8 CD 40 F2               CALL   Reselect
1765: EECB 0E 0F                  LD     C,nameLength
1766: EECD             QMarkSelect:                      ; qselect:
1767: EECD CD B0 F2               CALL   Search4DirElement
1768: EED0 C3 5E F3               JP     CopyDirEntryToUser   ; copy directory entry to user
1769: EED3         ;-----------------------------------------------------------------
1770: EED3         ;search for next occurrence of a file name
1771: EED3         ; OUT - (A)	Directory Code
1772: EED3         ;	0-3 = success ; 0FFH = File Not Found
1773: EED3             vFindNext:                      ; func18: (18 - 12) Search for next
1774: EED3 2A 66 F5               LD     HL,(searchAddress)
1775: EED6 22 34 F5               LD     (paramDE),HL
1776: EED9 CD 40 F2               CALL   Reselect
1777: EEDC CD C8 F2               CALL   Search4NextDirElement
1778: EEDF C3 5E F3               JP     CopyDirEntryToUser   ; copy directory entry to user
1779: EEE2         ;-----------------------------------------------------------------
1780: EEE2         ;search for next occurrence of a file name
1781: EEE2         ; OUT - (A)	Directory Code
1782: EEE2         ;delete a file
1783: EEE2             vDeleteFile:                      ; func18: (19 - 13) Delete File
1784: EEE2 CD 40 F2               CALL   Reselect
1785: EEE5 CD F3 F0               CALL   DeleteFile
1786: EEE8 C3 2A F2               JP     DirLocationToReturnLoc
1787: EEEB         ;-----------------------------------------------------------------
1788: EEEB         ;read sequential
1789: EEEB         ;IN  - (DE) FCB address
1790: EEEB         ;OUT - (A) 00 = success and data available. else no read and no data
1791: EEEB             vReadSeq:                       ; func20: (20 - 14) read sequential
1792: EEEB CD 40 F2               CALL   Reselect
1793: EEEE CD 2D EF               CALL   ReadSeq
1794: EEF1 C9                     RET
1795: EEF2         ;-----------------------------------------------------------------
1796: EEF2         ;write sequential
1797: EEF2         ;IN  - (DE) FCB address
1798: EEF2         ;OUT - (A) 00 = success and data available. else no read and no data
1799: EEF2             vWriteSeq:                      ; func21 (21 - 15) write sequention
1800: EEF2 CD 40 F2               CALL   Reselect
1801: EEF5 CD 70 EF               CALL   DiskWriteSeq
1802: EEF8 C9                     RET
1803: EEF9         ;-----------------------------------------------------------------
1804: EEF9         ; Make file
1805: EEF9         ; In - (DE)	FCB Address
1806: EEF9         ; OUT - (A)	Directory Code
1807: EEF9         ;	0-3 = success ; 0FFH = File Not Found
1808: EEF9             vMakeFile:                      ; func22 (22 - 16) Make file
1809: EEF9 CD 31 F2               CALL   ClearModuleNum       ; set S2 to Zero
1810: EEFC CD 40 F2               CALL   Reselect
1811: EEFF C3 BD F0               JP     MakeNewFile
1812: EF02         ;-----------------------------------------------------------------
1813: EF02         ; Rename file
1814: EF02         ; In - (DE)	FCB Address
1815: EF02         ; OUT - (A)	Directory Code
1816: EF02         ;	0-3 = success ; 0FFH = File Not Found
1817: EF02             vRenameFile:                      ; func23 (23 - 17) Rename File
1818: EF02 CD 40 F2               CALL   Reselect
1819: EF05 CD 98 F0               CALL   Rename
1820: EF08 C3 2A F2               JP     DirLocationToReturnLoc
1821: EF0B         ;-----------------------------------------------------------------
1822: EF0B         ;-----------------------------------------------------------------
1823: EF0B         ;*****************************************************************
1824: EF0B         ;-----------------------------------------------------------------
1825: EF0B         ;check current directory element for read/only status
1826: EF0B             CheckRODirectory:
1827: EF0B CD 40 EE               CALL   GetDirElementAddress ; address of element
1828: EF0E         ;	JMP	CheckROFile
1829: EF0E         ;------------
1830: EF0E         ;check current buff(dptr) or fcb(0) for r/o status
1831: EF0E             CheckROFile:
1832: EF0E 11 09 00               LD     DE,fcbROfileIndex
1833: EF11 19                     ADD    HL,DE                ; offset to ro bit
1834: EF12 7E                     LD     A,(HL)
1835: EF13 17                     RLA
1836: EF14 D0                     RET    NC                   ; return if not set
1837: EF15 C3 AF F4               JP     errReadOnlyFile      ; exit to read only disk message
1838: EF18         ;-----------------------------------------------------------------
1839: EF18         ;check for write protected disk
1840: EF18             CheckWrite:
1841: EF18 CD 1F EF               CALL   DoNotWrite
1842: EF1B C8                     RET    Z                    ; ok to write if not rodsk
1843: EF1C C3 A9 F4               JP     errReadOnlyDisk      ; read only disk error
1844: EF1F         ;-----------------------------------------------------------------
1845: EF1F         ;return true if dir checksum difference occurred
1846: EF1F             DoNotWrite:
1847: EF1F 2A 3A F5               LD     HL,(ReadOnlyVector)
1848: EF22 3A 38 F5               LD     A,(currentDisk)
1849: EF25 4F                     LD     C,A
1850: EF26 CD CB F3               CALL   ShiftRightHLbyC
1851: EF29 7D                     LD     A,L
1852: EF2A E6 1B                  AND    1BH                  ; 01BH
1853: EF2C C9                     RET                         ; non zero if nowrite
1854: EF2D         ;-----------------------------------------------------------------
1855: EF2D         ;sequential disk read operation
1856: EF2D             ReadSeq:
1857: EF2D 3E 01                  LD     A,1
1858: EF2F 32 63 F5               LD     (seqReadFlag),A      ; set flag for seqential read
1859: EF32         ;---
1860: EF32         ; read the disk
1861: EF32         ; read the next record from the current fcb
1862: EF32             DiskRead:
1863: EF32 3E FF                  LD     A,TRUE
1864: EF34 32 61 F5               LD     (readModeFlag),A     ; read mode flag = true (OpenNextExt)
1865: EF37
1866: EF37 CD 6C EE               CALL   SetRecordVars        ; sets cpmRecord, fcbRecordCount and EXM
1867: EF3A 3A 6E F5               LD     A,(cpmRecord)
1868: EF3D 21 6C F5               LD     HL,fcbRecordCount
1869: EF40 BE                     CP     M                    ; cpmRecord-fcbRecordCount
1870: EF41         ; skip if  cpmRecord < fcbRecordCount
1871: EF41 DA 57 EF               JP     C,RecordOK
1872: EF44         ; not enough records in the extent
1873: EF44 FE 80                  CP     RecordsPerExtent     ; cpmRecord = 128?   *** Records in an Extent
1874: EF46 C2 6D EF               JP     NZ,DiskEOF           ; skip if cpmRecord<>128
1875: EF49 CD 35 F0               CALL   OpenNextExt          ; go to next extent if so
1876: EF4C AF                     XOR    A
1877: EF4D 32 6E F5               LD     (cpmRecord),A        ; cpmRecord=00
1878: EF50         ; now check for open ok
1879: EF50 3A 36 F5               LD     A,(lowReturnStatus)
1880: EF53 B7                     OR     A
1881: EF54 C2 6D EF               JP     NZ,DiskEOF
1882: EF57         ; stop at eof
1883: EF57         ; arrive with fcb addressing a record to read
1884: EF57             RecordOK:                       ; recordok:
1885: EF57 CD FE F1               CALL   GetBlockNumber       ; save it in currentBlock
1886: EF5A CD 0B F2               CALL   IsAllocated          ; currentBlock=0000?
1887: EF5D CA 6D EF               JP     Z,DiskEOF            ; get out if not allocated already
1888: EF60
1889: EF60 CD 11 F2               CALL   SetActualRecordAdd   ; currentBlock now a record value
1890: EF63 CD A8 ED               CALL   Seek                 ; to proper track,sector
1891: EF66 CD AE F1               CALL   ReadBuffer           ; to dma address
1892: EF69 CD 83 EE               CALL   UpdateRecordVars     ; update variables from I/O in  fcb
1893: EF6C C9                     RET
1894: EF6D             DiskEOF:                        ; diskeof:
1895: EF6D C3 47 F3               JP     SetLowReturnTo1      ; lowReturnStatus = 1
1896: EF70         ;ret
1897: EF70         ;-----------------------------------------------------------------
1898: EF70         ;sequential disk write
1899: EF70             DiskWriteSeq:
1900: EF70 3E 01                  LD     A,1
1901: EF72 32 63 F5               LD     (seqReadFlag),A
1902: EF75         ;--------
1903: EF75         ;disk write
1904: EF75             DiskWrite:
1905: EF75 3E 00                  LD     A,FALSE
1906: EF77 32 61 F5               LD     (readModeFlag),A
1907: EF7A         ; write record to currently selected file
1908: EF7A CD 18 EF               CALL   CheckWrite           ; in case write protected
1909: EF7D 2A 34 F5               LD     HL,(paramDE)         ; HL = .fcb(0)
1910: EF80 CD 0E EF               CALL   CheckROFile          ; may be a read-only file
1911: EF83 CD 6C EE               CALL   SetRecordVars        ; set local Record parameters
1912: EF86 3A 6E F5               LD     A,(cpmRecord)
1913: EF89 FE 80                  CP     highestRecordNumber+1 ; Still in the same extent?
1914: EF8B DA 92 EF               JP     C,DiskWrite1         ; skip if in the same Extent
1915: EF8E CD 47 F3               CALL   SetLowReturnTo1
1916: EF91 C9                     RET                         ; Exit ???????????
1917: EF92
1918: EF92         ; can write the next record, so continue
1919: EF92             DiskWrite1:
1920: EF92 CD FE F1               CALL   GetBlockNumber       ; sets up actual block number
1921: EF95 CD 0B F2               CALL   IsAllocated
1922: EF98 0E 00                  LD     C,WriteAllocated     ; assume a normal write operation for WriteBuffer
1923: EF9A C2 E5 EF               JP     NZ,DiskWrite3
1924: EF9D         ; not allocated -
1925: EF9D         ; the argument to getblock is the starting position for the disk search
1926: EF9D         ; and should be the last allocated block for this file,
1927: EF9D         ; or the value 0 if no space has been allocated
1928: EF9D
1929: EF9D CD 86 F3               CALL   GetDiskMapIndex      ; return with Disk Map index in Acc
1930: EFA0 32 64 F5               LD     (diskMapIndex),A     ; save for later
1931: EFA3 01 00 00               LD     BC,0000h             ; may use block zero
1932: EFA6 B7                     OR     A
1933: EFA7 CA B1 EF               JP     Z,FirstBlock         ; skip if no previous block
1934: EFAA         ; previous block exists
1935: EFAA 4F                     LD     C,A
1936: EFAB 0B                     DEC    BC                   ; previous block # in BC
1937: EFAC CD A6 F3               CALL   GetDiskMapValue      ; previous block # to HL
1938: EFAF 44                     LD     B,H
1939: EFB0 4D                     LD     C,L                  ; BC=prev block#
1940: EFB1         ; BC = 0000, or previous block #
1941: EFB1             FirstBlock:
1942: EFB1 CD C4 F1               CALL   GetClosestBlock      ; block # to HL
1943: EFB4         ; arrive here with block# or zero
1944: EFB4 7D                     LD     A,L
1945: EFB5 B4                     OR     H
1946: EFB6 C2 BF EF               JP     NZ,BlockOK
1947: EFB9         ; cannot find a block to allocate
1948: EFB9 3E 02                  LD     A,2
1949: EFBB 32 36 F5               LD     (lowReturnStatus),A
1950: EFBE C9                     RET                         ; lowReturnStatus=2
1951: EFBF
1952: EFBF             BlockOK:
1953: EFBF 22 70 F5               LD     (currentBlock),HL    ; allocated block number is in HL
1954: EFC2 EB                     EX     DE,HL                ; block number to DE
1955: EFC3 2A 34 F5               LD     HL,(paramDE)
1956: EFC6 01 10 00               LD     BC,fcbDiskMapIndex
1957: EFC9 09                     ADD    HL,BC                ; HL=.fcb(fcbDiskMapIndex)
1958: EFCA 3A 68 F5               LD     A,(single)
1959: EFCD B7                     OR     A                    ; set flags for single byte dm
1960: EFCE 3A 64 F5               LD     A,(diskMapIndex)     ; recall dm index
1961: EFD1 CA DB EF               JP     Z,Allocate16Bit      ; skip if allocating word
1962: EFD4         ; else allocate using a byte value
1963: EFD4 CD BF F3               CALL   AddAtoHL
1964: EFD7 73                     LD     (HL),E               ; single byte alloc
1965: EFD8 C3 E3 EF               JP     DiskWrite2           ; to continue
1966: EFDB
1967: EFDB             Allocate16Bit:                      ; allocate a word value
1968: EFDB
1969: EFDB 4F                     LD     C,A
1970: EFDC 06 00                  LD     B,0                  ; double(diskMapIndex)
1971: EFDE 09                     ADD    HL,BC
1972: EFDF 09                     ADD    HL,BC                ; HL=.fcb(diskMapIndex*2)
1973: EFE0 72                     LD     (HL),D
1974: EFE1 23                     INC    HL
1975: EFE2 73                     LD     (HL),E               ; double wd
1976: EFE3         ; disk write to previously unallocated block
1977: EFE3             DiskWrite2:
1978: EFE3 0E 02                  LD     C,WriteUnallocated   ; marked as unallocated write
1979: EFE5
1980: EFE5         ; continue the write operation of no allocation error
1981: EFE5         ; C = 0 if normal write, 1 if directory write, 2 if to prev unalloc block
1982: EFE5
1983: EFE5             DiskWrite3:
1984: EFE5 3A 36 F5               LD     A,(lowReturnStatus)
1985: EFE8 B7                     OR     A
1986: EFE9 C0                     RET    NZ                   ; stop if non zero returned value
1987: EFEA
1988: EFEA C5                     PUSH   BC                   ; save write flag ( in C see above)
1989: EFEB CD 11 F2               CALL   SetActualRecordAdd   ; currentBlock set to actual record number
1990: EFEE CD A8 ED               CALL   Seek                 ; to proper file position
1991: EFF1 C1                     POP    BC                   ; get write flag
1992: EFF2 C5                     PUSH   BC                   ; restore/save write flag (C=2 if new block)
1993: EFF3 CD A6 F1               CALL   WriteBuffer          ; written to disk
1994: EFF6 C1                     POP    BC                   ; C = 2 if a new block was allocated, 0 if not
1995: EFF7         ; increment record count if fcbRecordCount<=cpmRecord
1996: EFF7 3A 6E F5               LD     A,(cpmRecord)
1997: EFFA 21 6C F5               LD     HL,fcbRecordCount
1998: EFFD BE                     CP     M                    ; cpmRecord-fcbRecordCount
1999: EFFE DA 05 F0               JP     C,DiskWrite4
2000: F001         ; fcbRecordCount <= cpmRecord
2001: F001 77                     LD     (HL),A
2002: F002 34                     INC    M                    ; fcbRecordCount = cpmRecord+1
2003: F003 0E 02                  LD     C,2                  ; mark as record count incremented
2004: F005             DiskWrite4:
2005: F005         ; A has cpmRecord, C=2 if new block or new record#
2006: F005 0D                     DEC    C
2007: F006 0D                     DEC    C
2008: F007 C2 12 F0               JP     NZ,DiskWrite5
2009: F00A F5                     PUSH   AF                   ; save cpmRecord value
2010: F00B CD 37 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2011: F00E         ; reset the file write flag to mark as written fcb
2012: F00E E6 7F                  AND    7FH                  ; not writeFlagMask
2013: F010 77                     LD     (HL),A               ; fcb(fcbS2Index) = fcb(fcbS2Index) and 7fh
2014: F011 F1                     POP    AF                   ; restore cpmRecord
2015: F012             DiskWrite5:
2016: F012         ; check for end of extent, if found attempt to open next extent in preparation for next write
2017: F012 FE 7F                  CP     highestRecordNumber  ; cpmRecord=highestRecordNumber?
2018: F014 C2 32 F0               JP     NZ,DiskWrite7        ; skip if not
2019: F017         ; may be random access write, if so we are done
2020: F017 3A 63 F5               LD     A,(seqReadFlag)
2021: F01A B7                     OR     A
2022: F01B CA 32 F0               JP     Z,DiskWrite7         ; skip next extent open op
2023: F01E         ; update current fcb before going to next extent
2024: F01E CD 83 EE               CALL   UpdateRecordVars     ;update variables from I/O in  fcb
2025: F021 CD 35 F0               CALL   OpenNextExt          ; readModeFlag=false
2026: F024         ; cpmRecord remains at highestRecordNumber causing eof if no more directory space is available
2027: F024 21 36 F5               LD     HL,lowReturnStatus
2028: F027 7E                     LD     A,(HL)
2029: F028 B7                     OR     A
2030: F029 C2 30 F0               JP     NZ,DiskWrite6        ; no space
2031: F02C         ; space available, set cpmRecord=255
2032: F02C 3D                     DEC    A
2033: F02D 32 6E F5               LD     (cpmRecord),A        ; goes to 00 next time
2034: F030             DiskWrite6:
2035: F030 36 00                  LD     (HL),0               ; lowReturnStatus = 00 for returned value
2036: F032             DiskWrite7:
2037: F032 C3 83 EE               JP     UpdateRecordVars     ; update variables from I/O in  fcb
2038: F035         ;ret
2039: F035         ;-----------------------------------------------------------------
2040: F035         ;close the current extent  and open the next one if possible.
2041: F035         ;readModeFlag is true if in read mode
2042: F035             OpenNextExt:                      ; open$reel
2043: F035 AF                     XOR    A
2044: F036 32 60 F5               LD     (fcbCopiedFlag),A    ; set true if actually copied
2045: F039 CD 15 F1               CALL   CloseDirEntry        ; close current extent
2046: F03C         ; lowReturnStatus remains at enddir if we cannot open the next ext
2047: F03C CD 54 ED               CALL   EndOfDirectory
2048: F03F C8                     RET    Z                    ; return if end
2049: F040 2A 34 F5               LD     HL,(paramDE)         ; increment extent number
2050: F043 01 0C 00               LD     BC,fcbExtIndex
2051: F046 09                     ADD    HL,BC                ; HL=.fcb(fcbExtIndex)
2052: F047 7E                     LD     A,(HL)
2053: F048 3C                     INC    A
2054: F049 E6 1F                  AND    maxExtValue
2055: F04B 77                     LD     (HL),A               ; fcb(fcbExtIndex)=++1
2056: F04C CA 5E F0               JP     Z,OpenNextModule     ; move to next module if zero
2057: F04F         ; may be in the same extent group
2058: F04F 47                     LD     B,A
2059: F050 3A 52 F5               LD     A,(dpbEXM)
2060: F053 A0                     AND    B
2061: F054         ; if result is zero, then not in the same group
2062: F054 21 60 F5               LD     HL,fcbCopiedFlag     ; true if the fcb was copied to directory
2063: F057 A6                     AND    M                    ; produces a 00 in accumulator if not written
2064: F058 CA 69 F0               JP     Z,OpenNextExt1       ; go to next physical extent
2065: F05B         ; result is non zero, so we must be in same logical ext
2066: F05B C3 87 F0               JP     OpenNextExt2         ; to copy fcb information
2067: F05E         ; extent number overflow, go to next module
2068: F05E
2069: F05E             OpenNextModule:
2070: F05E 01 02 00               LD     BC,fcbS2Index-fcbExtIndex ;RATS
2071: F061 09                     ADD    HL,BC                ; HL=.fcb(fcbS2Index)
2072: F062 34                     INC    M                    ; fcb(fcbS2Index)=++1
2073: F063         ; module number incremented, check for overflow
2074: F063 7E                     LD     A,(HL)
2075: F064 E6 0F                  AND    moduleMask           ; mask high order bits
2076: F066 CA 92 F0               JP     Z,OpenNextExtError   ; cannot overflow to zero
2077: F069         ; otherwise, ok to continue with new module
2078: F069
2079: F069             OpenNextExt1:
2080: F069 0E 0F                  LD     C,nameLength
2081: F06B CD B0 F2               CALL   Search4DirElement    ; next extent found?
2082: F06E CD 54 ED               CALL   EndOfDirectory
2083: F071 C2 87 F0               JP     NZ,OpenNextExt2
2084: F074         ; end of file encountered
2085: F074 3A 61 F5               LD     A,(readModeFlag)
2086: F077 3C                     INC    A                    ; 0ffh becomes 00 if read
2087: F078 CA 92 F0               JP     Z,OpenNextExtError   ; sets lowReturnStatus = 1
2088: F07B         ; try to extend the current file
2089: F07B CD BD F0               CALL   MakeNewFile
2090: F07E         ; cannot be end of directory
2091: F07E CD 54 ED               CALL   EndOfDirectory
2092: F081 CA 92 F0               JP     Z,OpenNextExtError   ; with lowReturnStatus = 1
2093: F084 C3 8A F0               JP     OpenNextExt3
2094: F087
2095: F087         ; not end of file, open
2096: F087             OpenNextExt2:
2097: F087 CD 76 F2               CALL   OpenFileCopyFCB
2098: F08A             OpenNextExt3:
2099: F08A CD 6C EE               CALL   SetRecordVars        ; Set Record parameters
2100: F08D AF                     XOR    A
2101: F08E 32 36 F5               LD     (lowReturnStatus),A  ; lowReturnStatus = 0
2102: F091 C9                     RET                         ; with lowReturnStatus = 0
2103: F092
2104: F092         ; cannot move to next extent of this file
2105: F092             OpenNextExtError:
2106: F092 CD 47 F3               CALL   SetLowReturnTo1      ; lowReturnStatus = 1
2107: F095 C3 40 F3               JP     SetFileWriteFlag     ; ensure that it will not be closed
2108: F098         ;-----------------------------------------------------------------
2109: F098         ;rename the file described by the first half of the currently addressed FCB.
2110: F098         ;the new name is contained in the last half of the FCB. The file name and type
2111: F098         ;are changed, but the reel number is ignored.  the user number is identical
2112: F098             Rename:
2113: F098 CD 18 EF               CALL   CheckWrite           ; may be write protected
2114: F09B         ; search up to the extent field
2115: F09B 0E 0C                  LD     C,fcbExtIndex        ; extent number field index
2116: F09D CD B0 F2               CALL   Search4DirElement
2117: F0A0         ; copy position 0
2118: F0A0 2A 34 F5               LD     HL,(paramDE)
2119: F0A3 7E                     LD     A,(HL)               ; HL=.fcb(0), A=fcb(0)
2120: F0A4 11 10 00               LD     DE,fcbDiskMapIndex
2121: F0A7 19                     ADD    HL,DE                ; HL=.fcb(fcbDiskMapIndex)
2122: F0A8 77                     LD     (HL),A               ; fcb(fcbDiskMapIndex)=fcb(0)
2123: F0A9         ; assume the same disk drive for new named file
2124: F0A9             Rename1:
2125: F0A9 CD 54 ED               CALL   EndOfDirectory
2126: F0AC C8                     RET    Z                    ; stop at end of dir
2127: F0AD         ; not end of directory, rename next element
2128: F0AD CD 0B EF               CALL   CheckRODirectory     ; may be read-only file
2129: F0B0 0E 10                  LD     C,fcbDiskMapIndex
2130: F0B2 1E 0C                  LD     E,fcbExtIndex
2131: F0B4 CD 71 F3               CALL   CopyDir
2132: F0B7         ; element renamed, move to next
2133: F0B7 CD C8 F2               CALL   Search4NextDirElement
2134: F0BA C3 A9 F0               JP     Rename1
2135: F0BD         ;-----------------------------------------------------------------
2136: F0BD         ;create a new file by creating a directory entry then opening the file
2137: F0BD             MakeNewFile:
2138: F0BD CD 18 EF               CALL   CheckWrite           ; may be write protected
2139: F0C0 2A 34 F5               LD     HL,(paramDE)
2140: F0C3 E5                     PUSH   HL                   ; save fcb address, look for e5
2141: F0C4 21 39 F5               LD     HL,emptyFCB
2142: F0C7 22 34 F5               LD     (paramDE),HL         ; paramDE = .empty
2143: F0CA 0E 01                  LD     C,1
2144: F0CC CD B0 F2               CALL   Search4DirElement    ; length 1 match on empty entry
2145: F0CF CD 54 ED               CALL   EndOfDirectory       ; zero flag set if no space
2146: F0D2 E1                     POP    HL                   ; recall paramDE address
2147: F0D3 22 34 F5               LD     (paramDE),HL         ; in case we return here
2148: F0D6 C8                     RET    Z                    ; return with error condition 255 if not found
2149: F0D7 EB                     EX     DE,HL                ; DE = paramDE address
2150: F0D8         ; clear the remainder of the fcb
2151: F0D8 21 0F 00               LD     HL,nameLength
2152: F0DB 19                     ADD    HL,DE                ; HL=.fcb(nameLength)
2153: F0DC 0E 11                  LD     C,fcbLength-nameLength ; number of bytes to fill
2154: F0DE AF                     XOR    A                    ; clear accumulator to 00 for fill
2155: F0DF             MakeNewFile1:
2156: F0DF 77                     LD     (HL),A
2157: F0E0 23                     INC    HL
2158: F0E1 0D                     DEC    C
2159: F0E2 C2 DF F0               JP     NZ,MakeNewFile1
2160: F0E5 21 0D 00               LD     HL,fcbS1Index
2161: F0E8 19                     ADD    HL,DE                ; HL = .fcb(fcbS1Index)
2162: F0E9 77                     LD     (HL),A               ; fcb(fcbS1Index) = 0
2163: F0EA CD 49 EE               CALL   SetDirectoryEntry    ; may have extended the directory
2164: F0ED         ; now copy entry to the directory
2165: F0ED CD 6A F3               CALL   CopyFCB
2166: F0F0         ; and set the file write flag to "1"
2167: F0F0 C3 40 F3               JP     SetFileWriteFlag
2168: F0F3         ;-----------------------------------------------------------------
2169: F0F3         ;delete the currently addressed file
2170: F0F3             DeleteFile:
2171: F0F3 CD 18 EF               CALL   CheckWrite           ; write protected ?
2172: F0F6 0E 0C                  LD     C,fcbExtIndex        ; extent number field
2173: F0F8 CD B0 F2               CALL   Search4DirElement    ; search through file type
2174: F0FB             DeleteFile1:
2175: F0FB         ; loop while directory matches
2176: F0FB CD 54 ED               CALL   EndOfDirectory
2177: F0FE C8                     RET    Z                    ; exit if end
2178: F0FF         ; set each non zero disk map entry to 0 in the allocation vector
2179: F0FF CD 0B EF               CALL   CheckRODirectory     ; ro disk error if found
2180: F102 CD 40 EE               CALL   GetDirElementAddress ; HL=.buff(dptr)
2181: F105 36 E5                  LD     (HL),emptyDir
2182: F107 0E 00                  LD     C,0
2183: F109 CD BD EC               CALL   ScanDiskMap          ; alloc elts set to 0
2184: F10C CD 98 F1               CALL   WriteDir             ; write the directory
2185: F10F CD C8 F2               CALL   Search4NextDirElement ; to next element
2186: F112 C3 FB F0               JP     DeleteFile1          ; for another record
2187: F115         ;-----------------------------------------------------------------
2188: F115         ;locate the directory element and re-write it
2189: F115             CloseDirEntry:
2190: F115 AF                     XOR    A
2191: F116 32 36 F5               LD     (lowReturnStatus),A
2192: F119 CD 1F EF               CALL   DoNotWrite           ; return TRUE (0) if checksum change
2193: F11C C0                     RET    NZ                   ; skip close if r/o disk
2194: F11D         ; check file write flag - 0 indicates written
2195: F11D CD 37 F2               CALL   GetModuleNum         ; fcb(fcbS2Index) in A
2196: F120 E6 80                  AND    writeFlagMask
2197: F122 C0                     RET    NZ                   ; return if bit remains set
2198: F123 0E 0F                  LD     C,nameLength
2199: F125 CD B0 F2               CALL   Search4DirElement    ; locate file
2200: F128 CD 54 ED               CALL   EndOfDirectory
2201: F12B C8                     RET    Z                    ; return if not found
2202: F12C         ; merge the disk map at paramDE with that at buff(dptr)
2203: F12C 01 10 00               LD     BC,fcbDiskMapIndex
2204: F12F CD 40 EE               CALL   GetDirElementAddress
2205: F132 09                     ADD    HL,BC
2206: F133 EB                     EX     DE,HL                ; DE is .buff(dptr+16)
2207: F134 2A 34 F5               LD     HL,(paramDE)
2208: F137 09                     ADD    HL,BC                ; DE=.buff(dptr+16), HL=.fcb(16)
2209: F138 0E 10                  LD     C,(fcbLength-fcbDiskMapIndex) ; length of single byte dm
2210: F13A             CloseDirEntry1:
2211: F13A 3A 68 F5               LD     A,(single)
2212: F13D B7                     OR     A
2213: F13E CA 55 F1               JP     Z,CloseDirEntry4     ; skip to double
2214: F141         ; this is a single byte map
2215: F141         ; if fcb(i) = 0 then fcb(i) = buff(i)
2216: F141         ; if buff(i) = 0 then buff(i) = fcb(i)
2217: F141         ; if fcb(i) <> buff(i) then error
2218: F141 7E                     LD     A,(HL)
2219: F142 B7                     OR     A
2220: F143 1A                     LD     A,(DE)
2221: F144 C2 48 F1               JP     NZ,CloseDirEntry2
2222: F147         ; fcb(i) = 0
2223: F147 77                     LD     (HL),A               ; fcb(i) = buff(i)
2224: F148             CloseDirEntry2:
2225: F148 B7                     OR     A
2226: F149 C2 4E F1               JP     NZ,CloseDirEntry3
2227: F14C         ; buff(i) = 0
2228: F14C 7E                     LD     A,(HL)
2229: F14D 12                     LD     (DE),AE              ; buff(i)=fcb(i)
2230: F14E             CloseDirEntry3:
2231: F14E BE                     CP     M
2232: F14F C2 8D F1               JP     NZ,CloseDirEntryError ; fcb(i) = buff(i)?
2233: F152 C3 6A F1               JP     CloseDirEntry5       ; if merge ok
2234: F155
2235: F155         ; this is a double byte merge operation
2236: F155             CloseDirEntry4:
2237: F155 CD B6 F1               CALL   Merge                ; buff = fcb if buff 0000
2238: F158 EB                     EX     DE,HL
2239: F159 CD B6 F1               CALL   Merge
2240: F15C EB                     EX     DE,HL                ; fcb = buff if fcb 0000
2241: F15D         ; they should be identical at this point
2242: F15D 1A                     LD     A,(DE)
2243: F15E BE                     CP     M
2244: F15F C2 8D F1               JP     NZ,CloseDirEntryError ; low same?
2245: F162 13                     INC    DE
2246: F163 23                     INC    HL                   ; to high byte
2247: F164 1A                     LD     A,(DE)
2248: F165 BE                     CP     M
2249: F166 C2 8D F1               JP     NZ,CloseDirEntryError ; high same?
2250: F169         ;	merge operation ok for this pair
2251: F169 0D                     DEC    C                    ; extra count for double byte
2252: F16A             CloseDirEntry5:
2253: F16A 13                     INC    DE
2254: F16B 23                     INC    HL                   ; to next byte position
2255: F16C 0D                     DEC    C
2256: F16D C2 3A F1               JP     NZ,CloseDirEntry1    ; for more
2257: F170         ; end of disk map merge, check record count DE = .buff(dptr)+32, HL = .fcb(32)
2258: F170 01 EC FF               LD     BC,-(fcbLength-fcbExtIndex) ;RATS
2259: F173 09                     ADD    HL,BC
2260: F174 EB                     EX     DE,HL
2261: F175 09                     ADD    HL,BC
2262: F176         ; DE = .fcb(fcbExtIndex), HL = .buff(dptr+fcbExtIndex)
2263: F176 1A                     LD     A,(DE)               ; current user extent number
2264: F177         ; if fcb(ext) >= buff(fcb) then	buff(ext) := fcb(ext), buff(rec) := fcb(rec)
2265: F177 BE                     CP     M
2266: F178 DA 84 F1               JP     C,CloseDirEntryEnd
2267: F17B         ; fcb extent number >= dir extent number
2268: F17B 77                     LD     (HL),A               ; buff(ext) = fcb(ext)
2269: F17C         ; update directory record count field
2270: F17C 01 03 00               LD     BC,fcbRCIndex-fcbExtIndex ;RATS
2271: F17F 09                     ADD    HL,BC
2272: F180 EB                     EX     DE,HL
2273: F181 09                     ADD    HL,BC
2274: F182         ; DE=.buff(fcbRCIndex), HL=.fcb(fcbRCIndex)
2275: F182 7E                     LD     A,(HL)
2276: F183 12                     LD     (DE),AE              ; buff(fcbRCIndex)=fcb(fcbRCIndex)
2277: F184             CloseDirEntryEnd:
2278: F184 3E FF                  LD     A,TRUE
2279: F186 32 60 F5               LD     (fcbCopiedFlag),A    ; mark as copied
2280: F189 CD 92 F1               CALL   SeekCopy             ; ok to "WriteDir" here - 1.4 compat
2281: F18C C9                     RET
2282: F18D
2283: F18D         ; elements did not merge correctly
2284: F18D             CloseDirEntryError:
2285: F18D 21 36 F5               LD     HL,lowReturnStatus
2286: F190 35                     DEC    M                    ; =255 non zero flag set
2287: F191 C9                     RET
2288: F192         ;-----------------------------------------------------------------
2289: F192         ;enter from CloseDirEntry to seek and copy current element
2290: F192             SeekCopy:
2291: F192 CD 97 ED               CALL   SeekDir              ; to the directory element
2292: F195 C3 98 F1               JP     WriteDir             ; write the directory element
2293: F198         ;ret
2294: F198         ;-----------------------------------------------------------------
2295: F198         ;write the current directory entry, set checksum
2296: F198             WriteDir:
2297: F198 CD 09 EE               CALL   NewCheckSum          ; initialize entry
2298: F19B CD 4B ED               CALL   SetDirDMA            ; directory dma
2299: F19E 0E 01                  LD     C,1                  ; indicates a write directory operation
2300: F1A0 CD A6 F1               CALL   WriteBuffer          ; write the buffer
2301: F1A3 C3 45 ED               JP     SetDataDMA           ; to data dma address
2302: F1A6         ;ret
2303: F1A6         ;-----------------------------------------------------------------
2304: F1A6         ;write buffer and check condition
2305: F1A6         ;write type (wrtype) is in register C
2306: F1A6         ;wrtype = 0 => normal write operation		WriteAllocated
2307: F1A6         ;wrtype = 1 => directory write operation	WriteDirectory
2308: F1A6         ;wrtype = 2 => start of new block			WriteUnallocated
2309: F1A6             WriteBuffer:
2310: F1A6 CD 2A F6               CALL   bcWrite              ; current drive, track, sector, dma
2311: F1A9 B7                     OR     A
2312: F1AA C2 C8 F4               JP     NZ,erPermanentNoWait ; error if not 00
2313: F1AD C9                     RET
2314: F1AE         ;-----------------------------------------------------------------
2315: F1AE         ;read buffer and check condition
2316: F1AE             ReadBuffer:
2317: F1AE CD 27 F6               CALL   bcRead               ; current drive, track, sector, dma
2318: F1B1 B7                     OR     A
2319: F1B2 C2 C8 F4               JP     NZ,erPermanentNoWait
2320: F1B5 C9                     RET
2321: F1B6         ;-----------------------------------------------------------------
2322: F1B6         ;HL = .fcb1(i), DE = .fcb2(i),
2323: F1B6         ;if fcb1(i) = 0 then fcb1(i) := fcb2(i)
2324: F1B6             Merge:
2325: F1B6 7E                     LD     A,(HL)
2326: F1B7 23                     INC    HL
2327: F1B8 B6                     OR     M
2328: F1B9 2B                     DEC    HL
2329: F1BA C0                     RET    NZ                   ; return if = 0000
2330: F1BB 1A                     LD     A,(DE)
2331: F1BC 77                     LD     (HL),A
2332: F1BD 13                     INC    DE
2333: F1BE 23                     INC    HL                   ; low byte copied
2334: F1BF 1A                     LD     A,(DE)
2335: F1C0 77                     LD     (HL),A
2336: F1C1 1B                     DEC    DE
2337: F1C2 2B                     DEC    HL                   ; back to input form
2338: F1C3 C9                     RET
2339: F1C4         ;-----------------------------------------------------------------
2340: F1C4         ;compute closest disk block number from current block
2341: F1C4         ;given allocation vector position BC, find the zero bit closest to this position
2342: F1C4         ;by searching left and right.
2343: F1C4         ;if found, set the bit to one and return the bit position in hl.
2344: F1C4         ;if not found (i.e., we pass 0 on the left, or dpbDSM on the right), return 0000 in hl
2345: F1C4             GetClosestBlock:
2346: F1C4 50                     LD     D,B
2347: F1C5 59                     LD     E,C                  ; copy of starting position to de
2348: F1C6             TestLeft:
2349: F1C6 79                     LD     A,C
2350: F1C7 B0                     OR     B
2351: F1C8 CA D7 F1               JP     Z,TestRight          ; skip if left=0000
2352: F1CB         ; left not at position zero, bit zero?
2353: F1CB 0B                     DEC    BC
2354: F1CC D5                     PUSH   DE
2355: F1CD C5                     PUSH   BC                   ; left,right pushed
2356: F1CE CD EB EC               CALL   GetAllocBit
2357: F1D1 1F                     RRA
2358: F1D2 D2 F2 F1               JP     NC,ReturnBlockNumber ; return block number if zero
2359: F1D5         ; bit is one, so try the right
2360: F1D5 C1                     POP    BC
2361: F1D6 D1                     POP    DE                   ; left, right restored
2362: F1D7             TestRight:
2363: F1D7 2A 53 F5               LD     HL,(dpbDSM)          ; value of maximum allocation#
2364: F1DA 7B                     LD     A,E
2365: F1DB 95                     SUB    L
2366: F1DC 7A                     LD     A,D
2367: F1DD 9C                     SBC    A,H                  ; right=dpbDSM?
2368: F1DE D2 FA F1               JP     NC,ReturnBlockZero   ; return block 0000 if so
2369: F1E1 13                     INC    DE
2370: F1E2 C5                     PUSH   BC
2371: F1E3 D5                     PUSH   DE                   ; left, right pushed
2372: F1E4 42                     LD     B,D
2373: F1E5 4B                     LD     C,E                  ; ready right for call
2374: F1E6 CD EB EC               CALL   GetAllocBit
2375: F1E9 1F                     RRA
2376: F1EA D2 F2 F1               JP     NC,ReturnBlockNumber ; return block number if zero
2377: F1ED D1                     POP    DE
2378: F1EE C1                     POP    BC                   ; restore left and right pointers
2379: F1EF C3 C6 F1               JP     TestLeft             ; for another attempt
2380: F1F2             ReturnBlockNumber:
2381: F1F2 17                     RLA
2382: F1F3 3C                     INC    A                    ; bit back into position and set to 1
2383: F1F4         ; 	D contains the number of shifts required to reposition
2384: F1F4 CD 1D ED               CALL   RotateAndReplace     ; move bit back to position and store
2385: F1F7 E1                     POP    HL
2386: F1F8 D1                     POP    DE                   ; HL returned value, DE discarded
2387: F1F9 C9                     RET
2388: F1FA
2389: F1FA         ; cannot find an available bit, return 0000
2390: F1FA             ReturnBlockZero:
2391: F1FA 21 00 00               LD     HL,0000H
2392: F1FD C9                     RET
2393: F1FE         ;-----------------------------------------------------------------
2394: F1FE         ;compute disk block number from current fcb
2395: F1FE             GetBlockNumber:
2396: F1FE CD 86 F3               CALL   GetDiskMapIndex      ; 0...15 in register A
2397: F201 4F                     LD     C,A
2398: F202 06 00                  LD     B,0
2399: F204 CD A6 F3               CALL   GetDiskMapValue      ; return value in HL
2400: F207 22 70 F5               LD     (currentBlock),HL    ; save for later
2401: F20A C9                     RET
2402: F20B         ;-----------------------------------------------------------------
2403: F20B         ;is  block allocated
2404: F20B             IsAllocated:
2405: F20B 2A 70 F5               LD     HL,(currentBlock)
2406: F20E 7D                     LD     A,L
2407: F20F B4                     OR     H
2408: F210 C9                     RET
2409: F211         ;-----------------------------------------------------------------
2410: F211         ;compute actual record address
2411: F211         ; result = currentBlock * ( 2**BSH)
2412: F211             SetActualRecordAdd:
2413: F211 3A 50 F5               LD     A,(dpbBSH)           ; Block Shift  to reg A
2414: F214 2A 70 F5               LD     HL,(currentBlock)
2415: F217
2416: F217             SetActualRecordAdd1:
2417: F217 29                     ADD    HL,HL
2418: F218 3D                     DEC    A                    ; shl(currentBlock,dpbBSH)
2419: F219 C2 17 F2               JP     NZ,SetActualRecordAdd1
2420: F21C         ; HL has Record number for start of the block;
2421: F21C 3A 51 F5               LD     A,(dpbBLM)           ; get block mask
2422: F21F 4F                     LD     C,A                  ; to get cpmRecord mod Block
2423: F220 3A 6E F5               LD     A,(cpmRecord)        ; get index into block
2424: F223 A1                     AND    C                    ; masked value in A
2425: F224 B5                     OR     L
2426: F225 6F                     LD     L,A                  ; to HL
2427: F226 22 70 F5               LD     (currentBlock),HL    ; currentBlock=HL or (cpmRecord and dpbBLM)
2428: F229         ; *** currentBlock now has current record number - Starting record number + index into block
2429: F229 C9                     RET
2430: F22A         ;-----------------------------------------------------------------
2431: F22A         ;---------------------
2432: F22A         ;copy directory location to lowReturnStatus
2433: F22A             DirLocationToReturnLoc:
2434: F22A 3A 62 F5               LD     A,(directoryFlag)
2435: F22D 32 36 F5               LD     (lowReturnStatus),A
2436: F230 C9                     RET
2437: F231         ;---------------------
2438: F231         ;clear the module number field for user open/make (S2)
2439: F231             ClearModuleNum:
2440: F231 CD 37 F2               CALL   GetModuleNum
2441: F234 36 00                  LD     (HL),0               ; fcb(fcbS2Index)=0
2442: F236 C9                     RET
2443: F237         ;---------------------
2444: F237         ;get data module number (high order bit is fwf -file write flag)
2445: F237             GetModuleNum:
2446: F237 2A 34 F5               LD     HL,(paramDE)
2447: F23A 11 0E 00               LD     DE,fcbS2Index
2448: F23D 19                     ADD    HL,DE                ; HL=.fcb(fcbS2Index)
2449: F23E 7E                     LD     A,(HL)
2450: F23F C9                     RET                         ; A=fcb(fcbS2Index)
2451: F240         ;---------------------
2452: F240         ;check current fcb to see if reselection necessary
2453: F240             Reselect:
2454: F240 3E FF                  LD     A,TRUE
2455: F242 32 69 F5               LD     (fResel),A           ;mark possible reselect
2456: F245 2A 34 F5               LD     HL,(paramDE)
2457: F248 7E                     LD     A,(HL)               ; drive select code
2458: F249 E6 1F                  AND    00011111B            ; non zero is auto drive select
2459: F24B 3D                     DEC    A                    ; drive code normalized to 0..30, or 255
2460: F24C 32 5D F5               LD     (paramE),A           ; save drive code
2461: F24F FE 1E                  CP     30
2462: F251 D2 64 F2               JP     NC,NoSelect
2463: F254         ; auto select function, save currentDisk
2464: F254 3A 38 F5               LD     A,(currentDisk)
2465: F257 32 6A F5               LD     (entryDisk),A        ; entryDisk=currentDisk
2466: F25A 7E                     LD     A,(HL)
2467: F25B 32 6B F5               LD     (fcbDisk),A          ; save drive code
2468: F25E E6 E0                  AND    11100000B
2469: F260 77                     LD     (HL),A               ; preserve hi bits
2470: F261 CD BD EB               CALL   SelectCurrent
2471: F264             NoSelect:                       ; noselect:
2472: F264
2473: F264 3A 33 F5               LD     A,(currentUserNumber) ; set user code 0...31
2474: F267 2A 34 F5               LD     HL,(paramDE)
2475: F26A B6                     OR     M
2476: F26B 77                     LD     (HL),A
2477: F26C C9                     RET
2478: F26D         ;---------------------
2479: F26D         ;search for the directory entry, copy to fcb
2480: F26D             OpenFile:
2481: F26D 0E 0F                  LD     C,nameLength
2482: F26F CD B0 F2               CALL   Search4DirElement
2483: F272 CD 54 ED               CALL   EndOfDirectory
2484: F275 C8                     RET    Z                    ; return with lowReturnStatus=255 if end
2485: F276
2486: F276         ; not end of directory, copy fcb information
2487: F276             OpenFileCopyFCB:
2488: F276 CD 38 F3               CALL   GetExtentAddress     ; HL=.fcb(fcbExtIndex)
2489: F279 7E                     LD     A,(HL)
2490: F27A F5                     PUSH   AF
2491: F27B E5                     PUSH   HL                   ; save extent#
2492: F27C CD 40 EE               CALL   GetDirElementAddress
2493: F27F EB                     EX     DE,HL                ; DE = .buff(dptr)
2494: F280 2A 34 F5               LD     HL,(paramDE)         ; HL=.fcb(0)
2495: F283 0E 20                  LD     C,NEXT_RECORD        ; length of move operation
2496: F285 D5                     PUSH   DE                   ; save .buff(dptr)
2497: F286 CD DF F3               CALL   Move                 ; from .buff(dptr) to .fcb(0)
2498: F289         ; note that entire fcb is copied, including indicators
2499: F289 CD 40 F3               CALL   SetFileWriteFlag     ; sets file write flag
2500: F28C D1                     POP    DE
2501: F28D 21 0C 00               LD     HL,fcbExtIndex
2502: F290 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbExtIndex)
2503: F291 4E                     LD     C,(HL)               ; C = directory extent number
2504: F292 21 0F 00               LD     HL,fcbRCIndex        ; point at the record Count field
2505: F295 19                     ADD    HL,DE                ; HL=.buff(dptr+fcbRCIndex)
2506: F296 46                     LD     B,(HL)               ; B holds directory record count
2507: F297 E1                     POP    HL
2508: F298 F1                     POP    AF
2509: F299 77                     LD     (HL),A               ; restore extent number
2510: F29A         ; HL = .user extent#, B = dir rec cnt, C = dir extent#
2511: F29A         ; if user ext < dir ext then user := 128 records
2512: F29A         ; if user ext = dir ext then user := dir records
2513: F29A         ; if user ext > dir ext then user := 0 records
2514: F29A 79                     LD     A,C
2515: F29B BE                     CP     M
2516: F29C 78                     LD     A,B                  ; ready dir fcbRCIndex
2517: F29D CA A7 F2               JP     Z,OpenRecordCount    ; if same, user gets dir fcbRCIndex
2518: F2A0 3E 00                  LD     A,0
2519: F2A2 DA A7 F2               JP     C,OpenRecordCount    ; user is larger
2520: F2A5 3E 80                  LD     A,RecordsPerExtent   ; directory is larger >>>RecordsPerExtent
2521: F2A7             OpenRecordCount:                      ;Acc has record count to fill
2522: F2A7 2A 34 F5               LD     HL,(paramDE)
2523: F2AA 11 0F 00               LD     DE,fcbRCIndex
2524: F2AD 19                     ADD    HL,DE
2525: F2AE 77                     LD     (HL),A
2526: F2AF C9                     RET
2527: F2B0
2528: F2B0         ;---------------------
2529: F2B0         ;search for directory element of length C at info
2530: F2B0             Search4DirElement:
2531: F2B0 3E FF                  LD     A,0FFH
2532: F2B2 32 62 F5               LD     (directoryFlag),A    ; changed if actually found
2533: F2B5 21 65 F5               LD     HL,searchLength
2534: F2B8 71                     LD     (HL),C               ; searchLength = C
2535: F2B9 2A 34 F5               LD     HL,(paramDE)
2536: F2BC 22 66 F5               LD     (searchAddress),HL   ; searchAddress = paramDE
2537: F2BF CD 3E ED               CALL   SetEndDirectory      ; dirEntryIndex = enddir
2538: F2C2 CD 24 ED               CALL   Home                 ; to start at the beginning
2539: F2C5 C3 C8 F2               JP     Search4NextDirElement
2540: F2C8         ;---------------------
2541: F2C8         ;search for the next directory element, assuming a previous
2542: F2C8         ;call on search which sets searchAddress and searchLength
2543: F2C8             Search4NextDirElement:
2544: F2C8 0E 00                  LD     C,FALSE
2545: F2CA CD 66 ED               CALL   ReadDirectory        ; read next dir element
2546: F2CD CD 54 ED               CALL   EndOfDirectory
2547: F2D0 CA 2F F3               JP     Z,SearchDone         ; skip to end if so
2548: F2D3         ; not end of directory, scan for match
2549: F2D3 2A 66 F5               LD     HL,(searchAddress)
2550: F2D6 EB                     EX     DE,HL                ; DE=beginning of user fcb
2551: F2D7 1A                     LD     A,(DE)               ; first character
2552: F2D8 FE E5                  CP     emptyDir             ; keep scanning if Dir entry is empty
2553: F2DA CA E5 F2               JP     Z,Search4NextDirElement1
2554: F2DD         ; not emptyDir, may be end of logical directory
2555: F2DD D5                     PUSH   DE                   ; save search address
2556: F2DE CD 52 EE               CALL   StillInDirectory     ; past logical end?
2557: F2E1 D1                     POP    DE                   ; recall address
2558: F2E2 D2 2F F3               JP     NC,SearchDone        ; artificial stop
2559: F2E5             Search4NextDirElement1:
2560: F2E5 CD 40 EE               CALL   GetDirElementAddress ; HL = buffa+dptr
2561: F2E8 3A 65 F5               LD     A,(searchLength)
2562: F2EB 4F                     LD     C,A                  ; length of search to c
2563: F2EC 06 00                  LD     B,0                  ; bcounts up, c counts down
2564: F2EE             Search4NextLoop:
2565: F2EE 79                     LD     A,C
2566: F2EF B7                     OR     A
2567: F2F0 CA 1E F3               JP     Z,EndDirElementSearch
2568: F2F3 1A                     LD     A,(DE)
2569: F2F4 FE 3F                  CP     QMARK
2570: F2F6 CA 17 F3               JP     Z,Search4NextOK      ; ? matches all
2571: F2F9         ; scan next character if not fcbS1Index
2572: F2F9 78                     LD     A,B
2573: F2FA FE 0D                  CP     fcbS1Index
2574: F2FC CA 17 F3               JP     Z,Search4NextOK
2575: F2FF         ; not the fcbS1Index field, extent field?
2576: F2FF FE 0C                  CP     fcbExtIndex          ; may be extent field
2577: F301 1A                     LD     A,(DE)               ; fcb character
2578: F302 CA 0E F3               JP     Z,Search4Ext         ; skip to search extent
2579: F305 96                     SUB    M
2580: F306 E6 7F                  AND    07FH                 ; mask-out flags/extent modulus
2581: F308 C2 C8 F2               JP     NZ,Search4NextDirElement ; skip if not matched
2582: F30B C3 17 F3               JP     Search4NextOK        ;matched character
2583: F30E
2584: F30E         ; A has fcb character attempt an extent # match
2585: F30E             Search4Ext:
2586: F30E C5                     PUSH   BC                   ; save counters
2587: F30F 4E                     LD     C,(HL)               ; directory character to c
2588: F310 CD 4D F3               CALL   CompareExtents       ; compare user/dir char
2589: F313 C1                     POP    BC                   ; recall counters
2590: F314 C2 C8 F2               JP     NZ,Search4NextDirElement ; skip if no match
2591: F317
2592: F317         ; current character matches
2593: F317             Search4NextOK:
2594: F317 13                     INC    DE
2595: F318 23                     INC    HL
2596: F319 04                     INC    B
2597: F31A 0D                     DEC    C
2598: F31B C3 EE F2               JP     Search4NextLoop
2599: F31E
2600: F31E         ; entire name matches, return dir position
2601: F31E             EndDirElementSearch:
2602: F31E 3A 73 F5               LD     A,(dirEntryIndex)
2603: F321 E6 03                  AND    dirEntryMask
2604: F323 32 36 F5               LD     (lowReturnStatus),A
2605: F326         ; lowReturnStatus = low(dirEntryIndex) and 11b
2606: F326 21 62 F5               LD     HL,directoryFlag
2607: F329 7E                     LD     A,(HL)
2608: F32A 17                     RLA
2609: F32B D0                     RET    NC                   ; directoryFlag=0ffh?
2610: F32C         ; yes, change it to 0 to mark as found
2611: F32C AF                     XOR    A
2612: F32D 77                     LD     (HL),A               ; directoryFlag=0
2613: F32E C9                     RET
2614: F32F
2615: F32F         ; end of directory, or empty name
2616: F32F             SearchDone:
2617: F32F CD 3E ED               CALL   SetEndDirectory      ; may be artifical end
2618: F332 3E FF                  LD     A,0FFH
2619: F334 32 36 F5               LD     (lowReturnStatus),A
2620: F337 C9                     RET
2621: F338         ;---------------------
2622: F338         ;get current extent field address to (HL)
2623: F338             GetExtentAddress:
2624: F338 2A 34 F5               LD     HL,(paramDE)
2625: F33B 11 0C 00               LD     DE,fcbExtIndex
2626: F33E 19                     ADD    HL,DE                ;HL=.fcb(fcbExtIndex)
2627: F33F C9                     RET
2628: F340         ;---------------------
2629: F340         ;Set file write flag
2630: F340             SetFileWriteFlag:
2631: F340 CD 37 F2               CALL   GetModuleNum         ; HL=.fcb(fcbS2Index), A=fcb(fcbS2Index)
2632: F343 F6 80                  OR     writeFlagMask        ; set fwf (file write flag) to "1"
2633: F345 77                     LD     (HL),A               ; fcb(fcbS2Index)=fcb(fcbS2Index) or 80h
2634: F346 C9                     RET                         ; also returns non zero in accumulator
2635: F347         ;---------------------
2636: F347         ;set lowReturnStatus to 1
2637: F347             SetLowReturnTo1:
2638: F347 3E 01                  LD     A,1
2639: F349 32 36 F5               LD     (lowReturnStatus),A
2640: F34C C9                     RET
2641: F34D         ;---------------------
2642: F34D         ;compare extent# in A with that in C, return nonzero if they do not match
2643: F34D             CompareExtents:
2644: F34D C5                     PUSH   BC                   ; save C's original value
2645: F34E F5                     PUSH   AF
2646: F34F 3A 52 F5               LD     A,(dpbEXM)
2647: F352 2F                     CPL
2648: F353 47                     LD     B,A
2649: F354         ; B has negated form of extent mask
2650: F354 79                     LD     A,C
2651: F355 A0                     AND    B
2652: F356 4F                     LD     C,A                  ; low bits removed from C
2653: F357 F1                     POP    AF
2654: F358 A0                     AND    B                    ; low bits removed from A
2655: F359 91                     SUB    C
2656: F35A E6 1F                  AND    maxExtValue          ; set flags
2657: F35C C1                     POP    BC                   ; restore original values
2658: F35D C9                     RET
2659: F35E         ;---------------------
2660: F35E         ;copy the directory entry to the user buffer
2661: F35E             CopyDirEntryToUser:
2662: F35E 2A 46 F5               LD     HL,(caDirectoryDMA)
2663: F361 EB                     EX     DE,HL                ; source is directory buffer
2664: F362 2A 3E F5               LD     HL,(InitDAMAddress)  ; destination is user dma address
2665: F365 0E 80                  LD     C,cpmRecordSize      ; copy entire record
2666: F367 C3 DF F3               JP     Move
2667: F36A         ;---------------------
2668: F36A         ;copy the whole file control block
2669: F36A             CopyFCB:
2670: F36A 0E 00                  LD     C,0
2671: F36C 1E 20                  LD     E,fcbLength          ; start at 0, to fcblen-1
2672: F36E C3 71 F3               JP     CopyDir
2673: F371         ;---------------------
2674: F371         ;copy fcb information starting at C for E bytes into the currently addressed directory entry
2675: F371             CopyDir:
2676: F371 D5                     PUSH   DE                   ; save length for later
2677: F372 06 00                  LD     B,0                  ; double index to BC
2678: F374 2A 34 F5               LD     HL,(paramDE)         ; HL = source for data
2679: F377 09                     ADD    HL,BC
2680: F378 EB                     EX     DE,HL                ; DE=.fcb(C), source for copy
2681: F379 CD 40 EE               CALL   GetDirElementAddress ; HL=.buff(dptr), destination
2682: F37C C1                     POP    BC                   ; DE=source, HL=dest, C=length
2683: F37D CD DF F3               CALL   Move                 ; data moved
2684: F380         ;enter from close to seek and copy current element
2685: F380             SeekAndCopy:                      ; seek$copy:
2686: F380 CD 97 ED               CALL   SeekDir              ; seek$dir ;to the directory element
2687: F383 C3 98 F1               JP     WriteDir             ; write the directory element
2688: F386         ;---------------------
2689: F386         ;Return the  disk map Index for cpmRecord in the ACC
2690: F386         ;  account for multiple extents in 1 physical Directory entry
2691: F386             GetDiskMapIndex:                      ; dm$position
2692: F386 21 50 F5               LD     HL,dpbBSH            ; get block shift value
2693: F389 4E                     LD     C,(HL)               ; shift count to C
2694: F38A 3A 6E F5               LD     A,(cpmRecord)        ; current virtual record to A
2695: F38D             GetDiskMapIndex1:
2696: F38D B7                     OR     A                    ; reset the carry flag
2697: F38E 1F                     RRA
2698: F38F 0D                     DEC    C
2699: F390 C2 8D F3               JP     NZ,GetDiskMapIndex1
2700: F393         ; A = shr(cpmRecord,dpbBSH) = cpmRecord/2**(sect/block)
2701: F393         ; A has the relative position in the block.
2702: F393 47                     LD     B,A                  ; save it for later addition
2703: F394 3E 08                  LD     A,8
2704: F396 96                     SUB    M                    ; 8-dpbBSH to accumulator
2705: F397 4F                     LD     C,A                  ; extent shift count in register c
2706: F398 3A 6D F5               LD     A,(extentValue)      ; extent value ani extmsk
2707: F39B             GetDiskMapIndex2:                      ; dmpos1:
2708: F39B         ; dpbBSH = 3,4,5,6,7, C=5,4,3,2,1
2709: F39B         ; shift is 4,3,2,1,0
2710: F39B 0D                     DEC    C
2711: F39C CA A4 F3               JP     Z,GetDiskMapIndex3
2712: F39F B7                     OR     A                    ; clear the carry flag
2713: F3A0 17                     RLA
2714: F3A1 C3 9B F3               JP     GetDiskMapIndex2
2715: F3A4
2716: F3A4         ; The ACC has the Block Number for this record
2717: F3A4             GetDiskMapIndex3:
2718: F3A4         ; arrive here with A = shl(ext and extmsk,7-dpbBSH)
2719: F3A4 80                     ADD    A,B                  ; add the previous shr(cpmRecord,dpbBSH) value
2720: F3A5         ; A is one of the following values, depending upon alloc
2721: F3A5         ; bks dpbBSH
2722: F3A5         ; 1k   3     v/8 + extentValue * 16
2723: F3A5         ; 2k   4     v/16+ extentValue * 8
2724: F3A5         ; 4k   5     v/32+ extentValue * 4
2725: F3A5         ; 8k   6     v/64+ extentValue * 2
2726: F3A5         ; 16k  7     v/128+extentValue * 1
2727: F3A5 C9                     RET                         ; with disk map position in A
2728: F3A6         ;---------------------
2729: F3A6         ; Enter with Disk Map Index in BG
2730: F3A6         ; Return disk map value  in HL
2731: F3A6             GetDiskMapValue:
2732: F3A6 2A 34 F5               LD     HL,(paramDE)         ; base address of file control block
2733: F3A9 11 10 00               LD     DE,fcbDiskMapIndex   ; offset to the disk map
2734: F3AC 19                     ADD    HL,DE                ; HL =.diskmap
2735: F3AD 09                     ADD    HL,BC                ; index by a single byte value
2736: F3AE 3A 68 F5               LD     A,(single)           ; single byte/map entry?
2737: F3B1 B7                     OR     A
2738: F3B2 CA B9 F3               JP     Z,GetDiskMap16Bit    ; get disk map single byte
2739: F3B5 6E                     LD     L,(HL)
2740: F3B6 26 00                  LD     H,0
2741: F3B8 C9                     RET                         ; with HL=00bb
2742: F3B9             GetDiskMap16Bit:                      ; getdmd:
2743: F3B9 09                     ADD    HL,BC                ; HL=.fcb(dm+i*2)
2744: F3BA         ; double precision value returned
2745: F3BA 56                     LD     D,(HL)
2746: F3BB 23                     INC    HL
2747: F3BC 5E                     LD     E,(HL)
2748: F3BD EB                     EX     DE,HL
2749: F3BE C9                     RET
2750: F3BF         ;---------------------
2751: F3BF         ;---------------------
2752: F3BF         ;*****************************************************************
2753: F3BF         ;************************ Utilities ******************************
2754: F3BF         ;*****************************************************************
2755: F3BF             AddAtoHL:
2756: F3BF 85                     ADD    A,L
2757: F3C0 6F                     LD     L,A
2758: F3C1 D0                     RET    NC
2759: F3C2 24                     INC    H
2760: F3C3 C9                     RET
2761: F3C4         ;----------
2762: F3C4             DEminusHL2HL:
2763: F3C4 7B                     LD     A,E
2764: F3C5 95                     SUB    L
2765: F3C6 6F                     LD     L,A
2766: F3C7 7A                     LD     A,D
2767: F3C8 9C                     SBC    A,H
2768: F3C9 67                     LD     H,A
2769: F3CA C9                     RET
2770: F3CB         ;-------------
2771: F3CB             ShiftRightHLbyC:
2772: F3CB 0C                     INC    C
2773: F3CC             ShiftRightHLbyC0:
2774: F3CC 0D                     DEC    C
2775: F3CD C8                     RET    Z
2776: F3CE 7C                     LD     A,H
2777: F3CF B7                     OR     A
2778: F3D0 1F                     RRA
2779: F3D1 67                     LD     H,A
2780: F3D2 7D                     LD     A,L
2781: F3D3 1F                     RRA
2782: F3D4 6F                     LD     L,A
2783: F3D5 C3 CC F3               JP     ShiftRightHLbyC0
2784: F3D8         ;-------
2785: F3D8             ShiftLeftHLbyC:
2786: F3D8 0C                     INC    C
2787: F3D9             ShiftLeftHLbyC0:
2788: F3D9 0D                     DEC    C
2789: F3DA C8                     RET    Z                    ; exit when done
2790: F3DB 29                     ADD    HL,HL
2791: F3DC C3 D9 F3               JP     ShiftLeftHLbyC0
2792: F3DF         ;*****************************************************************
2793: F3DF         ;move data length of length C from source DE to HL
2794: F3DF             Move:
2795: F3DF 0C                     INC    C
2796: F3E0             Move0:
2797: F3E0 0D                     DEC    C
2798: F3E1 C8                     RET    Z
2799: F3E2 1A                     LD     A,(DE)
2800: F3E3 77                     LD     (HL),A
2801: F3E4 13                     INC    DE
2802: F3E5 23                     INC    HL
2803: F3E6 C3 E0 F3               JP     Move0
2804: F3E9
2805: F3E9         ;********** Console Routines***********************
2806: F3E9         ;********** Console IN Routines********************
2807: F3E9         ;read console character to A
2808: F3E9             ConIn:
2809: F3E9 21 7C F5               LD     HL,kbchar
2810: F3EC 7E                     LD     A,(HL)
2811: F3ED 36 00                  LD     (HL),0
2812: F3EF B7                     OR     A
2813: F3F0 C0                     RET    NZ
2814: F3F1         ;no previous keyboard character ready
2815: F3F1 C3 09 F6               JP     bcConin              ;get character externally
2816: F3F4         ;----------------
2817: F3F4         ;echo character if graphic CR, LF, TAB, or backspace
2818: F3F4             EchoNonGraphicCharacter:
2819: F3F4 FE 0D                  CP     CR
2820: F3F6 C8                     RET    Z                    ; carriage return?
2821: F3F7 FE 0A                  CP     LF
2822: F3F9 C8                     RET    Z                    ; line feed?
2823: F3FA FE 09                  CP     TAB
2824: F3FC C8                     RET    Z                    ; TAB?
2825: F3FD FE 08                  CP     CTRL_H
2826: F3FF C8                     RET    Z                    ; backspace?
2827: F400 FE 20                  CP     SPACE
2828: F402 C9                     RET                         ; carry set if not graphic
2829: F403         ;----------------
2830: F403         ;read character with echo
2831: F403             ConsoleInWithEcho:
2832: F403 CD E9 F3               CALL   ConIn
2833: F406 CD F4 F3               CALL   EchoNonGraphicCharacter
2834: F409 D8                     RET    C                    ; return if graphic character
2835: F40A         ; character must be echoed before return
2836: F40A F5                     PUSH   AF
2837: F40B 4F                     LD     C,A
2838: F40C CD 55 EB               CALL   TabOut
2839: F40F F1                     POP    AF
2840: F410 C9                     RET                         ; with character in A
2841: F411         ;********** Console OUT Routines*******************
2842: F411             ConBreak:
2843: F411 3A 7C F5               LD     A,(kbchar)
2844: F414 B7                     OR     A
2845: F415 C2 33 F4               JP     NZ,ConBreak1         ; skip if active kbchar
2846: F418 CD 06 F6               CALL   bcConst              ; get status
2847: F41B E6 01                  AND    1
2848: F41D C8                     RET    Z                    ; return if no char ready
2849: F41E CD 09 F6               CALL   bcConin              ; to A
2850: F421 FE 13                  CP     CTRL_S
2851: F423 C2 30 F4               JP     NZ,ConBreak0         ; check stop screen function
2852: F426         ; found CTRL_S, read next character
2853: F426 CD 09 F6               CALL   bcConin              ; to A
2854: F429 FE 03                  CP     CTRL_C
2855: F42B CA 00 00               JP     Z,WarmBoot           ; CTRL_C implies re-boot
2856: F42E         ; not a WarmBoot, act as if nothing has happened
2857: F42E AF                     XOR    A
2858: F42F C9                     RET                         ; with zero in accumulator
2859: F430             ConBreak0:
2860: F430         ; character in accum, save it
2861: F430 32 7C F5               LD     (kbchar),A
2862: F433             ConBreak1:
2863: F433
2864: F433 3E FF                  LD     A,TRUE               ; return with true set in accumulator
2865: F435 C9                     RET
2866: F436         ;
2867: F436         ;
2868: F436         ;display #, CR, LF for CTRL_X, CTRL_U, CTRL_R functions
2869: F436         ;then move to startingColumn (starting columnPosition)
2870: F436             showHashCRLF:
2871: F436 0E 23                  LD     C,HASH_TAG
2872: F438 CD 66 F4               CALL   ConsoleOut
2873: F43B CD 4E F4               CALL   showCRLF
2874: F43E         ; columnPosition = 0, move to position startingColumn
2875: F43E             showHashCRLF0:
2876: F43E 3A 7A F5               LD     A,(columnPosition)
2877: F441 21 79 F5               LD     HL,startingColumn
2878: F444 BE                     CP     M
2879: F445 D0                     RET    NC                   ; stop when columnPosition reaches startingColumn
2880: F446 0E 20                  LD     C,SPACE
2881: F448 CD 66 F4               CALL   ConsoleOut           ; display blank
2882: F44B C3 3E F4               JP     showHashCRLF0
2883: F44E         ;
2884: F44E         ;carriage return line feed sequence
2885: F44E             showCRLF:
2886: F44E 0E 0D                  LD     C,CR
2887: F450 CD 66 F4               CALL   ConsoleOut
2888: F453 0E 0A                  LD     C,LF
2889: F455 C3 66 F4               JP     ConsoleOut
2890: F458
2891: F458         ;-------------
2892: F458         ; print message until M(BC) = '$'
2893: F458             Print:
2894: F458 0A                     LD     A,(BC)
2895: F459 FE 24                  CP     DOLLAR
2896: F45B C8                     RET    Z                    ; stop on $
2897: F45C 03                     INC    BC
2898: F45D C5                     PUSH   BC
2899: F45E 4F                     LD     C,A
2900: F45F CD 55 EB               CALL   TabOut
2901: F462 C1                     POP    BC
2902: F463 C3 58 F4               JP     Print
2903: F466
2904: F466         ;----------------
2905: F466         ; compute character position/write console char from C
2906: F466         ; compcol = true if computing column position
2907: F466             ConsoleOut:                      ; conout
2908: F466 3A 78 F5               LD     A,(compcol)
2909: F469 B7                     OR     A
2910: F46A C2 80 F4               JP     NZ,ConsoleOut1
2911: F46D         ; write the character, then compute the columnPosition
2912: F46D         ; write console character from C
2913: F46D C5                     PUSH   BC
2914: F46E CD 11 F4               CALL   ConBreak             ; check for screen stop function
2915: F471 C1                     POP    BC
2916: F472 C5                     PUSH   BC                   ; recall/save character
2917: F473 CD 0C F6               CALL   bcConout             ; externally, to console
2918: F476 C1                     POP    BC
2919: F477 C5                     PUSH   BC                   ; recall/save character
2920: F478         ; may be copying to the list device
2921: F478 3A 7B F5               LD     A,(listeningToggle)
2922: F47B B7                     OR     A
2923: F47C C4 0F F6               CALL   NZ,bcList            ; to printer, if so
2924: F47F C1                     POP    BC                   ; recall the character
2925: F480             ConsoleOut1:
2926: F480 79                     LD     A,C                  ; recall the character
2927: F481         ; and compute column position
2928: F481 21 7A F5               LD     HL,columnPosition    ; A = char, HL = .columnPosition
2929: F484 FE 7F                  CP     RUBOUT
2930: F486 C8                     RET    Z                    ; no columnPosition change if nulls
2931: F487 34                     INC    M                    ; columnPosition = columnPosition + 1
2932: F488 FE 20                  CP     SPACE
2933: F48A D0                     RET    NC                   ; return if graphic
2934: F48B         ; not graphic, reset columnPosition position
2935: F48B 35                     DEC    M                    ; columnPosition = columnPosition - 1
2936: F48C 7E                     LD     A,(HL)
2937: F48D B7                     OR     A
2938: F48E C8                     RET    Z                    ; return if at zero
2939: F48F         ; not at zero, may be backspace or end line
2940: F48F 79                     LD     A,C                  ; character back to A
2941: F490 FE 08                  CP     CTRL_H
2942: F492 C2 97 F4               JP     NZ,NotBackSpace
2943: F495         ; backspace character
2944: F495 35                     DEC    M                    ; columnPosition = columnPosition - 1
2945: F496 C9                     RET
2946: F497             NotBackSpace:                      ; notbacksp:  not a backspace character  eol?
2947: F497 FE 0A                  CP     LF
2948: F499 C0                     RET    NZ                   ; return if not
2949: F49A         ; end of line, columnPosition = 0
2950: F49A 36 00                  LD     (HL),0               ; columnPosition = 0
2951: F49C C9                     RET
2952: F49D
2953: F49D         ;********************************************************
2954: F49D         ;return version number
2955: F49D             vGetVersion:                      ; func12 (12 - 0C)	 Get Verson
2956: F49D 3E 20                  LD     A,VERSION
2957: F49F 32 36 F5               LD     (lowReturnStatus),A  ;lowReturnStatus = VERSION (high = 00)
2958: F4A2 C9                     RET
2959: F4A3         ;************Error message World*************************
2960: F4A3             errSelect:
2961: F4A3 21 C2 F4               LD     HL,evSelection
2962: F4A6 C3 BB F4               JP     GoToError
2963: F4A9             errReadOnlyDisk:
2964: F4A9 21 C4 F4               LD     HL,evReadOnlyDisk
2965: F4AC C3 BB F4               JP     GoToError
2966: F4AF             errReadOnlyFile:
2967: F4AF 21 C6 F4               LD     HL,evReadOnlyFile
2968: F4B2 C3 BB F4               JP     GoToError
2969: F4B5             errPermanent:
2970: F4B5 21 C0 F4               LD     HL,evPermanent
2971: F4B8 C3 BB F4               JP     GoToError
2972: F4BB         ;************Error message handler **********************
2973: F4BB             GoToError:
2974: F4BB         ;HL = .errorhandler, call subroutine
2975: F4BB 5E                     LD     E,(HL)
2976: F4BC 23                     INC    HL
2977: F4BD 56                     LD     D,(HL)               ; address of routine in DE
2978: F4BE EB                     EX     DE,HL
2979: F4BF E9                     JP     (HL)                 ; vector to subroutine
2980: F4C0         ;************ Error Vectors *****************************
2981: F4C0 CE F4       evPermanent: DW     erPermanent          ; pererr permanent error subroutine
2982: F4C2 DA F4       evSelection: DW     erSelection          ; selerr select error subroutine
2983: F4C4 E0 F4       evReadOnlyDisk: DW     erReadOnlyDisk       ; roderr ro disk error subroutine
2984: F4C6 E6 F4       evReadOnlyFile: DW     erReadOnlyFile       ; roferr ro file error subroutine
2985: F4C8         ;************Error Routines ******************************
2986: F4C8             erPermanentNoWait:
2987: F4C8 21 18 F5               LD     HL,emPermanent
2988: F4CB C3 BB F4               JP     GoToError
2989: F4CE             erPermanent:
2990: F4CE 21 18 F5               LD     HL,emPermanent
2991: F4D1 CD EF F4               CALL   displayAndWait       ; to report the error
2992: F4D4 FE 03                  CP     CTRL_C
2993: F4D6 CA 00 00               JP     Z,WarmBoot           ; reboot if response is CTRL_C
2994: F4D9 C9                     RET                         ; and ignore the error
2995: F4DA         ;
2996: F4DA             erSelection:
2997: F4DA 21 23 F5               LD     HL,emSelection
2998: F4DD C3 E9 F4               JP     waitB4boot           ; wait console before boot
2999: F4E0         ;
3000: F4E0             erReadOnlyDisk:
3001: F4E0 21 2F F5               LD     HL,emReadOnlyDisk
3002: F4E3 C3 E9 F4               JP     waitB4boot           ; wait console before boot
3003: F4E6         ;
3004: F4E6             erReadOnlyFile:
3005: F4E6 21 2A F5               LD     HL,emReadOnlyFile    ; drop through to wait for console
3006: F4E9         ;
3007: F4E9         ; wait for response before boot
3008: F4E9             waitB4boot:
3009: F4E9 CD EF F4               CALL   displayAndWait
3010: F4EC C3 00 00               JP     WarmBoot
3011: F4EF
3012: F4EF         ;report error to console, message address in HL
3013: F4EF             displayAndWait:
3014: F4EF E5                     PUSH   HL                   ; save message pointer
3015: F4F0 CD 4E F4               CALL   showCRLF             ; stack mssg address, new line
3016: F4F3 3A 38 F5               LD     A,(currentDisk)
3017: F4F6 C6 41                  ADD    A,ASCII_A
3018: F4F8 32 14 F5               LD     (emDisk),A           ; Problem disk name
3019: F4FB 01 08 F5               LD     BC,emDisk0
3020: F4FE CD 58 F4               CALL   Print                ; the error message
3021: F501 C1                     POP    BC
3022: F502 CD 58 F4               CALL   Print                ; error mssage tail
3023: F505 C3 E9 F3               JP     ConIn                ; to get the input character
3024: F508         ;ret
3025: F508         ;**************Error Messages*******************************
3026: F508 42 64 6F 73 20 45 72 72 20 4F 6E 20     emDisk0:   DB     'Bdos Err On '
3027: F514 20 3A 20 24     emDisk:    DB     ' : $'
3028: F518 42 61 64 20 53 65 63 74 6F 72 24     emPermanent: DB     'Bad Sector$'
3029: F523 53 65 6C 65 63 74 24     emSelection: DB     'Select$'
3030: F52A 46 69 6C 65 20     emReadOnlyFile: DB     'File '
3031: F52F 52 2F 4F 24     emReadOnlyDisk: DB     'R/O$'
3032: F533         ;*****************************************************************
3033: F533
3034: F533         ;********* file control block (fcb) constants ********************
3035: F533             fcbLength  EQU    32                   ; fcblen file control block size
3036: F533             fcbROfileIndex EQU    9                    ; high order of first type char
3037: F533             fcbHiddenfileIndex EQU    10                   ; invisible file in dir command
3038: F533             fcbExtIndex EQU    12                   ; extent number field index
3039: F533             fcbS1Index EQU    13                   ; S1 index
3040: F533             fcbS2Index EQU    14                   ; S2 data module number index
3041: F533             fcbRCIndex EQU    15                   ; record count field index
3042: F533             fcbDiskMapIndex EQU    16                   ; dskmap disk map field
3043: F533
3044: F533             highestRecordNumber EQU    RecordsPerExtent - 1 ; last record# in extent
3045: F533
3046: F533             dirEntriesPerRecord EQU    cpmRecordSize/fcbLength ; directory elts / record
3047: F533             dirEntryShift EQU    2                    ; log2(dirEntriesPerRecord)
3048: F533             dirEntryMask EQU    dirEntriesPerRecord-1
3049: F533             fcbShift   EQU    5                    ; log2(fcbLength)
3050: F533         ;
3051: F533
3052: F533
3053: F533
3054: F533             maxExtValue EQU    31                   ; largest extent number
3055: F533             moduleMask EQU    15                   ; limits module number value
3056: F533             writeFlagMask EQU    80h                  ; file write flag is high order fcbS2Index
3057: F533             nameLength EQU    15                   ; namlen name length
3058: F533
3059: F533             emptyDir   EQU    0E5H                 ; empty empty directory entry
3060: F533             NEXT_RECORD EQU    fcbLength            ; nxtrec
3061: F533             RANDOM_REC_FIELD EQU    NEXT_RECORD + 1      ;ranrec random record field (2 bytes)
3062: F533         ;
3063: F533         ;	reserved file indicators
3064: F533         ;	equ	11				; reserved
3065: F533         ;*****************************************************************
3066: F533         ;*****************************************************************
3067: F533
3068: F533         ;***common values shared between bdosi and bdos******************
3069: F533 00          currentUserNumber: DB     0                    ; usrcode current user number
3070: F534             paramDE:   DS     2                    ; ParamsDE information address
3071: F536             statusBDOSReturn: DS     2                    ; address value to return
3072: F538 FF          currentDisk: DB     -1                   ; curdsk current disk number
3073: F539             lowReturnStatus EQU    statusBDOSReturn     ; lret low(statusBDOSReturn)
3074: F539
3075: F539         ;********************* Local Variables ***************************
3076: F539         ;     ************************
3077: F539         ;     *** Initialized Data ***
3078: F539
3079: F539 E5          emptyFCB:  DB     emptyDir             ; efcb 0E5 = available dir entry
3080: F53A 00 00       ReadOnlyVector: DW     0                    ; rodsk read only disk vector
3081: F53C 00 00       loggedDisks: DW     0                    ; dlog	 logged-in disks
3082: F53E 80 00       InitDAMAddress: DW     DMABuffer            ; dmaad tbuff initial dma address
3083: F540
3084: F540         ;     *** Current Disk attributes ****
3085: F540         ; These are set upon disk select
3086: F540         ; data must be adjacent, do not insert variables
3087: F540         ; address of translate vector, not used
3088: F540         ; ca - currentAddress
3089: F540
3090: F540 00 00       caDirMaxValue: DW     0000H                ; cdrmaxa pointer to cur dir max value
3091: F542 00 00       caTrack:   DW     0000H                ; curtrka current track address
3092: F544 00 00       caSector:  DW     0000H                ; current Sector
3093: F546             caListSizeStart:
3094: F546 00 00       caDirectoryDMA: DW     0000H                ; buffa pointer to directory dma address
3095: F548 00 00       caDiskParamBlock: DW     0000H                ; dpbaddr current disk parameter block address
3096: F54A 00 00       caCheckSum: DW     0000H                ; checka current checksum vector address
3097: F54C 00 00       caAllocVector: DW     0000H                ; alloca current allocation vector address
3098: F54E             caListSizeEnd:
3099: F54E             caListSize EQU    caListSizeEnd - caListSizeStart
3100: F54E
3101: F54E         ;     ***** Disk Parameter Block *******
3102: F54E         ; data must be adjacent, do not insert variables
3103: F54E         ; dpb - Disk Parameter Block
3104: F54E             dpbStart:
3105: F54E 00 00       dpbSPT:    DW     0000H                ; sectpt sectors per track
3106: F550 00          dpbBSH:    DB     0000H                ; blkshf block shift factor
3107: F551 00          dpbBLM:    DB     00H                  ; blkmsk block mask
3108: F552 00          dpbEXM:    DB     00H                  ; extmsk extent mask
3109: F553 00 00       dpbDSM:    DW     0000H                ; maxall maximum allocation number
3110: F555 00 00       dpbDRM:    DW     0000H                ; dirmax largest directory number
3111: F557 00 00       dpbDABM:   DW     0000H                ; dirblk reserved allocation bits for directory
3112: F559 00 00       dpbCKS:    DW     0000H                ; chksiz size of checksum vector
3113: F55B 00 00       dpbOFF:    DW     0000H                ; offset offset tracks at beginning
3114: F55D             dpbEnd:
3115: F55D             dpbSize    EQU    dpbEnd - dpbStart
3116: F55D         ;
3117: F55D
3118: F55D         ;     ************************
3119: F55D
3120: F55D             paramE:    DS     BYTE                 ; ParamE low(info)
3121: F55E 00 00       caSkewTable: DW     0000H                ; tranv address of translate vector
3122: F560 00          fcbCopiedFlag: DB     00H                  ; fcb$copied set true if CopyFCB called
3123: F561 00          readModeFlag: DB     00H                  ; rmf read mode flag for OpenNextExt
3124: F562 00          directoryFlag: DB     00H                  ; dirloc directory flag in rename, etc.
3125: F563 00          seqReadFlag: DB     00H                  ; seqio  1 if sequential i/o
3126: F564 00          diskMapIndex: DB     00H                  ; dminx  local for DiskWrite
3127: F565 00          searchLength: DB     00H                  ; searchl search length
3128: F566 00 00       searchAddress: DW     0000H                ; searcha search address
3129: F568         ;tinfo:	ds	word							; temp for info in "make"
3130: F568 00          single:    DB     00H                  ; set true if single byte allocation map
3131: F569 00          fResel:    DB     00H                  ; resel reselection flag
3132: F56A 00          entryDisk: DB     00H                  ; olddsk disk on entry to bdos
3133: F56B 00          fcbDisk:   DB     00H                  ; fcbdsk disk named in fcb
3134: F56C 00          fcbRecordCount: DB     00H                  ; record count from current fcb
3135: F56D 00          extentValue: DB     00H                  ; extent number and dpbEXM from current fcb
3136: F56E 00 00       cpmRecord: DW     0000H                ; current virtual record - NEXT_RECORD
3137: F570 00 00       currentBlock: DW     0000H                ; arecord current actual record
3138: F572         ;
3139: F572         ;	local variables for directory access
3140: F572 00          dirBlockIndex: DB     00H                  ; directory block Index 0,1,2,3
3141: F573 00 00       dirEntryIndex: DW     00H                  ; directory entry Index  0,1,...,dpbDRM
3142: F575 00 00       dirRecord: DW     00H                  ; drec:	ds	word	;directory record 0,1,...,dpbDRM/4
3143: F577
3144: F577         ;********************** data areas ******************************
3145: F577 00          Cvalue:    DB     00H                  ; Reg C on BDOS Entry
3146: F578 00          compcol:   DB     0                    ; true if computing column position
3147: F579 00          startingColumn: DB     0                    ; strtcol starting column position after read
3148: F57A 00          columnPosition: DB     0                    ; column column position
3149: F57B 00          listeningToggle: DB     0                    ; listcp listing toggle
3150: F57C 00          kbchar:    DB     0                    ; initial key char = 00
3151: F57D             usersStack: DS     2                    ; entry stack pointer
3152: F57F             stackBottom: DS     STACK_SIZE * 2       ; stack size
3153: F5BF             bdosStack:
3154: F5BF         ;	end of Basic I/O System
3155: F5BF         ;-----------------------------------------------------------------;*****************************************************************
3156: F5BF
3157: F5BF         ;
3158: F5BF             CodeEnd:
3159: F5BF
           ************************   Xref   ************************
0000: $               F57F   0395 0425
2755: AddAtoHL        F3BF   1654 1963
1967: Allocate16Bit   EFDB   1961
0080: ASCII_A         0041   3017
0081: ASCII_C         0043
0082: ASCII_K         004B
0089: ASCII_LO_A      0061
0090: ASCII_LO_K      006B
0091: ASCII_LO_P      0070
0032: ASCII_MASK      007F   0832
0083: ASCII_N         004E
0084: ASCII_Q         0051
0085: ASCII_R         0052
0086: ASCII_W         0057
0087: ASCII_Y         0059
0067: ASCII_ZERO      0030
0061: ASTERISK        002A
0951: BackSpace       EB08   0955
0994: BackUp          EB37   0901 0952
0289: bcBoot          F600   0383
0292: bcConin         F609   0470 2815 2849 2853
0293: bcConout        F60C   0464 0997 1001 2917
0291: bcConst         F606   0467 2846
0297: bcHome          F618   1406
0294: bcList          F60F   0456 2923
0304: bcListst        F62D
0295: bcPunch         F612
0302: bcRead          F627   2317
0296: bcReader        F615
0305: bcSectran       F630
0298: bcSeldsk        F61B   1148
0301: bcSetdma        F624   1446
0300: bcSetsec        F621   1598
0299: bcSettrk        F61E   1411 1578
0290: bcWboot         F603
0303: bcWrite         F62A   2310
0146: BDOSBase        E800   0147 0149 0308
0115: BDOSE           0005   0116
0147: BDOSEntry       E806
0136: BDOSLength      0E00   0139 0149 0150
3153: bdosStack       F5BF   0331
0318: BdosStart       E809   0316
0050: BELL            0007
0149: BIOSBase        F600
0137: BIOSLength      0A00   0139
0109: BIOSPAGE        0002
0150: BIOSStart       F600   0289 0290 0291 0292 0293 0294 0295 0296 0297 0298 0299 0300 0301 0302 0303 0304 0305
1952: BlockOK         EFBF   1946
0246: BlockSize       0800   0268
0028: BYTE            0001   3120
3097: caAllocVector   F54C   1084 1236 1248 1371
3096: caCheckSum      F54A   1617
3094: caDirectoryDMA  F546   1167 1440 1641 1652 2662
3090: caDirMaxValue   F540   1156 1218 1255 1671
3095: caDiskParamBlock F548   1108 1171
1609: CalculateCheckSum EE0B   1499
3099: caListSize      0008   1168
3098: caListSizeEnd   F54E   3099
3093: caListSizeStart F546   3099
0088: CARET           005E   1015
1009: CaretCout       EB44   0934 0970
3092: caSector        F544   1162 1418 1517 1587
3121: caSkewTable     F55E   1166
3091: caTrack         F542   1159 1414 1521 1581
0144: CCPEntry        E000   0146 0150
0135: CCPLength       0800   0139 0146 0150
1826: CheckRODirectory EF0B   2128 2179
1831: CheckROFile     EF0E   1910
1840: CheckWrite      EF18   1908 2113 2138 2171
2439: ClearModuleNum  F231   1742 1763 1809
2189: CloseDirEntry   F115   0653 1750 2045
2210: CloseDirEntry1  F13A   2256
2224: CloseDirEntry2  F148   2221
2230: CloseDirEntry3  F14E   2226
2236: CloseDirEntry4  F155   2213
2252: CloseDirEntry5  F16A   2233
2277: CloseDirEntryEnd F184   2266
2284: CloseDirEntryError F18D   2232 2244 2249
3158: CodeEnd         F5BF
0309: CodeStart       E800
0068: COLON           003A
3148: columnPosition  F57A   0815 0847 0897 0945 1030 2876 2928
0063: COMMA           002C
2643: CompareExtents  F34D   2588
3146: compcol         F578   0848 0941 0947 0953 2908
1639: ComputeCheckSum EE33   1616
1643: ComputeCheckSum0 EE39   1647
0121: ComTail         0080   0122
0123: ComTailChars    0082
0122: ComTailCount    0081   0123
2842: ConBreak        F411   0503 2914
2859: ConBreak0       F430   2851
2862: ConBreak1       F433   2845
2808: ConIn           F3E9   0831 2832 3023
2831: ConsoleInWithEcho F403   0434
2907: ConsoleOut      F466   0990 1016 1025 1029 2872 2881 2887 2889
2925: ConsoleOut1     F480   2910
2675: CopyDir         F371   1728 2131 2672
2661: CopyDirEntryToUser F35E   1768 1778
2669: CopyFCB         F36A   2165
3136: cpmRecord       F56E   1696 1711 1867 1877 1912 1996 2033 2423 2694
0223: cpmRecordSize   0080   0225 0228 0230 1640 2665 3046
0053: CR              000D   0835 0989 2819 2886
0036: CTRL_C          0003   0974 2854 2992
0037: CTRL_E          0005   0868
0038: CTRL_H          0008   0839 1000 2825 2941
0039: CTRL_K          000B
0040: CTRL_L          000C
0041: CTRL_P          0010   0879
0042: CTRL_R          0012   0914
0043: CTRL_S          0013   2850
0044: CTRL_U          0015   0906
0045: CTRL_X          0018   0891
0046: CTRL_Z          001A
3137: currentBlock    F570   1506 1513 1953 2400 2405 2414 2427
3072: currentDisk     F538   1047 1070 1115 1124 1146 1194 1848 2464 3016
3069: currentUserNumber F533   0514 0520 1273 2473
3145: Cvalue          F577   0320
0064: DASH            002D
0257: DataBlocks      02C7   0267
0256: DataSectors     0B1C   0257
2170: DeleteFile      F0F3   1785
2174: DeleteFile1     F0FB   2186
2762: DEminusHL2HL    F3C4   1476 1613
3140: dirBlockIndex   F572   1492 1653
0228: DirBuffSize     0080
0243: DirectoryBlockCount 0002   0268
0230: DirectoryEntryPerRecord 0004   0271
3124: directoryFlag   F562   2434 2532 2606
3046: dirEntriesPerRecord 0004   3048
3141: dirEntryIndex   F573   1432 1452 1472 1474 1484 1503 1669 2602
3048: dirEntryMask    0003   1485 2603
3047: dirEntryShift   0002   1504
0227: DirEntrySize    0020   0230 0268
2433: DirLocationToReturnLoc F22A   1103 1786 1820
3142: dirRecord       F575   1507 1610 1619
0215: DiskCommandBlock 0046
0214: DiskControlByte 0045
0217: DiskControlTable 0040
1894: DiskEOF         EF6D   1874 1881 1887
0395: diskf           000B
3126: diskMapIndex    F564   1930 1960
1862: DiskRead        EF32   0582
0219: DiskReadCode    0001
0224: diskSectorSize  0200   0225 0246 0254
0213: DiskStatusLocation 0043
1904: DiskWrite       EF75   0589
1919: DiskWrite1      EF92   1914
1977: DiskWrite2      EFE3   1965
1983: DiskWrite3      EFE5   1923
2004: DiskWrite4      F005   1999
2015: DiskWrite5      F012   2008
2034: DiskWrite6      F030   2030
2036: DiskWrite7      F032   2018 2022
0220: DiskWriteCode   0002
1899: DiskWriteSeq    EF70   1801
3013: displayAndWait  F4EF   2991 3009
0126: DMABuffer       0080   1048 3082
0057: DOLLAR          0024   1279 2895
1846: DoNotWrite      EF1F   1841 2192
0269: dpb3hdAL0       00C0
0270: dpb3hdAL1       0000
0265: dpb3hdBLM       000F
0264: dpb3hdBSH       0004
0271: dpb3hdCKS       0020
0268: dpb3hdDRM       007F   0271
0267: dpb3hdDSM       02C6
0266: dpb3hdEXM       0000
0273: dpb3hdNOH       0002
0272: dpb3hdOFF       0001
0263: dpb3hdSPT       0090
3107: dpbBLM          F551   2421
3106: dpbBSH          F550   2413 2692
3112: dpbCKS          F559   1612
3111: dpbDABM         F557   1246
3110: dpbDRM          F555   1216 1470
3109: dpbDSM          F553   1176 1229 2363
3114: dpbEnd          F55D   3115
3108: dpbEXM          F552   1701 2059 2646
3113: dpbOFF          F55B   1407 1574
3115: dpbSize         000F   1174
3105: dpbSPT          F54E   1539 1553
3104: dpbStart        F54E   1173 3115
0427: DUMMY           E8B9   0422 0423
2818: EchoNonGraphicCharacter F3F4   1011 2833
3027: emDisk          F514   3018
3026: emDisk0         F508   3019
3028: emPermanent     F518   2987 2990
3059: emptyDir        00E5   1269 2181 2552 3079
3079: emptyFCB        F539   2141
3031: emReadOnlyDisk  F52F   3001
3030: emReadOnlyFile  F52A   3005
3029: emSelection     F523   2997
0130: END_OF_FILE     001A
2601: EndDirElementSearch F31E   2567
1451: EndOfDirectory  ED54   0732 1265 1724 2047 2082 2091 2125 2145 2176 2200 2483 2546
0034: EndOfMessage    0000
0986: EndRead         EB30   0836 0838
3132: entryDisk       F56A   0368 2465
0285: EOD             FFFF   1431
0072: EQUAL_SIGN      003D
2989: erPermanent     F4CE   2981
2986: erPermanentNoWait F4C8   2312 2319
3000: erReadOnlyDisk  F4E0   2983
3004: erReadOnlyFile  F4E6   2984
2969: errPermanent    F4B5
2963: errReadOnlyDisk F4A9   1843
2966: errReadOnlyFile F4AF   1837
2960: errSelect       F4A3   1131
2996: erSelection     F4DA   2982
2981: evPermanent     F4C0   2970
2983: evReadOnlyDisk  F4C4   2964
2984: evReadOnlyFile  F4C6   2967
2982: evSelection     F4C2   2961
0055: EXCLAIM_POINT   0021
3135: extentValue     F56D   1703 2706
0023: FALSE           0000   0587 1182 1905 2544
0118: FCB1            005C   0119
0119: FCB2            006C
3122: fcbCopiedFlag   F560   2044 2062 2279
3133: fcbDisk         F56B   0334 0363 2467
3042: fcbDiskMapIndex 0010   1297 1300 1956 2120 2129 2203 2209 2733
3038: fcbExtIndex     000C   0636 0660 0719 0771 1721 1727 2050 2070 2115 2130 2172 2258 2270 2501 2576 2625
3037: fcbHiddenfileIndex 000A
3035: fcbLength       0020   1300 2153 2209 2258 2671 3046 3060
3041: fcbRCIndex      000F   0736 1685 1688 2270 2504 2523
3134: fcbRecordCount  F56C   1699 1715 1868 1997
3036: fcbROfileIndex  0009   1832
3039: fcbS1Index      000D   2160 2573
3040: fcbS2Index      000E   0642 0663 0788 2070 2447
3049: fcbShift        0005   1486
0163: fCloseFile      0010
0154: fConsoleIn      0001
0155: fConsoleOut     0002
0166: fDeleteFile     0013
0466: fDirectConIn    E8D7   0463
0158: fGetConsoleStatus 000B
0172: fGetCurrentDisk 0019
0171: fGetLoginVector 0018
0174: fGetSetUserNumber 0020
0159: fGetVersion     000C
1941: FirstBlock      EFB1   1933
0169: fMakeFile       0016
0162: fOpenFile       000F
0156: fPrintString    0009
0167: fReadSeq        0014
0157: fReadString     000A
0170: fRenameFile     0017
3131: fResel          F569   0335 0357 2455
0160: fResetSystem    000D
0164: fSearchFirst    0011
0165: fSearchNext     0012
0161: fSelectDisk     000E
0173: fSetDMA         001A
0425: functionCount   0028   0340
0382: functionTable   E867   0344 0395 0425
0168: fWriteSeq       0015
1344: GetAllocBit     ECEB   1386 2356 2374
1375: GetAllocBitl    ED0C   1378
2395: GetBlockNumber  F1FE   1885 1920
2345: GetClosestBlock F1C4   1942
1651: GetDirElementAddress EE40   0735 1268 1295 1827 2180 2204 2492 2560 2681
2742: GetDiskMap16Bit F3B9   2738
2691: GetDiskMapIndex F386   1929 2396
2695: GetDiskMapIndex1 F38D   2699
2707: GetDiskMapIndex2 F39B   2714
2717: GetDiskMapIndex3 F3A4   2711
2731: GetDiskMapValue F3A6   1937 2399
2623: GetExtentAddress F338   1700 2488
1683: GetFcbAddress   EE5F   1694 1708
0718: GetFileSize     E9E7   0553
0731: GetFileSize1    E9F9   0759
0757: GetFileSize2    EA1B   0750
0760: GetFileSizeExit EA21   0733
2445: GetModuleNum    F237   0692 2010 2195 2440 2631
0765: GetRandomRecordPosition EA23   0707 0737
0895: GoBack          EABD   0902
2973: GoToError       F4BB   2962 2965 2968 2971 2988
0073: GREATER_THAN    003E
0056: HASH_TAG        0023   2871
3044: highestRecordNumber 007F   1913 2017
1405: Home            ED24   1253 2538
3082: InitDAMAddress  F53E   1049 1078 1436 2664
1228: InitDisk        EC5F   1141
1238: InitDisk0       EC6D   1244
1262: InitDisk1       EC8E   1271 1289
1284: InitDisk2       ECB2   1275 1280
0110: IOBYTE          0003   0476 0482
2404: IsAllocated     F20B   1886 1921
3150: kbchar          F57C   2809 2843 2861
0059: L_PAREN         0028
0076: LEFT_ARROW      005F
0092: LEFT_CURLY      007B
0139: LengthInBytes   2000   0140 0144 0254
0140: LengthInK       0009
0071: LESS_THAN       003C
0052: LF              000A   0837 2821 2888 2947
0916: LineLengthOrRepeat EADF   0850
3149: listeningToggle F57B   0883 2921
0026: LO_NIBBLE_MASK  000F   0519 0784
3081: loggedDisks     F53C   1045 1063 1123 1136 1140
3073: lowReturnStatus F536   0515 0657 0667 0678 0685 0698 1071 1283 1879 1949 1984 2027 2101 2191 2285 2435 2604 2619 2639 2957
2137: MakeNewFile     F0BD   0676 1811 2089
2155: MakeNewFile1    F0DF   2159
3054: maxExtValue     001F   2054 2656
0142: MemorySize      0040   0144
2324: Merge           F1B6   2237 2239
3055: moduleMask      000F   2075
2794: Move            F3DF   1169 1175 2497 2666 2683
2796: Move0           F3E0   2803
0255: myOffset        0001   0256 0272
3057: nameLength      000F   1765 2080 2151 2153 2198 2481
1606: NewCheckSum     EE09   2297
3060: NEXT_RECORD     0020   0631 0706 1688 2495 3061
2471: NoSelect        F264   2462
2946: NotBackSpace    F497   2942
0980: NotCtntl_C      EB2C   0976
0877: NotCtntl_E      EAA6   0869
0852: NotCtntl_H      EA85   0840
0890: NotCtntl_P      EAB7   0880
0959: NotCtntl_R      EB15   0915
0912: NotCtntl_U      EADA   0907
0905: NotCtntl_X      EACE   0892
0867: NotRubout       EA95   0854
0048: NULL            0000
0239: NumberOfHeads   0002   0250 0252 0263 0273
0236: NumberOfLogicalDisks 0004
0025: OFF             0000
0024: ON              FFFF
2480: OpenFile        F26D   0666 1744
2487: OpenFileCopyFCB F276   2097
2042: OpenNextExt     F035   1875 2025
2079: OpenNextExt1    F069   2064
2096: OpenNextExt2    F087   2066 2083
2098: OpenNextExt3    F08A   2093
2105: OpenNextExtError F092   2076 2087 2092
2069: OpenNextModule  F05E   2056
2521: OpenRecordCount F2A7   2517 2519
3070: paramDE         F534   0322 0361 0488 0600 0705 0722 0817 1077 1684 1758 1775 1909 1955 2049 2118 2139 2142 2147 2207 2446 2456 2474 2494 2522 2535 2624 2678 2732
3120: paramE          F55D   0325 0369 0511 1114 2460
0058: PERCENT         0025
0065: PERIOD          002E
0113: Pg0CurentDisk   0004
0112: Pg0CurentUser   0004   0113
0062: PLUS_SIGN       002B
2893: Print           F458   0491 2902 3020 3022
0999: PutCntl_H       EB3F   0995
0074: QMARK           003F   1760 2569
1766: QMarkSelect     EECD   1761
0060: R_PAREN         0029
0106: RAM             0000   0108 0109 0110 0112 0115 0118 0121 0126 0128
3061: RANDOM_REC_FIELD 0021   0602 0708 0723
0579: RandomDiskRead  E931   0534
0586: RandomDiskWrite E93A   0546
0596: RandomSeek      E943   0581 0588
0650: RandomSeekClose E987   0640
0695: RandomSeekError E9CC   0629
0688: RandomSeekErrorBadSeek E9C5   0659 0675 0680
0682: RandomSeekExit  E9BF   0649 0669
2316: ReadBuffer      F1AE   1464 1891
1469: ReadDirectory   ED66   1264 2545
1483: ReadDirectory0  ED7B   1477
1487: ReadDirectory1  ED82   1490
1462: ReadDirRecord   ED5D   1497
0961: ReadEcho        EB15
0965: ReadEcho1       EB18   0864
3123: readModeFlag    F561   1864 1906 2085
0827: ReadNext        EA5E   0844 0858 0888 0983
0830: ReadNext0       EA60   0876 0943 0956
3080: ReadOnlyVector  F53A   1044 1095 1209 1214 1847
1856: ReadSeq         EF2D   1793
0814: ReadString      EA50   0498 0899 0911
1884: RecordOK        EF57   1871
0248: RecordsPerBlock 0010
0232: RecordsPerExtent 0080   1873 2520 3044
0225: recordsPerSector 0004   0248 0263
2112: Rename          F098   1819
2124: Rename1         F0A9   2134
0925: Repeat          EAE7   0937
0938: Repeat1         EAF9   0928
2453: Reselect        F240   0533 0545 0552 1101 1743 1749 1764 1776 1784 1792 1800 1810 1818
0356: RetCaller       E840   0336
0373: RetDiskMon      E85D   0359 0365 0469
2380: ReturnBlockNumber F1F2   2358 2376
2390: ReturnBlockZero F1FA   2368
1396: RotateAndReplace ED1D   1390 1399 2384
0077: RUBOUT          007F   0853 2929
1294: ScanDiskMap     ECBD   1287 2183
1302: ScanDiskMap0    ECC7   1334
1318: ScanDiskMap1    ECDA   1310
1327: ScanDiskMap2    ECE0   1316
2530: Search4DirElement F2B0   0720 1722 1767 2081 2116 2144 2173 2199 2482
2585: Search4Ext      F30E   2578
2543: Search4NextDirElement F2C8   0758 1729 1777 2133 2185 2539 2581 2590
2559: Search4NextDirElement1 F2E5   2553
2564: Search4NextLoop F2EE   2598
2593: Search4NextOK   F317   2570 2574 2582
3128: searchAddress   F566   1774 2536 2549
2616: SearchDone      F32F   2547 2558
3127: searchLength    F565   2533 2561
0277: SectorMask      0003
0242: SectorsPerBlock 0004   0246 0248 0251 0257 0277
0252: SectorsPerCylinder 0024   0255 0256
0241: SectorsPerTrack 0012   0250 0252 0263
1510: Seek            EDA8   1508 1890 1990
1531: Seek0           EDBB   1548
1550: Seek1           EDD1   1536 1565
1567: Seek2           EDE3   1559
2685: SeekAndCopy     F380
2290: SeekCopy        F192   2280
1502: SeekDir         ED97   1496 2291 2686
1122: Select          EBC9   1051 1119
1113: SelectCurrent   EBBD   0370 1057 2470
1145: SelectDisk      EBED   1129
1184: SelectDisk1     EC31   1181
0070: SEMICOLON       003B
3125: seqReadFlag     F563   0598 1709 1858 1901 2020
2412: SetActualRecordAdd F211   1889 1989
2416: SetActualRecordAdd1 F217   2419
1384: SetAllocBit     ED12   1330
1720: SetAttributes   EE95   1102
1723: SetAttributes1  EE9A   1730
1192: SetCurrentDiskBit EC35   1139 1213
1435: SetDataDMA      ED45   1050 1079 1465 2301
1439: SetDirDMA       ED4B   1463 2298
1657: SetDirectoryEntry EE49   1288 2163
1208: SetDiskReadOnly EC48   1090 1630
1442: SetDMA          ED4E   1437
1430: SetEndDirectory ED3E   1260 1479 2537 2617
2630: SetFileWriteFlag F340   0700 2107 2167 2499
2637: SetLowReturnTo1 F347   1895 1915 2106
1634: SetNewCheckSum  EE31   1623
0704: SetRandomRecord E9D4   0559
1693: SetRecordVars   EE6C   1866 1911 2099
0518: SetUserNumber   E914   0513
2785: ShiftLeftHLbyC  F3D8   1197
2787: ShiftLeftHLbyC0 F3D9   2791
2771: ShiftRightHLbyC F3CB   1126 1232 1505 1850
2773: ShiftRightHLbyC0 F3CC   2783
2885: showCRLF        F44E   0873 2873 3015
2870: showHashCRLF    F436   0909 0919
2875: showHashCRLF0   F43E   2882
3130: single          F568   1178 1308 1958 2211 2736
0066: SLASH           002F
0049: SOH             0001
0054: SPACE           0020   0996 1028 2827 2880 2932
0284: STACK_SIZE      0020   3152
3152: stackBottom     F57F
3147: startingColumn  F579   0816 0875 0896 2877
3071: statusBDOSReturn F536   0327 0376 0435 0446 0471 0477 0504 1064 1085 1096 1109 3073
1668: StillInDirectory EE52   1628 1658 2556
0254: SystemSectors   0011   0255
0051: TAB             0009   1024 2823
1022: TabOut          EB55   0440 1012 2838 2900
1027: TabOut0         EB5B   1032
2348: TestLeft        F1C6   2379
2362: TestRight       F1D7   2351
0116: TopRAM          0007
0251: TotalNumberOfBlocks 02D0
0250: TotalNumberOfSectors 0B40   0251 0256
0128: TPA             0100
0240: TracksPerHead   0050   0250
0022: TRUE            FFFF   0580 1179 1185 1263 1607 1863 2278 2454 2864
0075: UNDER_SCORE     005F
1707: UpdateRecordVars EE83   1892 2024 2037
3151: usersStack      F57D   0330 0374
1748: vCloseFile      EEB4   0400
0551: vComputeFileSize E926   0419
0433: vConsoleIn      E8BA   0384
0439: vConsoleOut     E8C1   0385
1783: vDeleteFile     EEE2   0403
0460: vDirectConIO    E8CE   0389
0283: VERSION         0020   2956
1756: vFindFirst      EEBA   0401
1773: vFindNext       EED3   0402
1083: vGetAllocAddr   EB9C   0411
0502: vGetConsoleStatus E8FE   0394
1069: vGetCurrentDisk EB8C   0409
1107: vGetDiskParamBlock EBB6   0415
0475: vGetIOBYTE      E8E5   0390
1062: vGetLoginVector EB85   0408
1094: vGetRoVector    EBA6   0413
0510: vGetSetUserNumber E905   0416
2955: vGetVersion     F49D   0396
0455: vListOut        E8CA   0388
1808: vMakeFile       EEF9   0406
1741: vOpenFile       EEAB   0399
0487: vPrintString    E8F1   0392
0450: vPunchOut       E8C9   0387
0444: vReaderIn       E8C5   0386
0532: vReadRandom     E91A   0417
1791: vReadSeq        EEEB   0404
0497: vReadString     E8FA   0393
1817: vRenameFile     EF02   0407
0564: vResetDrive     E92F   0421
1042: vResetSystem    EB69   0397
1056: vSelectDisk     EB82   0398
1076: vSetDMA         EB93   0410
1100: vSetFileAttributes EBAD   0414
0481: vSetIOBYTE      E8EC   0391
0558: vSetRandomRecord E92C   0420
1089: vWriteProtectDisk EBA3   0412
0544: vWriteRandom    E920   0418
0572: vWriteRandom0Fill E930   0424
1799: vWriteSeq       EEF2   0405
3008: waitB4boot      F4E9   2998 3002
0108: WarmBoot        0000   0978 2855 2993 3010
0029: WORD            0002
0188: WriteAllocated  0000   1922
2309: WriteBuffer     F1A6   1993 2300
2296: WriteDir        F198   2184 2292 2687
0189: WriteDirectory  0001
3056: writeFlagMask   0080   2196 2632
0190: WriteUnallocated 0002   1978
0033: ZERO            0000
