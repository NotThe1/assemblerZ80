0001: 0000         ;     File created by MakeZ80Source on Tue Sep 18 12:43:09 EDT 2018 from:
0002: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\BIOS.asm
0003: 0000         ; BIOS.asm
0004: 0000
0005: 0000         ; 2017-03-31 Added List out functionality for List Device
0006: 0000         ; 2017-03-02 Refactored the CP/M Suite
0007: 0000         ; 2017-02-08 All disk drives are 3.5 DH disks (1.44MB)
0008: 0000         ; 2014-01-16
0009: 0000         ; 2014-03-14  :  Frank Martyn
0010: 0000
0011: 0000                        Include ./stdHeader.Z80
0012: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0013: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:01 EDT 2018 from:
0014: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\stdHeader.asm
0015: 0000         ; stdHeader.asm
0016: 0000         ; standard equates
0017: 0000
0018: 0000         ; 2017-03-02 Refactored the CP/M Suite
0019: 0000
0020: 0000
0021: 0000             TRUE       EQU    -1                   ; not false
0022: 0000             FALSE      EQU    0000H
0023: 0000             ON         EQU    -1
0024: 0000             OFF        EQU    0000H
0025: 0000             LO_NIBBLE_MASK EQU    0FH                  ; mask used to obtain the bytes low four bits
0026: 0000
0027: 0000             BYTE       EQU    1                    ; number of bytes for "byte" type
0028: 0000             WORD       EQU    2                    ; number of bytes for "word" type
0029: 0000
0030: 0000
0031: 0000             ASCII_MASK EQU    7FH                  ; Ascii mask 7 bits
0032: 0000             ZERO       EQU    00H                  ; Zero
0033: 0000             EndOfMessage EQU    00H
0034: 0000
0035: 0000             CTRL_C     EQU    03H                  ; ETX
0036: 0000             CTRL_E     EQU    05H                  ; physical eol
0037: 0000             CTRL_H     EQU    08H                  ; backspace
0038: 0000             CTRL_K     EQU    0BH                  ; VT - Vertical tab
0039: 0000             CTRL_L     EQU    0CH                  ; FF - Form feed
0040: 0000             CTRL_P     EQU    10H                  ; prnt toggle
0041: 0000             CTRL_R     EQU    12H                  ; repeat line
0042: 0000             CTRL_S     EQU    13H                  ; X-OFF stop/start screen
0043: 0000             CTRL_U     EQU    15H                  ; line delete
0044: 0000             CTRL_X     EQU    18H                  ; =ctl-u
0045: 0000             CTRL_Z     EQU    1AH                  ; end of file
0046: 0000
0047: 0000             NULL       EQU    00H                  ; Null
0048: 0000             SOH        EQU    01H                  ; Start of Heading
0049: 0000             BELL       EQU    07H                  ; Bell
0050: 0000             TAB        EQU    09H                  ; Tab
0051: 0000             LF         EQU    0AH                  ; Line Feed
0052: 0000             CR         EQU    0DH                  ; Carriage Return
0053: 0000             SPACE      EQU    20H                  ; Space
0054: 0000             EXCLAIM_POINT EQU    21H                  ; Exclamtion Point
0055: 0000             HASH_TAG   EQU    23H                  ; Sharp sign #
0056: 0000             DOLLAR     EQU    24H                  ; Dollar Sign
0057: 0000             PERCENT    EQU    25H                  ; Percent Sign
0058: 0000             L_PAREN    EQU    28H                  ; Left Paenthesis (
0059: 0000             R_PAREN    EQU    29H                  ; Right Paenthesis )
0060: 0000             ASTERISK   EQU    2AH                  ; Asterisk *
0061: 0000             PLUS_SIGN  EQU    2BH                  ; Plus sign +
0062: 0000             COMMA      EQU    2CH                  ; Comma
0063: 0000             DASH       EQU    2DH                  ; Dash Hyphen -
0064: 0000             PERIOD     EQU    2EH                  ; Period
0065: 0000             SLASH      EQU    2FH                  ; /
0066: 0000             ASCII_ZERO EQU    30H                  ; zero
0067: 0000             COLON      EQU    3AH                  ; Colon
0068: 0000
0069: 0000             SEMICOLON  EQU    3BH                  ; Semi Colon
0070: 0000             LESS_THAN  EQU    3CH                  ; Less Than <
0071: 0000             EQUAL_SIGN EQU    3DH                  ; Equal Sign
0072: 0000             GREATER_THAN EQU    3EH                  ; Greater Than >
0073: 0000             QMARK      EQU    3FH                  ; Question Mark
0074: 0000             UNDER_SCORE EQU    5FH                  ; under score _
0075: 0000             LEFT_ARROW EQU    5FH                  ; Left Arrow ?
0076: 0000             RUBOUT     EQU    7FH                  ; Delete Key
0077: 0000
0078: 0000
0079: 0000             ASCII_A    EQU    'A'
0080: 0000             ASCII_C    EQU    'C'
0081: 0000             ASCII_K    EQU    'K'
0082: 0000             ASCII_N    EQU    'N'
0083: 0000             ASCII_Q    EQU    'Q'
0084: 0000             ASCII_R    EQU    'R'
0085: 0000             ASCII_W    EQU    'W'
0086: 0000             ASCII_Y    EQU    'Y'
0087: 0000             CARET      EQU    '^'
0088: 0000             ASCII_LO_A EQU    'a'
0089: 0000             ASCII_LO_K EQU    'k'
0090: 0000             ASCII_LO_P EQU    'p'
0091: 0000             LEFT_CURLY EQU    '{'                  ; Left curly Bracket
0092: 0000
0093: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0094: 0000                        Include ./osHeader.Z80
0095: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0096: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:25:47 EDT 2018 from:
0097: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\osHeader.asm
0098: 0000         ; osHeader.asm
0099: 0000
0100: 0000         ; 2017-03-02 Refactored the CP/M Suite
0101: 0000
0102: 0000         ; Contains the Equates used by the CP/M system
0103: 0000
0104: 0000         ;------------------------Page Zero Constants ---------------------------------
0105: 0000             RAM        EQU    0                    ; Start of RAM ( and the Base page)
0106: 0000
0107: 0000             WarmBoot   EQU    RAM + 0              ; Contains a JMP instruction to warm boot in BIOS
0108: 0000             BIOSPAGE   EQU    RAM + 2              ; BIOS Jump Vector Page
0109: 0000             IOBYTE     EQU    RAM + 3              ; Input/Output redirection byte
0110: 0000
0111: 0000             Pg0CurentUser EQU    RAM + 4              ; Current user ( bits 7-4)
0112: 0000             Pg0CurentDisk EQU    Pg0CurentUser        ; Default logical disk (bits 0-3)
0113: 0000
0114: 0000             BDOSE      EQU    RAM + 5              ; Contains a JMP to BDOS entry
0115: 0000             TopRAM     EQU    BDOSE+2              ; Top page of usable RAM
0116: 0000
0117: 0000             FCB1       EQU    RAM + 05CH           ; File Control Block #1
0118: 0000             FCB2       EQU    FCB1 + 16            ; File Control Block #2
0119: 0000
0120: 0000             ComTail    EQU    RAM + 080H           ; Complete command tail
0121: 0000             ComTailCount EQU    ComTail + 1          ; Count of the number of char in tail
0122: 0000             ComTailChars EQU    ComTailCount + 1     ; Complete Command tail up-cased, w/o trailing CR
0123: 0000         ;-----------------------------------------------------------------------
0124: 0000
0125: 0000             DMABuffer  EQU    RAM + 080H           ; Default "DMA" address used as buffer
0126: 0000         ;-----------------------------------------------------------------------
0127: 0000             TPA        EQU    RAM + 0100H          ; Start of Transient program Area
0128: 0000         ;-----------------------------------------------------------------------
0129: 0000             END_OF_FILE EQU    1AH                  ; end of file
0130: 0000         ;-----------------------------------------------------------------------
0131: 0000
0132: 0000         ;--------------- CP/M Constants -----------------------------------------
0133: 0000
0134: 0000             CCPLength  EQU    0800H                ; Constant
0135: 0000             BDOSLength EQU    0E00H                ; Constant 0E00H
0136: 0000             BIOSLength EQU    0A00H                ; Constant 0900H
0137: 0000
0138: 0000             LengthInBytes EQU    CCPLength + BDOSLength + BIOSLength
0139: 0000             LengthInK  EQU    (LengthInBytes/1024) + 1
0140: 0000
0141: 0000             MemorySize EQU    64
0142: 0000
0143: 0000             CCPEntry   EQU    (MemorySize * 1024) - LengthInBytes
0144: 0000
0145: 0000             BDOSBase   EQU    CCPEntry + CCPLength
0146: 0000             BDOSEntry  EQU    BDOSBase + 6
0147: 0000
0148: 0000             BIOSBase   EQU    BDOSBase + BDOSLength
0149: 0000             BIOSStart  EQU    CCPEntry + CCPLength + BDOSLength
0150: 0000         ;-----------------------------------------------------------------------
0151: 0000
0152: 0000         ;------------------- BDOS System Call Equates --------------------------
0153: 0000             fConsoleIn EQU    01H                  ; rcharf - Console Input
0154: 0000             fConsoleOut EQU    02H                  ; pcharf - Console Output
0155: 0000             fPrintString EQU    09H                  ; pbuff	- Print String
0156: 0000             fReadString EQU    0AH                  ; rbuff	- Read Console String
0157: 0000             fGetConsoleStatus EQU    0BH                  ; breakf - Get Console Status
0158: 0000             fGetVersion EQU    0CH                  ; liftf	- Return Version Number
0159: 0000             fResetSystem EQU    0DH                  ; initf	- Reset Disk System
0160: 0000             fSelectDisk EQU    0EH                  ; self	- Select Disk
0161: 0000             fOpenFile  EQU    0FH                  ; openf	- Open File
0162: 0000             fCloseFile EQU    10H                  ; closef - Close File
0163: 0000             fSearchFirst EQU    11H                  ; searf	- Search For First
0164: 0000             fSearchNext EQU    12H                  ; searnf - Search for Next
0165: 0000             fDeleteFile EQU    13H                  ; delf - Delete File
0166: 0000             fReadSeq   EQU    14H                  ; dreadf - Read Sequential
0167: 0000             fWriteSeq  EQU    15H                  ; dwritf - Write Sequential
0168: 0000             fMakeFile  EQU    16H                  ; makef	- Make File
0169: 0000             fRenameFile EQU    17H                  ; renf	- Rename File
0170: 0000             fGetLoginVector EQU    18H                  ; logf	- Return Login Vector
0171: 0000             fGetCurrentDisk EQU    19H                  ; cself	- Return Current Disk
0172: 0000             fSetDMA    EQU    1AH                  ; dmaf	- Set DMA address
0173: 0000             fGetSetUserNumber EQU    20H                  ; userf	- Set/Get User Code
0174: 0000         ;-----------------------------------------------------------------------
0175: 0000
0176: 0000
0177: 0000
0178: 0000
0179: 0000
0180: 0000         ;*******************************************************************************
0181: 0000         ; These are the values handed over by the BDOS when it calls the Writer operation
0182: 0000         ; The allocated.unallocated indicates whether the BDOS is set to write to an
0183: 0000         ; unallocated allocation block (it only indicates this for the first 128 byte
0184: 0000         ; sector write) or to an allocation block that has already been allocated to a
0185: 0000         ; file. The BDOS also indicates if it is set to write to the file directory
0186: 0000         ;*******************************************************************************
0187: 0000             WriteAllocated EQU    00H
0188: 0000             WriteDirectory EQU    01H
0189: 0000             WriteUnallocated EQU    02H
0190: 0000
0191: 0000
0192: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0193: 0000                        Include ./diskHeader.Z80
0194: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0195: 0000         ;     File created by MakeZ80Source on Mon Sep 17 16:26:22 EDT 2018 from:
0196: 0000         ;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\diskHeader.asm
0197: 0000         ; diskHeader.asm
0198: 0000
0199: 0000         ; 2017-03-02 Refactored the CP/M Suite
0200: 0000
0201: 0000         ; needs osHeader.asm declared before this is used !!!!!!!
0202: 0000
0203: 0000         ; Contains the Equates used by the CP/M system to handle disks
0204: 0000
0205: 0000
0206: 0000         ;*******************************************************************************
0207: 0000         ;
0208: 0000         ;     Disk related values
0209: 0000         ;
0210: 0000         ;
0211: 0000         ;*******************************************************************************
0212: 0000             DiskStatusLocation EQU    043H                 ; status after disk I/O placed here
0213: 0000             DiskControlByte EQU    045H                 ; control byte for disk I/O
0214: 0000             DiskCommandBlock EQU    046H                 ; Control Table Pointer
0215: 0000         ; for boot
0216: 0000             DiskControlTable EQU    0040H
0217: 0000
0218: 0000             DiskReadCode EQU    01H                  ; Code for Read
0219: 0000             DiskWriteCode EQU    02H                  ; Code for Write
0220: 0000
0221: 0000
0222: 0000             cpmRecordSize EQU    080H                 ; (128) record size that CP/M uses
0223: 0000             diskSectorSize EQU    200H                 ; (512) size of physical disk I/O
0224: 0000             recordsPerSector EQU    diskSectorSize/cpmRecordSize
0225: 0000
0226: 0000             DirEntrySize EQU    20H                  ; (32)
0227: 0000             DirBuffSize EQU    cpmRecordSize
0228: 0000
0229: 0000             DirectoryEntryPerRecord EQU    cpmRecordSize / DirEntrySize
0230: 0000
0231: 0000             RecordsPerExtent EQU    080H                 ; extent Record capacity
0232: 0000
0233: 0000
0234: 0000         ;-------------------------------------------------------------------------------------
0235: 0000             NumberOfLogicalDisks EQU    4                    ; max number of disk in this system
0236: 0000
0237: 0000         ;----------------------3.5 Double Density Disk Geometry----------------------------------------
0238: 0000             NumberOfHeads EQU    02H                  ; number of heads
0239: 0000             TracksPerHead EQU    50H                  ; 80
0240: 0000             SectorsPerTrack EQU    12H                  ; 18 -  1 head only
0241: 0000             SectorsPerBlock EQU    04H                  ; 2048 bytes
0242: 0000             DirectoryBlockCount EQU    02H                  ;
0243: 0000         ;-----------------------------------------------------------------------
0244: 0000
0245: 0000             BlockSize  EQU    SectorsPerBlock * 	diskSectorSize ; Size in Bytes
0246: 0000
0247: 0000             RecordsPerBlock EQU    recordsPerSector * SectorsPerBlock
0248: 0000
0249: 0000             TotalNumberOfSectors EQU    SectorsPerTrack * TracksPerHead * NumberOfHeads
0250: 0000             TotalNumberOfBlocks EQU    TotalNumberOfSectors / SectorsPerBlock
0251: 0000             SectorsPerCylinder EQU    SectorsPerTrack * NumberOfHeads
0252: 0000
0253: 0000             SystemSectors EQU    LengthInBytes / diskSectorSize + 1 ; need to account for boot sector
0254: 0000             myOffset   EQU    (SystemSectors / SectorsPerCylinder) + 1 ;
0255: 0000             DataSectors EQU    TotalNumberOfSectors - (SectorsPerCylinder * myOffset)
0256: 0000             DataBlocks EQU    DataSectors / 	SectorsPerBlock
0257: 0000
0258: 0000         ;-----------------------------------------------------------------------
0259: 0000         ;; Disk block parameters for F3HD - 3.5 HD   1.44 MB Diskette
0260: 0000         ;-----------------------------------------------------------------------
0261: 0000         ;dpb3hdSPT				EQU		0090H			; cpmRecords per track- (144)
0262: 0000             dpb3hdSPT  EQU    recordsPerSector * SectorsPerTrack * NumberOfHeads ; SPT - records per Clynder
0263: 0000             dpb3hdBSH  EQU    04H                  ; Block Shift Factor - BlockSize = 128 * (2**BSH)											; BSH = Log2(BlockSize/cpmRecordSize)
0264: 0000             dpb3hdBLM  EQU    0FH                  ; BlockMask = (2**BSH) -1
0265: 0000             dpb3hdEXM  EQU    00H                  ; Extent mask = (PhysicalExtents/LogicalExtents) - 1
0266: 0000             dpb3hdDSM  EQU    DataBlocks -1        ; Maximum allocation block number (710)
0267: 0000             dpb3hdDRM  EQU    ((BlockSize *  DirectoryBlockCount)	/	DirEntrySize) -1 ; DRM Number of directory entries - 1 (127)
0268: 0000             dpb3hdAL0  EQU    0C0H                 ; Bit map for reserving 1 alloc. block
0269: 0000             dpb3hdAL1  EQU    00H                  ;  for each file directory
0270: 0000             dpb3hdCKS  EQU    (dpb3hdDRM +1)/ DirectoryEntryPerRecord ; Disk change work area size (32)
0271: 0000             dpb3hdOFF  EQU    myOffset             ; Number of tracks before directory
0272: 0000             dpb3hdNOH  EQU    NumberOfHeads
0273: 0000
0274: 0000         ;*******************************************************************************
0275: 0000
0276: 0000             SectorMask EQU    SectorsPerBlock - 1
0277: 0000
0278: 0000         ;***************************************************************************
0279: 0000
0280: 0000         ;<<<<<<<<<<<<<<<<<<<<<<< Include >>>>>>>>>>>>>>>>
0281: 0000
0282: 0000
0283: 0000             INopCode   EQU    0DBH
0284: 0000             OUTopCode  EQU    0D3H
0285: 0000
0286: 0000
0287: 0000                        ORG    BIOSStart            ; Assemble code at BIOS address
0288: F600         ; BIOS jum Vector
0289: F600             CodeStart:
0290: F600
0291: F600 C3 8C FE               JP     BOOT                 ; 00  Not Yet Checked
0292: F603             WarmBootEntry:
0293: F603 C3 41 FE               JP     WBOOT                ; 01 Not Yet Checked
0294: F606 C3 F5 F8               JP     CONST                ; 02 Checked
0295: F609 C3 0B F9               JP     CONIN                ; 03 Checked
0296: F60C C3 19 F9               JP     CONOUT               ; 04 Checked
0297: F60F C3 3F F9               JP     LIST                 ; 05 Checked
0298: F612 C3 4F F9               JP     PUNCH                ; 06 Not Yet Checked *
0299: F615 C3 61 F9               JP     READER               ; 07 Not Yet Checked *
0300: F618 C3 71 F9               JP     HOME                 ; 08 Checked
0301: F61B C3 81 F9               JP     SELDSK               ; 09 Checked
0302: F61E C3 A8 F9               JP     SETTRK               ; 0A Checked
0303: F621 C3 AE F9               JP     SETSEC               ; 0B Checked
0304: F624 C3 B3 F9               JP     SETDMA               ; 0C Checked
0305: F627 C3 BC F9               JP     READ                 ; 0D Not Yet Checked
0306: F62A C3 CF F9               JP     WRITE                ; 0E Not Yet Checked
0307: F62D C3 27 F9               JP     LISTST               ; 0F Not Yet Checked *
0308: F630 C3 B9 F9               JP     SECTRAN              ; 10 Checked
0309: F633
0310: F633         ;-------------------------------------------------
0311: F633                        ORG    (($+10H)/10H) * 10H
0312: F640
0313: F640             DiskBuffer:
0314: F640                        DS     diskSectorSize
0315: F840             AfterDiskBuffer EQU    $
0316: F840         ;-------------------------------------------------
0317: F840
0318: F840
0319: F840
0320: F840         ;	ORG AfterDiskBuffer				; reset Location Counter
0321: F840
0322: F840
0323: F840
0324: F840         ;-------------------------------------------------
0325: F840
0326: F840             TTYStatusPort EQU    0EDH
0327: F840             TTYDataPort EQU    0ECH
0328: F840             TTYOutputReady EQU    01H                  ; Status Mask
0329: F840             TTYInputReady EQU    02H                  ; Status Mask
0330: F840
0331: F840             CRT_StatusPort EQU    02H
0332: F840             CRT_DataPort EQU    01H
0333: F840             CRT_OutputReady EQU    80H                  ; Status Mask - ready for output
0334: F840             CRT_InputReady EQU    07FH                 ; Status Mask - bytes yet to have been read
0335: F840
0336: F840             CommunicationStatusPort EQU    0EDH
0337: F840             CommunicationDataPort EQU    0ECH
0338: F840             CommunicationOutputReady EQU    01H                  ; Status Mask
0339: F840             CommunicationInputReady EQU    02H                  ; Status Mask
0340: F840
0341: F840             PrinterStatusPort EQU    011H
0342: F840             PrinterDataPort EQU    010H
0343: F840             PrinterOutputReady EQU    0FFH                 ; Status Mask - ready for output
0344: F840             PrinterInputReady EQU    07FH                 ; Status Mask - not used
0345: F840
0346: F840
0347: F840             TTYTable:
0348: F840 ED                     DB     TTYStatusPort
0349: F841 EC                     DB     TTYDataPort
0350: F842 01                     DB     TTYOutputReady
0351: F843 02                     DB     TTYInputReady
0352: F844             CRT_Table:
0353: F844 02                     DB     CRT_StatusPort
0354: F845 01                     DB     CRT_DataPort
0355: F846 80                     DB     CRT_OutputReady
0356: F847 7F                     DB     CRT_InputReady
0357: F848             CommunicationTable:
0358: F848 ED                     DB     CommunicationStatusPort
0359: F849 EC                     DB     CommunicationDataPort
0360: F84A 01                     DB     CommunicationOutputReady
0361: F84B 02                     DB     CommunicationInputReady
0362: F84C             PrinterTable:
0363: F84C 11                     DB     PrinterStatusPort
0364: F84D 10                     DB     PrinterDataPort
0365: F84E FF                     DB     PrinterOutputReady
0366: F84F 7F                     DB     PrinterInputReady
0367: F850
0368: F850
0369: F850         ;----------------------------------------------------------------------
0370: F850
0371: F850         ; SelectRoutine. When called, the calling code has a vector table immediately following it.
0372: F850         ; it is used to get the correct physical routine determined by the IOBYTE bits for the
0373: F850         ; logical device. (00,01,10,11).
0374: F850         ; It will transfer control to a specified address following its calling address
0375: F850         ; according to the values in bits 1, 0 in A.
0376: F850
0377: F850             SelectRoutine:
0378: F850 E6 03                  AND    03H                  ; Keep low 2 bits
0379: F852 87                     ADD    A,A                  ; double for word size add
0380: F853 E3                     EX     (SP),HL              ; HL-> first word of address after CALL instruction
0381: F854 5F                     LD     E,A                  ; Add on selection value to address table base
0382: F855 16 00                  LD     D,00H
0383: F857 19                     ADD    HL,DE                ; HL-> now has the selected routine
0384: F858 7E                     LD     A,(HL)               ; LS Byte
0385: F859 23                     INC    HL                   ; HL-> MS byte
0386: F85A 66                     LD     H,(HL)               ; MS byte
0387: F85B 6F                     LD     L,A                  ; HL->routine
0388: F85C E3                     EX     (SP),HL              ; top of stack -> routine
0389: F85D C9                     RET                         ; transfer control to the selected routine
0390: F85E         ;----------------------routines called by SelectRoutine----------------------------
0391: F85E         ;----------------------------------------------------------------------------------
0392: F85E
0393: F85E         ; ------------ Status In
0394: F85E             TTYInStatus:
0395: F85E 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0396: F861 C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0397: F864             CRT_InStatus:
0398: F864 21 44 F8               LD     HL,CRT_Table         ; HL-> control table
0399: F867 C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0400: F86A             CommunicationInStatus:
0401: F86A 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0402: F86D C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0403: F870             DummyInStatus:
0404: F870 3E FF                  LD     A,0FFH               ; Dummy always indicates data ready
0405: F872 C9                     RET
0406: F873
0407: F873         ; ------------ Status Out
0408: F873             TTYOutStatus:
0409: F873 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0410: F876 C3 DA F8               JP     OutputStatus         ; use of JMP, OutputStatus will execute thr RETurn
0411: F879             CRT_OutStatus:
0412: F879 21 44 F8               LD     HL,CRT_Table         ; HL-> control table
0413: F87C C3 DA F8               JP     OutputStatus         ; use of JMP, OutputStatus will execute thr RETurn
0414: F87F             CommunicationOutStatus:
0415: F87F 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0416: F882 C3 DA F8               JP     OutputStatus         ; use of JMP, OutputStatus will execute thr RETurn
0417: F885             PrinterStatus:
0418: F885 21 4C F8               LD     HL,PrinterTable      ; HL-> control table
0419: F888 C3 BF F8               JP     InputStatus          ; use of JMP, InputStatus will execute thr RETurn
0420: F88B             DummyOutStatus:
0421: F88B 3E FF                  LD     A,0FFH               ; Dummy always indicates ready to output data
0422: F88D C9                     RET
0423: F88E
0424: F88E         ; ------------ Data In
0425: F88E             TTYInput:
0426: F88E 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0427: F891 C3 CA F8               JP     InputData            ; use of JMP, InputStatus will execute thr RETurn
0428: F894             CRT_Input:
0429: F894 21 44 F8               LD     HL,CRT_Table         ; HL-> control table
0430: F897 CD CA F8               CALL   InputData            ; ** special **
0431: F89A E6 7F                  AND    07FH                 ; Strip off high order bit
0432: F89C C9                     RET
0433: F89D             CommunicationInput:
0434: F89D 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0435: F8A0 C3 CA F8               JP     InputData            ; use of JMP, InputStatus will execute thr RETurn
0436: F8A3             DummyInput:
0437: F8A3 3E 1A                  LD     A,END_OF_FILE        ; Dummy always returns EOF
0438: F8A5 C9                     RET
0439: F8A6
0440: F8A6         ; ------------ Data Out
0441: F8A6             TTYOutput:
0442: F8A6 21 40 F8               LD     HL,TTYTable          ; HL-> control table
0443: F8A9 C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0444: F8AC             CRT_Output:
0445: F8AC 21 44 F8               LD     HL,CRT_Table         ;HL-> control table
0446: F8AF C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0447: F8B2             CommunicationOutput:
0448: F8B2 21 48 F8               LD     HL,CommunicationTable ; HL-> control table
0449: F8B5 C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0450: F8B8             PrinterOutput:
0451: F8B8 21 4C F8               LD     HL,PrinterTable      ; HL-> control table
0452: F8BB C3 E4 F8               JP     OutputData           ; use of JMP, InputStatus will execute thr RETurn
0453: F8BE             DummyOutput:
0454: F8BE C9                     RET                         ; Dummy always discards the data
0455: F8BF         ;-----------------------------------		----------------------------------------
0456: F8BF         ;---------------------------------------------------------------------------
0457: F8BF             InputStatus:                      ; return- A = 00H no incoming data
0458: F8BF 7E                     LD     A,(HL)               ; get status port
0459: F8C0 32 C4 F8               LD     (InputStatusPort),A  ; ** self modifying code
0460: F8C3 DB                     DB     INopCode             ; IN opcode
0461: F8C4             InputStatusPort:
0462: F8C4 00                     DB     00H                  ; <- set from above
0463: F8C5 23                     INC    HL                   ; move HL to point to input data mask
0464: F8C6 23                     INC    HL
0465: F8C7 23                     INC    HL
0466: F8C8 A6                     AND    M                    ; mask with input status
0467: F8C9 C9                     RET                         ; return with status (00 nothing, FF - data available)
0468: F8CA         ;---------------------------------------------------------------------------
0469: F8CA             InputData:                      ; return with next character
0470: F8CA E5                     PUSH   HL                   ; save control table pointer
0471: F8CB CD BF F8               CALL   InputStatus
0472: F8CE E1                     POP    HL                   ; restore the control table
0473: F8CF CA CA F8               JP     Z,InputData          ; wait until incoming data
0474: F8D2 23                     INC    HL                   ; HL <- data port
0475: F8D3 7E                     LD     A,(HL)               ; get data port
0476: F8D4 32 D8 F8               LD     (InputDataPort),A    ; modify code here
0477: F8D7 DB                     DB     INopCode             ; do the actual I/O
0478: F8D8             InputDataPort:
0479: F8D8 00                     DB     00H                  ; <- set from above
0480: F8D9 C9                     RET                         ; return with data in A
0481: F8DA         ;---------------------------------------------------------------------------
0482: F8DA             OutputStatus:                      ; return - A = 00H not ready
0483: F8DA 7E                     LD     A,(HL)
0484: F8DB 32 DF F8               LD     (OutputStatusPort),A
0485: F8DE DB                     DB     INopCode             ; IN opcode
0486: F8DF             OutputStatusPort:
0487: F8DF 00                     DB     00H                  ; <- set from above
0488: F8E0 23                     INC    HL                   ; HL , Output status mask
0489: F8E1 23                     INC    HL
0490: F8E2 A6                     AND    M                    ; mask with output status, 00 = Not ready
0491: F8E3 C9                     RET
0492: F8E4         ;---------------------------------------------------------------------------
0493: F8E4             OutputData:                      ; data in Register C is output
0494: F8E4 E5                     PUSH   HL                   ; save control table pointer
0495: F8E5 CD DA F8               CALL   OutputStatus
0496: F8E8 E1                     POP    HL                   ; restore table pointer
0497: F8E9 CA E4 F8               JP     Z,OutputData         ; wait until incoming data
0498: F8EC 23                     INC    HL                   ; HL <- data port
0499: F8ED 7E                     LD     A,(HL)               ; get data port
0500: F8EE 32 F3 F8               LD     (OutputDataPort),A   ; store it here Modify the code
0501: F8F1 79                     LD     A,C                  ; get the data to output
0502: F8F2 D3                     DB     OUTopCode            ; Do the I/O here !!
0503: F8F3             OutputDataPort:
0504: F8F3 00                     DB     00H                  ; <- set from above
0505: F8F4 C9                     RET
0506: F8F5         ;---------------------------------------------------------------------------
0507: F8F5
0508: F8F5
0509: F8F5         ;---------------------------------------------------------------------------
0510: F8F5         ;	Console Status  BIOS 02
0511: F8F5         ; Entered directly from BIOS JMP vector, returns Register A
0512: F8F5         ; 00H -> No data ,  0FFH -> there is data
0513: F8F5         ;
0514: F8F5
0515: F8F5             CONST:
0516: F8F5 CD FD F8               CALL   GetConsoleStatus     ; return A= zero or not zero
0517: F8F8 B7                     OR     A
0518: F8F9 C8                     RET    Z                    ; if 0 no returning data
0519: F8FA 3E FF                  LD     A,0FFH               ; else indicate there is data
0520: F8FC C9                     RET
0521: F8FD         ;---------------------------------------------------------------------------
0522: F8FD             GetConsoleStatus:
0523: F8FD 3A 03 00               LD     A,(IOBYTE)           ; Get IO redirection byte
0524: F900 CD 50 F8               CALL   SelectRoutine
0525: F903
0526: F903 5E F8                  DW     TTYInStatus          ; 00 TTY
0527: F905 64 F8                  DW     CRT_InStatus         ; 01 CRT
0528: F907 6A F8                  DW     CommunicationInStatus ; 10 BAT
0529: F909 70 F8                  DW     DummyInStatus        ; 11 UC1
0530: F90B
0531: F90B         ;---------------------------------------------------------------------------
0532: F90B         ;	Console In  BIOS 03
0533: F90B         ; Get console Input character entered directly from the BIOS jmp Vector
0534: F90B         ; return the character from the console in the A register.
0535: F90B         ; most significant bit will be 0. except when "reader" (communication)
0536: F90B         ; port has input , all 8 bits are reurned
0537: F90B         ;
0538: F90B         ; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0539: F90B
0540: F90B             CONIN:
0541: F90B 3A 03 00               LD     A,(IOBYTE)           ; get i/o redirection byte
0542: F90E CD 50 F8               CALL   SelectRoutine
0543: F911
0544: F911 8E F8                  DW     TTYInput             ; 00 TTY
0545: F913 94 F8                  DW     CRT_Input            ; 01 CRT
0546: F915 9D F8                  DW     CommunicationInput   ; 10 BAT
0547: F917 A3 F8                  DW     DummyInput           ; 11 UC1
0548: F919
0549: F919         ;---------------------------------------------------------------------------
0550: F919         ;	Console Out  BIOS 04
0551: F919         ;  entered directly from BIOS JMP Vector. it outputs the
0552: F919         ; character in the C register to the appropriate device according to
0553: F919         ; bits 1,0 of IOBYTE
0554: F919             CONOUT:
0555: F919 3A 03 00               LD     A,(IOBYTE)           ; get i/o redirection byte
0556: F91C CD 50 F8               CALL   SelectRoutine
0557: F91F
0558: F91F A6 F8                  DW     TTYOutput            ; 00 TTY
0559: F921 AC F8                  DW     CRT_Output           ; 01 CRT
0560: F923 B2 F8                  DW     CommunicationOutput  ; 10 BAT
0561: F925 BE F8                  DW     DummyOutput          ; 11 UC1
0562: F927
0563: F927         ;---------------------------------------------------------------------------
0564: F927         ;	List Status  BIOS 0F
0565: F927
0566: F927             LISTST:
0567: F927         ; List Device (output) status entered directly from the BIOS JMP Vector
0568: F927         ; returns in A the list device status that indicates if the device will
0569: F927         ; accept another character the IOBYTE's bits 7,6 determin the physical device
0570: F927         ; A = 00H (zero flag set): cannot accpet data
0571: F927         ; A = 0FFH ( zero flag cleared): can accept data
0572: F927
0573: F927 CD 2F F9               CALL   GetListStatus        ; return  A = 0 or non-zero
0574: F92A B7                     OR     A                    ; set flags
0575: F92B C8                     RET    Z                    ; exit if not ready
0576: F92C 3E FF                  LD     A,0FFH               ; else set retuen value for ok
0577: F92E C9                     RET
0578: F92F         ; exit
0579: F92F             GetListStatus:
0580: F92F 3A 03 00               LD     A,(IOBYTE)
0581: F932 07                     RLCA                        ; move bits 7,6
0582: F933 07                     RLCA                        ; to 1,0
0583: F934 CD 50 F8               CALL   SelectRoutine
0584: F937
0585: F937 73 F8                  DW     TTYOutStatus         ; 00 TTY
0586: F939 79 F8                  DW     CRT_OutStatus        ; 01 CRT
0587: F93B 85 F8                  DW     PrinterStatus        ; 10 LPT
0588: F93D 8B F8                  DW     DummyOutStatus       ; 11 UL1
0589: F93F         ;---------------------------------------------------------------------------
0590: F93F         ;	List output  BIOS 05
0591: F93F         ; entered directly from the BIOS JMP Vector
0592: F93F         ; outputs the data in Register C
0593: F93F             LIST:
0594: F93F 3A 03 00               LD     A,(IOBYTE)
0595: F942 07                     RLCA                        ; move bits 7,6
0596: F943 07                     RLCA                        ; to 1,0
0597: F944 CD 50 F8               CALL   SelectRoutine
0598: F947
0599: F947 A6 F8                  DW     TTYOutput            ; 00 TTY
0600: F949 AC F8                  DW     CRT_Output           ; 01 CRT
0601: F94B B8 F8                  DW     PrinterOutput        ; 10 LPT
0602: F94D BE F8                  DW     DummyOutput          ; 11 UL1
0603: F94F
0604: F94F         ;---------------------------------------------------------------------------
0605: F94F         ;	Punch output  BIOS 06	- not tested
0606: F94F         ; entered directly from the BIOS JMP Vector
0607: F94F         ; outputs the data in Register C
0608: F94F             PUNCH:                          ; Punch output
0609: F94F
0610: F94F 3A 03 00               LD     A,(IOBYTE)
0611: F952 0F                     RRCA
0612: F953 0F                     RRCA
0613: F954 0F                     RRCA                        ; move bits 5,4
0614: F955 0F                     RRCA                        ; to 1,0
0615: F956 CD 50 F8               CALL   SelectRoutine
0616: F959
0617: F959 A6 F8                  DW     TTYOutput            ; 00 TTY
0618: F95B BE F8                  DW     DummyOutput          ; 01 PTP
0619: F95D B2 F8                  DW     CommunicationOutput  ; 10 UP1
0620: F95F AC F8                  DW     CRT_Output           ; 11 UP2
0621: F961
0622: F961         ;---------------------------------------------------------------------------
0623: F961         ;	Reader input  BIOS 07	- not tested
0624: F961         ; entered directly from the BIOS JMP Vector
0625: F961         ; inputs data into the A register
0626: F961             READER:                         ; Reader Input
0627: F961 3A 03 00               LD     A,(IOBYTE)
0628: F964 0F                     RRCA
0629: F965 0F                     RRCA                        ; move bits 3,2  to 1,0
0630: F966 CD 50 F8               CALL   SelectRoutine
0631: F969
0632: F969 A6 F8                  DW     TTYOutput            ; 00 TTY
0633: F96B BE F8                  DW     DummyOutput          ; 01 PTR
0634: F96D B2 F8                  DW     CommunicationOutput  ; 10 UR1
0635: F96F AC F8                  DW     CRT_Output           ; 11 UR2
0636: F971
0637: F971         ;---------------------------------------------------------------------------
0638: F971         ;---------------------------------------------------------------------------
0639: F971         ;	Disk routines
0640: F971         ;---------------------------------------------------------------------------
0641: F971         ;**********************
0642: F971         ;	Home Disk	BIOS 08
0643: F971         ;HOME - Home the selected logical disk to track 0.
0644: F971         ;	Before doing this, a check must be made to see if the
0645: F971         ;	physical disk buffer has information that must be
0646: F971         ;	written out. This is indicated by a flag, MustWriteBuffer,
0647: F971         ;	set in the de-blocking code
0648: F971         ;**********************
0649: F971             HOME:
0650: F971 3A 6F FB               LD     A,(MustWriteBuffer)  ; check flag
0651: F974 B7                     OR     A
0652: F975 C2 7B F9               JP     NZ,HomeNoWrite
0653: F978 32 6E FB               LD     (DataInDiskBuffer),A ; no, so indicate empty buffer
0654: F97B             HomeNoWrite:
0655: F97B 0E 00                  LD     C,00H                ; Set to track 0
0656: F97D CD A8 F9               CALL   SETTRK               ; no, physical, only logical
0657: F980 C9                     RET
0658: F981
0659: F981         ;	Select Disk	BIOS 09
0660: F981         ; Select disk in C. C=0 for A: 1 for B: etc.
0661: F981         ; Return the address of the appropriate disk parameter header
0662: F981         ; in HL, or 0000H if selected disk does not exist
0663: F981         ;**********************
0664: F981             SELDSK:
0665: F981 21 00 00               LD     HL,00H               ; Assume an error
0666: F984 79                     LD     A,C
0667: F985 FE 04                  CP     NumberOfLogicalDisks
0668: F987 D0                     RET    NC                   ; return if > max number of Disks
0669: F988
0670: F988 32 71 FB               LD     (SelectedDisk),A     ; save disk number
0671: F98B 6F                     LD     L,A                  ; make disk into word number
0672: F98C 26 00                  LD     H,0
0673: F98E         ; Compute offset down disk parameter table by multiplying by parameter
0674: F98E         ; header length (16 bytes)
0675: F98E 29                     ADD    HL,HL
0676: F98F 29                     ADD    HL,HL
0677: F990 29                     ADD    HL,HL
0678: F991 29                     ADD    HL,HL                ; pointing at right one
0679: F992 11 80 FB               LD     DE,DiskParameterHeaders ; get DPH address
0680: F995 19                     ADD    HL,DE                ; DE -> appropriate DPH
0681: F996 E5                     PUSH   HL                   ; Save DPH pointer
0682: F997 11 0A 00               LD     DE,10                ; DiskParameterBlock Index
0683: F99A 19                     ADD    HL,DE                ; ????? -> cpmRecords per track
0684: F99B 5E                     LD     E,(HL)
0685: F99C 23                     INC    HL
0686: F99D 56                     LD     D,(HL)               ; DE has Parameter Block for selected disk
0687: F99E 21 0F 00               LD     HL,15                ; SectorsPerHead Index
0688: F9A1 19                     ADD    HL,DE                ; HL is at SecPerHeadPerTrack
0689: F9A2 7E                     LD     A,(HL)               ; get the value and
0690: F9A3 32 70 FB               LD     (SelectedDskSecsPerHead),A ; save for actual IO
0691: F9A6
0692: F9A6 E1                     POP    HL                   ; recover DPH pointer
0693: F9A7 C9                     RET
0694: F9A8
0695: F9A8         ;**********************
0696: F9A8         ;	Set Track	BIOS 0A
0697: F9A8         ;SETTRK - Set logical track for next read or write.	Track is in BC
0698: F9A8         ;**********************
0699: F9A8             SETTRK:
0700: F9A8 60                     LD     H,B                  ; select track in BC on entry
0701: F9A9 69                     LD     L,C
0702: F9AA 22 72 FB               LD     (SelectedTrack),HL   ; save for low level driver
0703: F9AD C9                     RET
0704: F9AE         ;**********************
0705: F9AE         ;	Set Sector	BIOS 0B
0706: F9AE         ;SETSEC - Set logical sector for next read or write. Sector is in C
0707: F9AE         ;**********************
0708: F9AE             SETSEC:
0709: F9AE 79                     LD     A,C
0710: F9AF 32 74 FB               LD     (SelectedSector),A   ; save for low level driver
0711: F9B2 C9                     RET
0712: F9B3         ;**********************
0713: F9B3         ;	Set Sector	BIOS 0C
0714: F9B3         ;SetDMA - Set DMA (input/output) address for next read or write. Address in BC
0715: F9B3         ;**********************
0716: F9B3             SETDMA:
0717: F9B3 69                     LD     L,C                  ; select address in BC on entry
0718: F9B4 60                     LD     H,B
0719: F9B5 22 75 FB               LD     (DMAAddress),HL      ; save for low level driver
0720: F9B8 C9                     RET
0721: F9B9         ;**********************
0722: F9B9         ;	Sector Translate	BIOS 10
0723: F9B9         ;SECTRAN - Translate logical sector to physical
0724: F9B9         ; on Entry:	BC= logical sector number DE-> appropriate skew table
0725: F9B9         ; on Exit:	HL = physical sector number
0726: F9B9         ;**********************
0727: F9B9             SECTRAN:
0728: F9B9 C5                     PUSH   BC
0729: F9BA E1                     POP    HL                   ; just move the value from BC to HL
0730: F9BB C9                     RET
0731: F9BC
0732: F9BC         ;************************************************************************************************
0733: F9BC         ;        READ	BIOS
0734: F9BC         ; Read in the  CP/M record specified by previous calls to select disk and to set track  and
0735: F9BC         ; sector. The sector will be read into the address specified in the previous call to set DMA address
0736: F9BC         ;
0737: F9BC         ;************************************************************************************************
0738: F9BC             READ:
0739: F9BC AF                     XOR    A                    ; set record count to 0
0740: F9BD 32 7C FB               LD     (UnalocatedlRecordCount),A
0741: F9C0 3C                     INC    A
0742: F9C1 32 7F FB               LD     (ReadFlag),A         ; Set to non zero to indicate that this is a read
0743: F9C4 32 7E FB               LD     (PrereadSectorFlag),A ; force pre-read
0744: F9C7 3E 02                  LD     A,WriteUnallocated   ; fake de-blocking code into responding as if this
0745: F9C9 32 69 FB               LD     (WriteType),A        ; is the first write to an unallocated allocation block
0746: F9CC C3 21 FA               JP     PerformReadWrite     ; use common code to execute read
0747: F9CF         ;----------------------------------------
0748: F9CF         ;************************************************************************************************
0749: F9CF         ;	WRITE
0750: F9CF         ;Write a cpmRecord (128-bytes) from the current DMA address to the previously Selected disk, track, and sector.
0751: F9CF         ;
0752: F9CF         ; On arrival here, the BDOS will have set register C to indicate whether this write operation is to:
0753: F9CF         ;	00H [WriteAllocated]	 An already allocated allocation block (which means a pre-read of the sector may be needed),
0754: F9CF         ;	01H [WriteDirectory]	 To the directory (in which case the data will be written to the disk immediately),
0755: F9CF         ;	02H	[WriteUnallocated]	 To the first cpmRecord of a previously unallocated allocation block (In which case no pre-read is required).
0756: F9CF         ;
0757: F9CF         ; Only writes to the directory take place immediately.
0758: F9CF         ; In all other cases, the data will be moved from the DMA address into the disk buffer,
0759: F9CF         ; and only written out when circumstance force the transfer.
0760: F9CF         ; The number of physical disk operations can therefore be reduced considerably.
0761: F9CF         ;************************************************************************************************
0762: F9CF             WRITE:
0763: F9CF         ; Buffered I/O
0764: F9CF AF                     XOR    A
0765: F9D0 32 7F FB               LD     (ReadFlag),A         ; Set to zero to indicate that this is not a read
0766: F9D3 79                     LD     A,C
0767: F9D4 32 69 FB               LD     (WriteType),A        ; save the BDOS write type (0,1,2)
0768: F9D7 FE 02                  CP     WriteUnallocated     ; first write to an unallocated allocation block ?
0769: F9D9 C2 EA F9               JP     NZ,CheckUnallocatedBlock ; No, - in the middle of writing to an unallocated block ?
0770: F9DC         ; Yes, It is the first write to unallocated allocation block.
0771: F9DC         ; Initialize  variables associated with unallocated writes
0772: F9DC 3E 10                  LD     A,RecordsPerBlock    ; Number of records
0773: F9DE 32 7C FB               LD     (UnalocatedlRecordCount),A ; reset Unallocated Record Count to recordsPerBlock
0774: F9E1 21 71 FB               LD     HL,SelectedDkTrkSec
0775: F9E4 11 78 FB               LD     DE,UnallocatedDkTrkSec
0776: F9E7 CD E4 FA               CALL   MoveDkTrkSec         ; copy disk, track & sector into unallocated variables
0777: F9EA
0778: F9EA         ; Check if this is not the first write to an unallocated allocation block -- if it is,
0779: F9EA         ; the unallocated record count has just been set to the number of records in the allocation block
0780: F9EA             CheckUnallocatedBlock:
0781: F9EA 3A 7C FB               LD     A,(UnalocatedlRecordCount)
0782: F9ED B7                     OR     A
0783: F9EE CA 19 FA               JP     Z,RequestPreread     ; No - write to an unallocated block
0784: F9F1 3D                     DEC    A
0785: F9F2 32 7C FB               LD     (UnalocatedlRecordCount),A ; decrement records left
0786: F9F5
0787: F9F5 21 71 FB               LD     HL,SelectedDkTrkSec  ; same Disk, Track & sector as for those in an unallocated block
0788: F9F8 11 78 FB               LD     DE,UnallocatedDkTrkSec
0789: F9FB CD D8 FA               CALL   CompareDkTrkSec      ; are they the same
0790: F9FE C2 19 FA               JP     NZ,RequestPreread    ; NO - do a pre-read
0791: FA01 EB                     EX     DE,HL
0792: FA02 34                     INC    M                    ; increment UnalocatedlRecordCount
0793: FA03 7E                     LD     A,(HL)
0794: FA04 FE 12                  CP     SectorsPerTrack      ; Sector > maximum on track ?
0795: FA06 DA 12 FA               JP     C,NoTrackChange      ; No ( A < M)
0796: FA09 36 00                  LD     (HL),00H             ; Yes
0797: FA0B 2A 79 FB               LD     HL,(UnallocatedTrack)
0798: FA0E 23                     INC    HL                   ; increment track
0799: FA0F 22 79 FB               LD     (UnallocatedTrack),HL
0800: FA12             NoTrackChange:
0801: FA12 AF                     XOR    A
0802: FA13 32 7E FB               LD     (PrereadSectorFlag),A ; clear flag
0803: FA16 C3 21 FA               JP     PerformReadWrite
0804: FA19
0805: FA19             RequestPreread:
0806: FA19 AF                     XOR    A
0807: FA1A 32 7C FB               LD     (UnalocatedlRecordCount),A ; not a write into an unallocated block
0808: FA1D 3C                     INC    A
0809: FA1E 32 7E FB               LD     (PrereadSectorFlag),A ; set flag
0810: FA21         ;*******************************************************
0811: FA21         ; Common code to execute both reads and writes of 128-byte records
0812: FA21         ;*******************************************************
0813: FA21             PerformReadWrite:
0814: FA21 AF                     XOR    A                    ; Assume no disk error will occur
0815: FA22 32 7D FB               LD     (DiskErrorFlag),A
0816: FA25 3A 74 FB               LD     A,(SelectedSector)
0817: FA28 1F                     RRA                         ; Convert selected record
0818: FA29 1F                     RRA                         ; into physical sector by dividing by 4
0819: FA2A E6 3F                  AND    03FH                 ; remove unwanted bits
0820: FA2C 32 77 FB               LD     (SelectedPhysicalSector),A
0821: FA2F 21 6E FB               LD     HL,DataInDiskBuffer  ; see if there is any data here ?
0822: FA32 7E                     LD     A,(HL)
0823: FA33 36 01                  LD     (HL),001H            ; force there is data here for after the actual read
0824: FA35 B7                     OR     A                    ; really is there any data here ?
0825: FA36 CA 56 FA               JP     Z,ReadSectorIntoBuffer ; NO ?- go read into buffer
0826: FA39         ;
0827: FA39         ; The buffer does have a physical sector in it, Note: The disk, track, and PHYSICAL sector
0828: FA39         ; in the buffer need to be checked, hence the use of the CompareDkTrk subroutine.
0829: FA39 11 6A FB               LD     DE,InBufferDkTrkSec
0830: FA3C 21 71 FB               LD     HL,SelectedDkTrkSec  ; get the requested sector
0831: FA3F CD D3 FA               CALL   CompareDkTrk         ; is it in the buffer ?
0832: FA42 C2 4F FA               JP     NZ,SectorNotInBuffer ; NO,jump - it must be read
0833: FA45         ; Yes, it is in the buffer
0834: FA45 3A 6D FB               LD     A,(InBufferSector)   ; get the sector
0835: FA48 21 77 FB               LD     HL,SelectedPhysicalSector
0836: FA4B BE                     CP     M                    ; Check if correct physical sector
0837: FA4C CA 73 FA               JP     Z,SectorInBuffer     ; Yes - it is already in memory
0838: FA4F         ; No, it will have to be read in over current contents of buffer
0839: FA4F             SectorNotInBuffer:
0840: FA4F 3A 6F FB               LD     A,(MustWriteBuffer)
0841: FA52 B7                     OR     A                    ; do we need to write ?
0842: FA53 C4 EF FA               CALL   NZ,WritePhysical     ; if yes - write it out
0843: FA56
0844: FA56             ReadSectorIntoBuffer:
0845: FA56         ; indicate the  selected disk, track, and sector now residing in buffer
0846: FA56 3A 71 FB               LD     A,(SelectedDisk)
0847: FA59 32 6A FB               LD     (InBufferDisk),A
0848: FA5C 2A 72 FB               LD     HL,(SelectedTrack)
0849: FA5F 22 6B FB               LD     (InBufferTrack),HL
0850: FA62 3A 77 FB               LD     A,(SelectedPhysicalSector)
0851: FA65 32 6D FB               LD     (InBufferSector),A
0852: FA68
0853: FA68 3A 7E FB               LD     A,(PrereadSectorFlag) ; do we need to pre-read
0854: FA6B B7                     OR     A
0855: FA6C C4 F4 FA               CALL   NZ,ReadPhysical      ; yes - pre-read the sector
0856: FA6F
0857: FA6F         ; At this point the data is in the buffer.
0858: FA6F         ; Either it was already here, or we returned from ReadPhysical
0859: FA6F
0860: FA6F AF                     XOR    A                    ; reset the flag
0861: FA70 32 6F FB               LD     (MustWriteBuffer),A  ; and store it away
0862: FA73
0863: FA73         ; Selected sector on correct track and  disk is already 1n the buffer.
0864: FA73         ; Convert the selected cpmRecord into relative address down the buffer.
0865: FA73             SectorInBuffer:
0866: FA73 3A 74 FB               LD     A,(SelectedSector)
0867: FA76 E6 03                  AND    SectorMask           ; only want the least bits
0868: FA78 6F                     LD     L,A                  ; to calculate offset into 512 byte buffer
0869: FA79 26 00                  LD     H,00H                ; Multiply by 128 - cpmRecordSize
0870: FA7B 29                     ADD    HL,HL                ; *2
0871: FA7C 29                     ADD    HL,HL                ; *4
0872: FA7D 29                     ADD    HL,HL                ; *8
0873: FA7E 29                     ADD    HL,HL                ; *16
0874: FA7F 29                     ADD    HL,HL                ; *32
0875: FA80 29                     ADD    HL,HL                ; *64
0876: FA81 29                     ADD    HL,HL                ; *128
0877: FA82 11 40 F6               LD     DE,DiskBuffer
0878: FA85 19                     ADD    HL,DE                ; HL -> record number start address
0879: FA86 EB                     EX     DE,HL                ; DE -> sector in the disk buffer
0880: FA87 2A 75 FB               LD     HL,(DMAAddress)      ; Get DMA address (set in SETDMA)
0881: FA8A EB                     EX     DE,HL                ; assume a read so :
0882: FA8B         ; DE -> DMA Address & HL -> sector in disk buffer
0883: FA8B 0E 10                  LD     C,cpmRecordSize/8    ; 8 bytes per move (loop count)
0884: FA8D         ;
0885: FA8D         ;  At this point -
0886: FA8D         ;	C	->	loop count
0887: FA8D         ;	DE	->	DMA address
0888: FA8D         ;	HL	->	sector in disk buffer
0889: FA8D         ;
0890: FA8D 3A 7F FB               LD     A,(ReadFlag)         ; Move into or out of buffer /
0891: FA90 B7                     OR     A                    ; 0 => Write, non Zero => Read
0892: FA91 C2 99 FA               JP     NZ,BufferMove        ; Move out of buffer
0893: FA94
0894: FA94 3C                     INC    A                    ; going to force a write
0895: FA95 32 6F FB               LD     (MustWriteBuffer),A
0896: FA98 EB                     EX     DE,HL                ; DE <--> HL
0897: FA99
0898: FA99         ;The following move loop moves eight bytes at a time from (HL> to (DE), C contains the loop count
0899: FA99             BufferMove:
0900: FA99 7E                     LD     A,(HL)               ; Get byte from source
0901: FA9A 12                     LD     (DE),A               ; Put into destination
0902: FA9B 13                     INC    DE                   ; update pointers
0903: FA9C 23                     INC    HL
0904: FA9D
0905: FA9D 7E                     LD     A,(HL)
0906: FA9E 12                     LD     (DE),A
0907: FA9F 13                     INC    DE
0908: FAA0 23                     INC    HL
0909: FAA1
0910: FAA1 7E                     LD     A,(HL)
0911: FAA2 12                     LD     (DE),A
0912: FAA3 13                     INC    DE
0913: FAA4 23                     INC    HL
0914: FAA5
0915: FAA5 7E                     LD     A,(HL)
0916: FAA6 12                     LD     (DE),A
0917: FAA7 13                     INC    DE
0918: FAA8 23                     INC    HL
0919: FAA9
0920: FAA9 7E                     LD     A,(HL)
0921: FAAA 12                     LD     (DE),A
0922: FAAB 13                     INC    DE
0923: FAAC 23                     INC    HL
0924: FAAD
0925: FAAD 7E                     LD     A,(HL)
0926: FAAE 12                     LD     (DE),A
0927: FAAF 13                     INC    DE
0928: FAB0 23                     INC    HL
0929: FAB1
0930: FAB1 7E                     LD     A,(HL)
0931: FAB2 12                     LD     (DE),A
0932: FAB3 13                     INC    DE
0933: FAB4 23                     INC    HL
0934: FAB5
0935: FAB5 7E                     LD     A,(HL)
0936: FAB6 12                     LD     (DE),A
0937: FAB7 13                     INC    DE
0938: FAB8 23                     INC    HL
0939: FAB9
0940: FAB9 0D                     DEC    C                    ; count down on loop counter
0941: FABA C2 99 FA               JP     NZ,BufferMove        ; repeat till done (CP/M sector moved)
0942: FABD         ; end of loop
0943: FABD
0944: FABD 3A 69 FB               LD     A,(WriteType)        ; write to directory ?
0945: FAC0 FE 01                  CP     WriteDirectory
0946: FAC2 3A 7D FB               LD     A,(DiskErrorFlag)    ; get flag in case of a delayed read or write
0947: FAC5 C0                     RET    NZ                   ; return if delayed read or write
0948: FAC6
0949: FAC6 B7                     OR     A                    ; Any disk errors ?
0950: FAC7 C0                     RET    NZ                   ; yes - abandon attempt to write to directory
0951: FAC8
0952: FAC8 AF                     XOR    A
0953: FAC9 32 6F FB               LD     (MustWriteBuffer),A  ; clear flag
0954: FACC CD EF FA               CALL   WritePhysical
0955: FACF 3A 7D FB               LD     A,(DiskErrorFlag)    ; return error flag to caller
0956: FAD2 C9                     RET
0957: FAD3         ;********************************************************************
0958: FAD3         ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
0959: FAD3             CompareDkTrk:
0960: FAD3 0E 03                  LD     C,03H                ; Disk(1), Track(2)
0961: FAD5 C3 DA FA               JP     CompareDkTrkSecLoop
0962: FAD8             CompareDkTrkSec:                      ;Compares just the disk and track   pointed to by DE and HL
0963: FAD8 0E 04                  LD     C,04H                ; Disk(1), Track(2), Sector(1)
0964: FADA             CompareDkTrkSecLoop:
0965: FADA 1A                     LD     A,(DE)
0966: FADB BE                     CP     M
0967: FADC C0                     RET    NZ                   ; Not equal
0968: FADD 13                     INC    DE
0969: FADE 23                     INC    HL
0970: FADF 0D                     DEC    C
0971: FAE0 C8                     RET    Z                    ; return they match (zero flag set)
0972: FAE1 C3 DA FA               JP     CompareDkTrkSecLoop  ; keep going
0973: FAE4
0974: FAE4         ;********************************************************************
0975: FAE4         ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE
0976: FAE4             MoveDkTrkSec:
0977: FAE4 0E 04                  LD     C,04H                ; Disk(1), Track(2), Sector(1)
0978: FAE6             MoveDkTrkSecLoop:
0979: FAE6 7E                     LD     A,(HL)
0980: FAE7 12                     LD     (DE),A
0981: FAE8 13                     INC    DE
0982: FAE9 23                     INC    HL
0983: FAEA 0D                     DEC    C
0984: FAEB C8                     RET    Z
0985: FAEC C3 E6 FA               JP     MoveDkTrkSecLoop
0986: FAEF         ;********************************************************************
0987: FAEF
0988: FAEF         ;********************************************************************
0989: FAEF         ;Write contents of disk buffer to correct sector
0990: FAEF             WritePhysical:
0991: FAEF 3E 02                  LD     A,DiskWriteCode      ; get write function
0992: FAF1 C3 F6 FA               JP     CommonPhysical
0993: FAF4
0994: FAF4             ReadPhysical:
0995: FAF4 3E 01                  LD     A,DiskReadCode       ; get read function
0996: FAF6
0997: FAF6             CommonPhysical:
0998: FAF6 32 5C FB               LD     (DCTCommand),A       ; set the command
0999: FAF9 3A 6A FB               LD     A,(InBufferDisk)
1000: FAFC E6 03                  AND    03H                  ; only units 0 to 3
1001: FAFE 32 5D FB               LD     (DCTUnit),A          ; set disk
1002: FB01 2A 6B FB               LD     HL,(InBufferTrack)
1003: FB04 7D                     LD     A,L                  ; for this controller it is a byte value
1004: FB05 32 5F FB               LD     (DCTTrack),A         ; set track
1005: FB08         ;  The sector must be converted into a head number and sector number.
1006: FB08         ; This set of disks and Diskettes only have two Heads ******
1007: FB08 06 00                  LD     B,0                  ; assume head 0
1008: FB0A 21 70 FB               LD     HL,SelectedDskSecsPerHead ; Point at track counts
1009: FB0D 3A 6D FB               LD     A,(InBufferSector)   ; get target sector
1010: FB10             Head0:
1011: FB10 BE                     CP     M                    ; Need another Head?
1012: FB11 DA 19 FB               JP     C,Head1              ; nope Acc < M
1013: FB14
1014: FB14 96                     SUB    M                    ; subtrack track value
1015: FB15 04                     INC    B                    ; Increment head
1016: FB16 C3 10 FB               JP     Head0                ; loop til done
1017: FB19
1018: FB19             Head1:
1019: FB19 3C                     INC    A                    ; physical sectors start at 1
1020: FB1A 32 60 FB               LD     (DCTSector),A
1021: FB1D 78                     LD     A,B
1022: FB1E 32 5E FB               LD     (DCTHead),A          ; set head number
1023: FB21
1024: FB21 21 00 02               LD     HL,diskSectorSize
1025: FB24 22 61 FB               LD     (DCTByteCount),HL    ; set byte count
1026: FB27 21 40 F6               LD     HL,DiskBuffer
1027: FB2A 22 63 FB               LD     (DCTDMAAddress),HL   ; set transfer address
1028: FB2D
1029: FB2D         ;	As only one control table is in use, close the status and busy chain pointers
1030: FB2D         ;  back to the main control bytes
1031: FB2D 21 43 00               LD     HL,DiskStatusLocation
1032: FB30 22 65 FB               LD     (DCTNextStatusBlock),HL
1033: FB33 21 45 00               LD     HL,DiskControlByte
1034: FB36 22 67 FB               LD     (DCTNextControlLocation),HL
1035: FB39 21 5C FB               LD     HL,DCTCommand
1036: FB3C 22 46 00               LD     (DiskCommandBlock),HL
1037: FB3F
1038: FB3F 21 45 00               LD     HL,DiskControlByte   ; activate disk controller
1039: FB42 36 80                  LD     (HL),080H
1040: FB44
1041: FB44         ;Wait until Disk Status Block indicates , operation complete, then check
1042: FB44         ; if any errors occurred. ,On entry HL -> disk control byte
1043: FB44             WaitForDiskComplete:
1044: FB44 7E                     LD     A,(HL)               ; get control bytes
1045: FB45 B7                     OR     A
1046: FB46 C2 44 FB               JP     NZ,WaitForDiskComplete ; operation not done
1047: FB49
1048: FB49 3A 43 00               LD     A,(DiskStatusLocation) ; done , so now check status
1049: FB4C FE 80                  CP     080H
1050: FB4E DA 56 FB               JP     C,DiskError
1051: FB51 AF                     XOR    A
1052: FB52 32 7D FB               LD     (DiskErrorFlag),A    ; clear the flag
1053: FB55 C9                     RET
1054: FB56
1055: FB56             DiskError:
1056: FB56 3E 01                  LD     A,1
1057: FB58 32 7D FB               LD     (DiskErrorFlag),A    ; set the error flag
1058: FB5B C9                     RET
1059: FB5C
1060: FB5C         ;********************************************************************
1061: FB5C         ;********************************************************************
1062: FB5C         ;********************************************************************
1063: FB5C
1064: FB5C         ;---------------------------------------------------------------------------
1065: FB5C         ;	Disk Data
1066: FB5C         ;---------------------------------------------------------------------------
1067: FB5C         ;	Disk Equates
1068: FB5C         ;---------------------------------------------------------------------------
1069: FB5C         ; Disk Types
1070: FB5C         ;;Floppy5DD	EQU	1 						; 5 1/4" mini floppy
1071: FB5C         ;;Floppy8	EQU	2 						; 8"  floppy (SS SD)
1072: FB5C         ;;HardDisk	EQU	2						; hard disk
1073: FB5C         ;NumberOfLogicalDisks	EQU 4			; max number of disk in this system
1074: FB5C
1075: FB5C
1076: FB5C         ;**************************************************************************************************
1077: FB5C         ;  There id one "smart" disk controllers on this system, for the 3.5 HD drive ( 1.44MB)
1078: FB5C         ;
1079: FB5C         ;  The controller is "hard-wired" to monitor memory locations 0X45 to detect when it is to
1080: FB5C         ; perform some disk operation.  These are called its disk control byte.
1081: FB5C         ; If the most significant bit of  disk control byte is set, the controller will look at the word
1082: FB5C         ; following the respective control bytes. This word must contain the address of  valid disk control
1083: FB5C         ; table that specifies the exact disk operation to be performed.
1084: FB5C         ;
1085: FB5C         ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1086: FB5C         ; This indicates completion to the disk driver code.
1087: FB5C         ;
1088: FB5C         ;  The controller also sets a return code in a disk status block - location 0X43H.
1089: FB5C         ; If the first byte of this status block is less than 80H. then a disk error
1090: FB5C         ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1091: FB5C         ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1092: FB5C         ; ten times before the controller returns an error
1093: FB5C         ;
1094: FB5C         ;  The disk control table layout is shown below. Note that the controller has the capability
1095: FB5C         ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1096: FB5C         ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1097: FB5C         ; in the disk control tables be pointed back to the main control bytes in order to indicate
1098: FB5C         ; the end of the chain
1099: FB5C         ;**************************************************************************************************
1100: FB5C
1101: FB5C         ;***************************************************************************
1102: FB5C         ;	Disk Control tables
1103: FB5C         ;***************************************************************************
1104: FB5C         ;;DiskControlTable:
1105: FB5C             DCTStart:
1106: FB5C 00          DCTCommand: DB     00H                  ; Command
1107: FB5D 00          DCTUnit:   DB     00H                  ; unit (drive) number = 0 or 1
1108: FB5E 00          DCTHead:   DB     00H                  ; head number = 0 or 1
1109: FB5F 00          DCTTrack:  DB     00H                  ; track number
1110: FB60 00          DCTSector: DB     00H                  ; sector number
1111: FB61 00 00       DCTByteCount: DW     0000H                ; number of bytes to read/write
1112: FB63 00 00       DCTDMAAddress: DW     0000H                ; transfer address
1113: FB65 00 00       DCTNextStatusBlock: DW     0000H                ; pointer to next status block
1114: FB67 00 00       DCTNextControlLocation: DW     0000H                ; pointer to next control byte
1115: FB69             DCTSize    EQU    $-DCTStart
1116: FB69         ;-----------------------------------------
1117: FB69         ;WriteAllocated		EQU	00H		W_NORMAL
1118: FB69         ;WriteDirectory		EQU	01H		W_DIRECTORY
1119: FB69         ;WriteUnallocated	EQU	02H		W_NEW_BLOCK
1120: FB69         ;-----------------------------------------
1121: FB69
1122: FB69 00          WriteType: DB     00H                  ; The type of write indicated by BDOS
1123: FB6A
1124: FB6A         ; variables for physical sector -  These are moved and compared as a group, DO NOT ALTER
1125: FB6A             InBufferDkTrkSec:
1126: FB6A 00          InBufferDisk: DB     00H
1127: FB6B 00 00       InBufferTrack: DW     00H
1128: FB6D 00          InBufferSector: DB     00H
1129: FB6E 00          DataInDiskBuffer: DB     00H                  ; when non-zero, the disk buffer has data from disk
1130: FB6F 00          MustWriteBuffer: DB     00H                  ; Non-zero when data has been written into DiskBuffer,
1131: FB70         ;   but not yet written out to the disk
1132: FB70         ;---------------------------------------------------------------------------
1133: FB70         ;	Disk Storage area
1134: FB70         ;---------------------------------------------------------------------------
1135: FB70         ;     variables for selected disk, track and sector
1136: FB70         ; These are moved and compared as a group, DO NOT ALTER
1137: FB70 00          SelectedDskSecsPerHead: DB     00H                  ; Sectors / head
1138: FB71
1139: FB71             SelectedDkTrkSec:
1140: FB71 00          SelectedDisk: DB     00H
1141: FB72 00 00       SelectedTrack: DW     00H
1142: FB74 00          SelectedSector: DB     00H
1143: FB75 00 00       DMAAddress: DW     00H                  ; DMA address
1144: FB77
1145: FB77             SelectedPhysicalSector:
1146: FB77 00                     DB     00H
1147: FB78
1148: FB78         ; Parameters for writing to a previously unallocated allocation block
1149: FB78         ; These are moved and compared as a group, DO NOT ALTER
1150: FB78             UnallocatedDkTrkSec:
1151: FB78 00          UnallocatedDisk: DB     00H
1152: FB79 00 00       UnallocatedTrack: DW     00H
1153: FB7B 00          UnallocatedSector: DB     00H
1154: FB7C 00          UnalocatedlRecordCount: DB     00H                  ; Number of unallocated "records"in current previously unallocated allocation block.
1155: FB7D 00          DiskErrorFlag: DB     00H                  ; Non-Zero - unrecoverable error output "Bad Sector" message
1156: FB7E         ; Flags used inside the de-blocking code
1157: FB7E 00          PrereadSectorFlag: DB     00H                  ; non-zero if physical sector must be read into the disk buffer
1158: FB7F         ; either before a write to a allocated block can occur, or
1159: FB7F         ; for a normal cpmRecord read
1160: FB7F 00          ReadFlag:  DB     00H                  ; Non-zero when a cpmRecord is to be read
1161: FB80
1162: FB80         ;---------------------------------------------------------------------------
1163: FB80
1164: FB80         ;---------------------------------------------------------------------------
1165: FB80         ;	Disk Definition Tables
1166: FB80         ; These consists of disk parameter headers, with one entry
1167: FB80         ; per logical disk driver, and disk parameter blocks, with
1168: FB80         ; either one parameter block per logical disk or the same
1169: FB80         ; parameter block for several logical disks.
1170: FB80         ;---------------------------------------------------------------------------
1171: FB80         ;---------------------------------------------------------------------------
1172: FB80             DiskParameterHeaders:
1173: FB80
1174: FB80         ; Logical Disk A: (3.25" HD 1.44MB Diskette)
1175: FB80 00 00                  DW     0000H                ; Floppy5SkewTable  - No Skew table
1176: FB82 00 00                  DW     0000H                ; Rel pos for file (0-3)
1177: FB84 00 00                  DW     0000H                ; Last Selected Track #
1178: FB86 00 00                  DW     0000H                ; Last Selected Sector #
1179: FB88 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1180: FB8A C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1181: FB8C D0 FB                  DW     DiskAWorkArea
1182: FB8E 50 FC                  DW     DiskAAllocationVector
1183: FB90
1184: FB90         ; Logical Disk B: (3.25" HD 1.44MB Diskette)
1185: FB90 00 00                  DW     0000H                ; No Skew table
1186: FB92 00 00                  DW     0000H                ; Rel pos for file (0-3)
1187: FB94 00 00                  DW     0000H                ; Last Selected Track #
1188: FB96 00 00                  DW     0000H                ; Last Selected Sector #
1189: FB98 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1190: FB9A C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1191: FB9C F0 FB                  DW     DiskBWorkArea
1192: FB9E A9 FC                  DW     DiskBAllocationVector
1193: FBA0
1194: FBA0         ; Logical Disk C: (3.25" HD 1.44MB Diskette)
1195: FBA0 00 00                  DW     0000H                ; No Skew table
1196: FBA2 00 00                  DW     0000H                ; Rel pos for file (0-3)
1197: FBA4 00 00                  DW     0000H                ; Last Selected Track #
1198: FBA6 00 00                  DW     0000H                ; Last Selected Sector #
1199: FBA8 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1200: FBAA C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1201: FBAC 10 FC                  DW     DiskCWorkArea
1202: FBAE 02 FD                  DW     DiskCAllocationVector
1203: FBB0
1204: FBB0         ; Logical Disk D: (3.25" HD 1.44MB Diskette)
1205: FBB0 00 00                  DW     0000H                ; No Skew table
1206: FBB2 00 00                  DW     0000H                ; Rel pos for file (0-3)
1207: FBB4 00 00                  DW     0000H                ; Last Selected Track #
1208: FBB6 00 00                  DW     0000H                ; Last Selected Sector #
1209: FBB8 B4 FD                  DW     DirectoryBuffer      ; all disks use this buffer
1210: FBBA C0 FB                  DW     ParameterBlock3HD    ; specific to disk's parameters
1211: FBBC 30 FC                  DW     DiskDWorkArea
1212: FBBE 5B FD                  DW     DiskDAllocationVector
1213: FBC0
1214: FBC0
1215: FBC0         ;-----------------------------------------------------------
1216: FBC0
1217: FBC0             ParameterBlock3HD:
1218: FBC0 90 00                  DW     dpb3hdSPT            ; cpmRecords per track- (144)
1219: FBC2 04                     DB     dpb3hdBSH            ; Block shift ( 4=> 2K)
1220: FBC3 0F                     DB     dpb3hdBLM            ; Block mask
1221: FBC4 00                     DB     dpb3hdEXM            ; Extent mask
1222: FBC5 C6 02                  DW     dpb3hdDSM            ; Maximum allocation block number (710)
1223: FBC7 7F 00                  DW     dpb3hdDRM            ; Number of directory entries - 1 (127)
1224: FBC9 C0                     DB     dpb3hdAL0            ; Bit map for reserving 1 alloc. block
1225: FBCA 00                     DB     dpb3hdAL1            ;  for file directory
1226: FBCB 20 00                  DW     dpb3hdCKS            ; Disk change work area size (32)
1227: FBCD 01 00                  DW     dpb3hdOFF            ; Number of tracks before directory
1228: FBCF
1229: FBCF 12                     DB     (dpb3hdSPT/4)/dpb3hdNOH ; number of Sectors/Head
1230: FBD0
1231: FBD0
1232: FBD0
1233: FBD0         ;---------------------------------------------------------------------------
1234: FBD0         ;	Disk work area
1235: FBD0         ;---------------------------------------------------------------------------
1236: FBD0         ; These are used by the BDOS to detect any unexpected
1237: FBD0         ; change of diskette. The BDOS will automatically set
1238: FBD0         ; such a changed diskette to read-only status.
1239: FBD0
1240: FBD0             DiskAWorkArea: DS     dpb3hdCKS            ; A:  020H
1241: FBF0             DiskBWorkArea: DS     dpb3hdCKS            ; B:  020H
1242: FC10             DiskCWorkArea: DS     dpb3hdCKS            ; C:  020H
1243: FC30             DiskDWorkArea: DS     dpb3hdCKS            ; D:  020H
1244: FC50
1245: FC50         ;---------------------------------------------------------------------------
1246: FC50         ;	Disk allocation vectors
1247: FC50         ;---------------------------------------------------------------------------
1248: FC50         ; Disk allocation vectors
1249: FC50         ; These are used by the BDOS to maintain a bit map of
1250: FC50         ; which allocation blocks are used and which are free.
1251: FC50         ; One byte is used for eight allocation blocks, hence the
1252: FC50         ; expression of the form (allocation blocks/8)+1
1253: FC50
1254: FC50             DiskAAllocationVector: DS     (dpb3hdDSM/8)+1      ; A:
1255: FCA9             DiskBAllocationVector: DS     (dpb3hdDSM/8)+1      ; B:
1256: FD02
1257: FD02             DiskCAllocationVector: DS     (dpb3hdDSM/8)+1      ; C:
1258: FD5B             DiskDAllocationVector: DS     (dpb3hdDSM/8)+1      ; D:
1259: FDB4         ;---------------------------------------------------------------------------
1260: FDB4         ;	Disk Buffer
1261: FDB4         ;---------------------------------------------------------------------------
1262: FDB4             DirectoryBuffer: DS     DirBuffSize
1263: FE34         ;---------------------------------------------------------------------------
1264: FE34         ;**********************************************************************************
1265: FE34         ;	Disk Control table image for warm boot
1266: FE34         ;**********************************************************************************
1267: FE34             BootControl:
1268: FE34 01                     DB     DiskReadCode         ; Read function
1269: FE35 00                     DB     00H                  ; unit number
1270: FE36 00                     DB     00H                  ; head number
1271: FE37 00                     DB     00H                  ; track number
1272: FE38 02                     DB     02H                  ; Starting sector number (skip cold boot sector)
1273: FE39 00 16                  DW     CCPLength + BDOSLength ; Number of bytes to read ( rest of the head)
1274: FE3B 00 E0                  DW     CCPEntry             ; read into this address
1275: FE3D 43 00                  DW     DiskStatusLocation   ; pointer to next block - no linking
1276: FE3F 45 00                  DW     DiskControlByte      ; pointer to next table- no linking
1277: FE41
1278: FE41         ;
1279: FE41         ;**********************************************************************************
1280: FE41         ;	Warm Boot
1281: FE41         ;  On warm boot. the CCP and BDOS must be reloaded into memory.
1282: FE41         ; This code is hardware specific to the 3.5 HD controller.
1283: FE41         ;**********************************************************************************
1284: FE41
1285: FE41             WBOOT:
1286: FE41 31 FF DF               LD     SP,CCPEntry-1
1287: FE44 21 34 FE               LD     HL,BootControl       ; point at the disk control table
1288: FE47 22 46 00               LD     (DiskCommandBlock),HL
1289: FE4A
1290: FE4A 21 45 00               LD     HL,DiskControlByte
1291: FE4D 36 80                  LD     (HL),080H            ; activate the controller
1292: FE4F
1293: FE4F             WaitTillDone:
1294: FE4F 7E                     LD     A,(HL)               ; Get the control byte
1295: FE50 B7                     OR     A                    ; Reset to 0 (Completed operation) ?
1296: FE51 C2 4F FE               JP     NZ,WaitTillDone      ; if not try again
1297: FE54
1298: FE54 3A 43 00               LD     A,(DiskStatusLocation) ; after operation what's the status?
1299: FE57 FE 80                  CP     080H                 ; any errors ?
1300: FE59 D2 8C FE               JP     NC,EnterCPM          ; Nope
1301: FE5C         ; yes
1302: FE5C             WarmBootError:
1303: FE5C 21 72 FE               LD     HL,WarmBootErroMessage ; point at error message
1304: FE5F CD 65 FE               CALL   DisplayMessage       ; sent it. and
1305: FE62 C3 41 FE               JP     WBOOT                ; try again.
1306: FE65
1307: FE65         ;---------------------------------------------------------------------------
1308: FE65             DisplayMessage:
1309: FE65 7E                     LD     A,(HL)               ; get next message byte
1310: FE66 B7                     OR     A                    ; terminator (a = 0)?
1311: FE67 C8                     RET    Z                    ; Yes, thes return to caller
1312: FE68
1313: FE68 4F                     LD     C,A                  ; prepare for output
1314: FE69 E5                     PUSH   HL                   ; save message pointer
1315: FE6A CD 19 F9               CALL   CONOUT               ; go to main console output routine *******
1316: FE6D E1                     POP    HL
1317: FE6E 23                     INC    HL                   ; point at next character
1318: FE6F C3 65 FE               JP     DisplayMessage       ; loop till done
1319: FE72
1320: FE72             WarmBootErroMessage:
1321: FE72 0D 0A                  DB     CR,LF
1322: FE74 57 61 72 6D 20 42 6F 6F 74 20 2D                DB     'Warm Boot -'
1323: FE7F 20 52 65 74 72 79 69 6E 67 2E                DB     ' Retrying.'
1324: FE89 0D 0A                  DB     CR,LF
1325: FE8B 00                     DB     EndOfMessage
1326: FE8C
1327: FE8C         ;--------------------BOOT-----------------------------
1328: FE8C
1329: FE8C         ; entered directly from the BIOS JMP vector
1330: FE8C         ; Control transfered by the CP/M bootstrap loader
1331: FE8C         ; Sets up Page Zero
1332: FE8C         ;---------------End of Cold Boot Initialization Code--------------
1333: FE8C
1334: FE8C             BOOT:
1335: FE8C             EnterCPM:
1336: FE8C 3E C3                  LD     A,0C3H               ; JMP op code
1337: FE8E 32 00 00               LD     (0000H),A            ; set up the jump in location 0000H
1338: FE91 32 05 00               LD     (0005H),A            ; and at location 0005H
1339: FE94
1340: FE94 21 03 F6               LD     HL,WarmBootEntry     ; get BIOS vector address
1341: FE97 22 01 00               LD     (0001H),HL           ; put address in location 1
1342: FE9A
1343: FE9A 21 06 E8               LD     HL,BDOSEntry         ; Get BDOS entry point address
1344: FE9D 22 06 00               LD     (0006H),HL           ; put address at location 5
1345: FEA0
1346: FEA0 01 80 00               LD     BC,DMABuffer         ; DefaultDiskBuffer set disk I/O address to default
1347: FEA3 CD B3 F9               CALL   SETDMA               ; use normal BIOS routine
1348: FEA6
1349: FEA6 FB                     EI
1350: FEA7 3A 04 00               LD     A,(Pg0CurentDisk)    ; DefaultDisk  Transfer current default disk to
1351: FEAA 4F                     LD     C,A                  ; Console Command Processor
1352: FEAB C3 00 E0               JP     CCPEntry             ; transfer to CCP
1353: FEAE
1354: FEAE         ;-------------------------------------------------
1355: FEAE
           ************************   Xref   ************************
0000: $               FEAB   0311 1115
0315: AfterDiskBuffer F840
0079: ASCII_A         0041
0080: ASCII_C         0043
0081: ASCII_K         004B
0088: ASCII_LO_A      0061
0089: ASCII_LO_K      006B
0090: ASCII_LO_P      0070
0031: ASCII_MASK      007F
0082: ASCII_N         004E
0083: ASCII_Q         0051
0084: ASCII_R         0052
0085: ASCII_W         0057
0086: ASCII_Y         0059
0066: ASCII_ZERO      0030
0060: ASTERISK        002A
0145: BDOSBase        E800   0146 0148
0114: BDOSE           0005   0115
0146: BDOSEntry       E806   1343
0135: BDOSLength      0E00   0138 0148 0149 1273
0049: BELL            0007
0148: BIOSBase        F600
0136: BIOSLength      0A00   0138
0108: BIOSPAGE        0002
0149: BIOSStart       F600   0287
0245: BlockSize       0800   0267
1334: BOOT            FE8C   0291
1267: BootControl     FE34   1287
0899: BufferMove      FA99   0892 0941
0027: BYTE            0001
0087: CARET           005E
0143: CCPEntry        E000   0145 0149 1274 1286 1352
0134: CCPLength       0800   0138 0145 0149 1273
0780: CheckUnallocatedBlock F9EA   0769
0289: CodeStart       F600
0067: COLON           003A
0062: COMMA           002C
0997: CommonPhysical  FAF6   0992
0337: CommunicationDataPort 00EC   0359
0433: CommunicationInput F89D   0546
0339: CommunicationInputReady 0002   0361
0400: CommunicationInStatus F86A   0528
0447: CommunicationOutput F8B2   0560 0619 0634
0338: CommunicationOutputReady 0001   0360
0414: CommunicationOutStatus F87F
0336: CommunicationStatusPort 00ED   0358
0357: CommunicationTable F848   0401 0415 0434 0448
0959: CompareDkTrk    FAD3   0831
0962: CompareDkTrkSec FAD8   0789
0964: CompareDkTrkSecLoop FADA   0961 0972
0120: ComTail         0080   0121
0122: ComTailChars    0082
0121: ComTailCount    0081   0122
0540: CONIN           F90B   0295
0554: CONOUT          F919   0296 1315
0515: CONST           F8F5   0294
0222: cpmRecordSize   0080   0224 0227 0229 0883
0052: CR              000D   1321 1324
0332: CRT_DataPort    0001   0354
0428: CRT_Input       F894   0545
0334: CRT_InputReady  007F   0356
0397: CRT_InStatus    F864   0527
0444: CRT_Output      F8AC   0559 0600 0620 0635
0333: CRT_OutputReady 0080   0355
0411: CRT_OutStatus   F879   0586
0331: CRT_StatusPort  0002   0353
0352: CRT_Table       F844   0398 0412 0429 0445
0035: CTRL_C          0003
0036: CTRL_E          0005
0037: CTRL_H          0008
0038: CTRL_K          000B
0039: CTRL_L          000C
0040: CTRL_P          0010
0041: CTRL_R          0012
0042: CTRL_S          0013
0043: CTRL_U          0015
0044: CTRL_X          0018
0045: CTRL_Z          001A
0063: DASH            002D
0256: DataBlocks      02C7   0266
1129: DataInDiskBuffer FB6E   0653 0821
0255: DataSectors     0B1C   0256
1111: DCTByteCount    FB61   1025
1106: DCTCommand      FB5C   0998 1035
1112: DCTDMAAddress   FB63   1027
1108: DCTHead         FB5E   1022
1114: DCTNextControlLocation FB67   1034
1113: DCTNextStatusBlock FB65   1032
1110: DCTSector       FB60   1020
1115: DCTSize         000B
1105: DCTStart        FB5C   1115
1109: DCTTrack        FB5F   1004
1107: DCTUnit         FB5D   1001
0227: DirBuffSize     0080   1262
0242: DirectoryBlockCount 0002   0267
1262: DirectoryBuffer FDB4   1179 1189 1199 1209
0229: DirectoryEntryPerRecord 0004   0270
0226: DirEntrySize    0020   0229 0267
1254: DiskAAllocationVector FC50   1182
1240: DiskAWorkArea   FBD0   1181
1255: DiskBAllocationVector FCA9   1192
0313: DiskBuffer      F640   0877 1026
1241: DiskBWorkArea   FBF0   1191
1257: DiskCAllocationVector FD02   1202
0214: DiskCommandBlock 0046   1036 1288
0213: DiskControlByte 0045   1033 1038 1276 1290
0216: DiskControlTable 0040
1242: DiskCWorkArea   FC10   1201
1258: DiskDAllocationVector FD5B   1212
1243: DiskDWorkArea   FC30   1211
1055: DiskError       FB56   1050
1155: DiskErrorFlag   FB7D   0815 0946 0955 1052 1057
1172: DiskParameterHeaders FB80   0679
0218: DiskReadCode    0001   0995 1268
0223: diskSectorSize  0200   0224 0245 0253 0314 1024
0212: DiskStatusLocation 0043   1031 1048 1275 1298
0219: DiskWriteCode   0002   0991
1308: DisplayMessage  FE65   1304 1318
1143: DMAAddress      FB75   0719 0880
0125: DMABuffer       0080   1346
0056: DOLLAR          0024
0268: dpb3hdAL0       00C0   1224
0269: dpb3hdAL1       0000   1225
0264: dpb3hdBLM       000F   1220
0263: dpb3hdBSH       0004   1219
0270: dpb3hdCKS       0020   1226 1240 1241 1242 1243
0267: dpb3hdDRM       007F   0270 1223
0266: dpb3hdDSM       02C6   1222 1254 1255 1257 1258
0265: dpb3hdEXM       0000   1221
0272: dpb3hdNOH       0002   1229
0271: dpb3hdOFF       0001   1227
0262: dpb3hdSPT       0090   1218 1229
0436: DummyInput      F8A3   0547
0403: DummyInStatus   F870   0529
0453: DummyOutput     F8BE   0561 0602 0618 0633
0420: DummyOutStatus  F88B   0588
0129: END_OF_FILE     001A   0437
0033: EndOfMessage    0000   1325
1335: EnterCPM        FE8C   1300
0071: EQUAL_SIGN      003D
0054: EXCLAIM_POINT   0021
0022: FALSE           0000
0117: FCB1            005C   0118
0118: FCB2            006C
0162: fCloseFile      0010
0153: fConsoleIn      0001
0154: fConsoleOut     0002
0165: fDeleteFile     0013
0157: fGetConsoleStatus 000B
0171: fGetCurrentDisk 0019
0170: fGetLoginVector 0018
0173: fGetSetUserNumber 0020
0158: fGetVersion     000C
0168: fMakeFile       0016
0161: fOpenFile       000F
0155: fPrintString    0009
0166: fReadSeq        0014
0156: fReadString     000A
0169: fRenameFile     0017
0159: fResetSystem    000D
0163: fSearchFirst    0011
0164: fSearchNext     0012
0160: fSelectDisk     000E
0172: fSetDMA         001A
0167: fWriteSeq       0015
0522: GetConsoleStatus F8FD   0516
0579: GetListStatus   F92F   0573
0072: GREATER_THAN    003E
0055: HASH_TAG        0023
1010: Head0           FB10   1016
1018: Head1           FB19   1012
0649: HOME            F971   0300
0654: HomeNoWrite     F97B   0652
1126: InBufferDisk    FB6A   0847 0999
1125: InBufferDkTrkSec FB6A   0829
1128: InBufferSector  FB6D   0834 0851 1009
1127: InBufferTrack   FB6B   0849 1002
0283: INopCode        00DB   0460 0477 0485
0469: InputData       F8CA   0427 0430 0435 0473
0478: InputDataPort   F8D8   0476
0457: InputStatus     F8BF   0396 0399 0402 0419 0471
0461: InputStatusPort F8C4   0459
0109: IOBYTE          0003   0523 0541 0555 0580 0594 0610 0627
0058: L_PAREN         0028
0075: LEFT_ARROW      005F
0091: LEFT_CURLY      007B
0138: LengthInBytes   2000   0139 0143 0253
0139: LengthInK       0009
0070: LESS_THAN       003C
0051: LF              000A   1321 1324
0593: LIST            F93F   0297
0566: LISTST          F927   0307
0025: LO_NIBBLE_MASK  000F
0141: MemorySize      0040   0143
0976: MoveDkTrkSec    FAE4   0776
0978: MoveDkTrkSecLoop FAE6   0985
1130: MustWriteBuffer FB6F   0650 0840 0861 0895 0953
0254: myOffset        0001   0255 0271
0800: NoTrackChange   FA12   0795
0047: NULL            0000
0238: NumberOfHeads   0002   0249 0251 0262 0272
0235: NumberOfLogicalDisks 0004   0667
0024: OFF             0000
0023: ON              FFFF
0284: OUTopCode       00D3   0502
0493: OutputData      F8E4   0443 0446 0449 0452 0497
0503: OutputDataPort  F8F3   0500
0482: OutputStatus    F8DA   0410 0413 0416 0495
0486: OutputStatusPort F8DF   0484
1217: ParameterBlock3HD FBC0   1180 1190 1200 1210
0057: PERCENT         0025
0813: PerformReadWrite FA21   0746 0803
0064: PERIOD          002E
0112: Pg0CurentDisk   0004   1350
0111: Pg0CurentUser   0004   0112
0061: PLUS_SIGN       002B
1157: PrereadSectorFlag FB7E   0743 0802 0809 0853
0342: PrinterDataPort 0010   0364
0344: PrinterInputReady 007F   0366
0450: PrinterOutput   F8B8   0601
0343: PrinterOutputReady 00FF   0365
0417: PrinterStatus   F885   0587
0341: PrinterStatusPort 0011   0363
0362: PrinterTable    F84C   0418 0451
0608: PUNCH           F94F   0298
0073: QMARK           003F
0059: R_PAREN         0029
0105: RAM             0000   0107 0108 0109 0111 0114 0117 0120 0125 0127
0738: READ            F9BC   0305
0626: READER          F961   0299
1160: ReadFlag        FB7F   0742 0765 0890
0994: ReadPhysical    FAF4   0855
0844: ReadSectorIntoBuffer FA56   0825
0247: RecordsPerBlock 0010   0772
0231: RecordsPerExtent 0080
0224: recordsPerSector 0004   0247 0262
0805: RequestPreread  FA19   0783 0790
0076: RUBOUT          007F
0865: SectorInBuffer  FA73   0837
0276: SectorMask      0003   0867
0839: SectorNotInBuffer FA4F   0832
0241: SectorsPerBlock 0004   0245 0247 0250 0256 0276
0251: SectorsPerCylinder 0024   0254 0255
0240: SectorsPerTrack 0012   0249 0251 0262 0794
0727: SECTRAN         F9B9   0308
0664: SELDSK          F981   0301
1140: SelectedDisk    FB71   0670 0846
1139: SelectedDkTrkSec FB71   0774 0787 0830
1137: SelectedDskSecsPerHead FB70   0690 1008
1145: SelectedPhysicalSector FB77   0820 0835 0850
1142: SelectedSector  FB74   0710 0816 0866
1141: SelectedTrack   FB72   0702 0848
0377: SelectRoutine   F850   0524 0542 0556 0583 0597 0615 0630
0069: SEMICOLON       003B
0716: SETDMA          F9B3   0304 1347
0708: SETSEC          F9AE   0303
0699: SETTRK          F9A8   0302 0656
0065: SLASH           002F
0048: SOH             0001
0053: SPACE           0020
0253: SystemSectors   0011   0254
0050: TAB             0009
0115: TopRAM          0007
0250: TotalNumberOfBlocks 02D0
0249: TotalNumberOfSectors 0B40   0250 0255
0127: TPA             0100
0239: TracksPerHead   0050   0249
0021: TRUE            FFFF
0327: TTYDataPort     00EC   0349
0425: TTYInput        F88E   0544
0329: TTYInputReady   0002   0351
0394: TTYInStatus     F85E   0526
0441: TTYOutput       F8A6   0558 0599 0617 0632
0328: TTYOutputReady  0001   0350
0408: TTYOutStatus    F873   0585
0326: TTYStatusPort   00ED   0348
0347: TTYTable        F840   0395 0409 0426 0442
1151: UnallocatedDisk FB78
1150: UnallocatedDkTrkSec FB78   0775 0788
1153: UnallocatedSector FB7B
1152: UnallocatedTrack FB79   0797 0799
1154: UnalocatedlRecordCount FB7C   0740 0773 0781 0785 0807
0074: UNDER_SCORE     005F
1043: WaitForDiskComplete FB44   1046
1293: WaitTillDone    FE4F   1296
0107: WarmBoot        0000
0292: WarmBootEntry   F603   1340
1320: WarmBootErroMessage FE72   1303
1302: WarmBootError   FE5C
1285: WBOOT           FE41   0293 1305
0028: WORD            0002
0762: WRITE           F9CF   0306
0187: WriteAllocated  0000
0188: WriteDirectory  0001   0945
0990: WritePhysical   FAEF   0842 0954
1122: WriteType       FB69   0745 0767 0944
0189: WriteUnallocated 0002   0744 0768
0032: ZERO            0000
