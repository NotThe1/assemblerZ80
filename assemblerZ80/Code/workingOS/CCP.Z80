;     File created by MakeZ80Source on Tue Sep 18 14:13:13 EDT 2018 from:
;     C:\Users\admin\Dropbox\Resources\CPM\CurrentOS\8080\CCP.asm
 ; CCP.asm
 ;
 ; 2017-03-02 Refactored the CP/M Suite
 ; 2014-01-16
 ; 2014-05-01  :  Frank Martyn
 
 ; replace systemFile with fcbSystemFileIndex
 
 	$Include ./stdHeader.Z80
 	$Include ./osHeader.Z80
 	$Include ./diskHeader.Z80
 
 
 fcbSystemFileIndex		EQU		0AH			; extent number field index
 iFunctionNameSize		EQU		04			; size of intrinsic function names
 
 
 
 					ORG	CCPEntry
 
 CcpBoundary			EQU	$
 
 	JP		CcpStart						;start ccp with possible initial command
 ;*****************************************************************
 ;enter here from boot loader
 CcpStart:
 	LD		SP,Stack
 	PUSH	BC								; save initial disk number
 											; (high order 4bits=user code, low 4bits=disk#)
 	LD		A,C
 	RRA
 	RRA
 	RRA
 	RRA
 	AND		LO_NIBBLE_MASK					; user code
 	LD		E,A
 	CALL	SetUser							; user code selected
 											; initialize for this user, get $ flag
 	CALL	Initialize						; 0ffh in accum if $ file present
 	LD		(submitFlag),A						; submit flag set if $ file present
 	POP		BC								; recall user code and disk number
 	LD		A,C
 	AND		LO_NIBBLE_MASK					; disk number in accumulator
 	LD		(Pg0CurentDisk),A					; clears low memory user code nibble
 	CALL	SelectDisk						; proper disk is selected, now check sub files
 											; check for initial command
 	LD		 A,(CommandLength)
 	OR		A
 	JP	NZ,Ccp0							;assume typed already
 
 Ccp:										;enter here on each command or error condition
 	LD		SP,Stack
 	CALL	CrLf							; print d> prompt, where d is disk name
 	CALL	GetSelectedDrive				; get current disk number
 	ADD	A,ASCII_A
 	CALL	PrintChar
 	LD		A,GREATER_THAN
 	CALL	PrintChar
 	CALL	ReadCommand						; command buffer filled
 Ccp0:										; ccp0 enter here from initialization with command full
 	LD		DE,DMABuffer
 	CALL	SetDMA							; default dma address at DMABuffer
 	CALL	GetSelectedDrive
 	LD		(currentDisk),A						; current disk number saved
 	CALL	FillFCB0						; command fcb filled
 	CALL	NZ,CommandError					; the name cannot be an ambiguous reference
 	LD		 A,(selectedDisk)
 	OR		A
 	JP	NZ,ccpUserFunction
 
 	CALL	IntrinsicFunction				; check for an intrinsic function
 	LD		HL,intrinsicFunctionsVector		; index is in the accumulator
 	LD		E,A
 	LD		D,0
 	ADD		HL,DE
 	ADD		HL,DE								; index in d,e
 	LD		A,(HL)
 	INC		HL
 	LD		H,(HL)
 	LD		L,A
 	JP(HL) 									; pc changes to the proper intrinsic or user function
 ;.................................................
 ;.................................................
 
 intrinsicFunctionsVector:					; jmptab
 	DW		ccpDirectory					; directory search
 	DW		ccpErase						; file erase
 	DW		ccpType							; type file
 	DW		ccpSave							; save memory image
 	DW		ccpRename						; file rename
 	DW		ccpUser							; user number
 	DW		ccpUserFunction					; user-defined function
 
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;read the next command into the command buffer
 ;check for submit file
 ReadCommand:
 	LD		 A,(submitFlag)
 	OR		A
 	JP	Z,NotSubmitFile
 ; scanning a submit file change drives to open and read the file
 	LD		 A,(currentDisk)
 	OR		A
 	LD		A,0
 	CALL	NZ,SelectDisk
 ; have to open again in case xsub present
 	LD		DE,submitFCB
 	CALL	OpenFile
 	JP	Z,NotSubmitFile					; skip if no submit file
 	LD		 A,(subRecordCount)
 	DEC		A								; read last record(s) first
 	LD		(subCurrentRecord),A				; current record to read
 	LD		DE,submitFCB
 	CALL	DiskRead						; end of file if last record
 	JP	NZ,NotSubmitFile
 ; disk read is ok, transfer to commandBuffer
 	LD		DE,CommandLength
 	LD		HL,DMABuffer
 	LD		B,cpmRecordSize					; number of bytes to Copy
 	CALL	CopyHL2DEforB
 ; line is transferred, close the file with a deleted record
 	LD		HL,subModuleNumber
 	LD		(HL),0								; clear fwflag
 	INC		HL
 	DEC		M								; one less record
 	LD		DE,submitFCB
 	CALL	CloseFile
 	JP	Z,NotSubmitFile
 ; CloseFile went ok, return to original drive
 	LD		 A,(currentDisk)
 	OR		A
 	CALL	NZ,SelectDisk
 ; print to the 00
 	LD		HL,commandBuffer
 	CALL	PrintStringNull
 	CALL	CheckForConsoleChar
 	JP	Z,NoRead
 	CALL	DeleteSubmitFile
 	JP		DeleteSubmitFile				; break key depressed
 
 NotSubmitFile:
 	CALL	DeleteSubmitFile
 ; translate to upper case, store zero at end
 	CALL	SaveUser						; user # save in case control c
 	LD		C,fReadString
 	LD		DE,MaxBufferLength
 	CALL	BDOSE
 	CALL	SetPage0CurDisk					; no control c, so restore Pg0CurentDisk
 
 NoRead:
 ; set the last character to zero for later scans
 	LD		HL,CommandLength
 	LD		B,(HL)								; length is in b
 ReadCommand1:								; readcom0
 	INC		HL
 	LD		A,B
 	OR		A								; end of scan?
 	JP	Z,ReadCommand2
 	LD		A,(HL)								; get character and translate
 	CALL	UpCase
 	LD		(HL),A
 	DEC		B
 	JP		ReadCommand1
 
 ;end of scan, h,l address end of command
 ReadCommand2:
 	LD		(HL),A								;store a zero
 	LD		HL,commandBuffer
 	LD	(commandAddress),HL					; ready to scan to zero
 	RET
 ;----------------------------------------------------------------
 
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;return current user code in A
 GetUser:
 	LD		E,0FFH							; drop through to setuser
 ;------
 SetUser:
 	LD		C,fGetSetUserNumber
 	JP		BDOSE							; sets user number
 ;-----------------------------
 Initialize:
 	LD		C,fResetSystem
 	JP		BDOSE
 ;-----------------------------
 SelectDisk:
 	LD		E,A
 	LD		C,fSelectDisk
 	JP		BDOSE
 ;-----------------------------
 ;get the currently selected drive number to A
 GetSelectedDrive:
 	LD		C,fGetCurrentDisk
 	JP		BDOSE
 ;-----------------------------
 ;open the file given by (DE)
 OpenFile:
 	LD		C,fOpenFile
 	JP		BDOSandIncA
 ;--------
 ;open file for Command FCB
 OpenFile4CmdFCB:
 	XOR		A
 	LD		(currentRecord),A					; clear next record to read
 	LD		DE,commandFCB
 	JP		OpenFile
 ;-----------------------------
 ;close the file given by (DE)
 CloseFile:
 	LD		C,fCloseFile
 	JP		BDOSandIncA
 ;-----------------------------
 ;delete the file given by (DE)
 DeleteFile:
 	LD		C,fDeleteFile
 	JP		BDOSE
 ;-----------------------------
 ;make the file given by (DE)
 MakeFile:
 	LD		C,fMakeFile
 	JP		BDOSandIncA
 ;-----------------------------
 ;read the next record from the file given by d,e
 DiskRead:
 	LD		C,fReadSeq
 	JP		BDOSsetFlags
 ;-----------
 ;read next record from Command FCB
 DiskReadCmdFCB:
 	LD		DE,commandFCB
 	JP		DiskRead
 ;-----------------------------
 ;write the next record to the file given by (DE)
 DiskWrite:
 	LD		C,fWriteSeq
 	JP		BDOSsetFlags
 ;-----------------------------
 ;search for the file given by d,e
 SearchForFirst:
 	LD		C,fSearchFirst
 	JP		BDOSandIncA
 ;-----
 ;search for commandFCB file
 Searc4CmdFcbFile:
 	LD		DE,commandFCB
 	JP		SearchForFirst
 ;-----------------------------
 ;search for the next occurrence of the file given by d,e
 SearchForNext:
 	LD		C,fSearchNext
 	JP		BDOSandIncA
 ;-----------------------------
 ; rename a file give bu (DE)
 RenameFile:
 	LD		C,fRenameFile
 	JP		BDOSE
 ;-----------------------------
 ;set default buffer dma address
 SetDefaultDMA:
 	LD		DE,DMABuffer
 ;---------
 ;set dma address to d,e
 SetDMA:
 	LD		C,fSetDMA
 	JP		BDOSE
 ;-----------------------------
 ; call BDOS and set Flags
 BDOSsetFlags:
 	CALL	BDOSE
 	OR		A								; set return code flags
 	RET
 ;-----------------------------
 ;call BDOS  - increment result - store in directory count
 BDOSandIncA:
 	CALL	BDOSE
 	LD		(directoryCount),A
 	INC		A
 	RET
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;----------------------------------------------------------------
 ;check for a character ready at the console
 CheckForConsoleChar:
 	LD		C,fGetConsoleStatus
 	CALL	BDOSE
 	OR		A
 	RET	Z; return no char waiting
 	LD		C,fConsoleIn
 	CALL	BDOSE							; character cleared
 	OR		A
 	RET
 ;-----------------------------
 ;delete the submit file, and set submit flag to false
 DeleteSubmitFile:
 	LD		HL,submitFlag
 	LD		A,(HL)
 	OR		A
 	RET	Z; return if no sub file
 	LD		(HL),0								; submit flag is set to false
 	XOR		A
 	CALL	SelectDisk						; on drive a to erase file
 	LD		DE,submitFCB
 	CALL	DeleteFile
 	LD		 A,(currentDisk)
 	JP		SelectDisk 						;back to original drive
 ;-----------------------------
 ;save user#/disk# before possible ^c or transient
 SaveUser:
 	CALL	GetUser							; code to a
 	ADD		A,A
 	ADD		A,A
 	ADD		A,A
 	ADD		A,A								; rotate left
 	LD		HL,currentDisk
 	OR		M								; msn 4b=user - lsn 4b=disk
 	LD		(Pg0CurentDisk),A					; stored away in memory for later
 	RET
 ;-----------------------------
 ; set Pg0CurentDisk to current disk
 SetPage0CurDisk:
 	LD		 A,(currentDisk)
 	LD		(Pg0CurentDisk),A					; user/disk
 	RET
 ;-----------------------------
 ;equivalent to fillfcb(0)
 FillFCB0:
 	LD		A,0
 FillFCB:
 	LD		HL,commandFCB
 	CALL	AddA2HL
 	PUSH	HL
 	PUSH	HL								; fcb rescanned at end
 	XOR		A
 	LD		(selectedDisk),A					; clear selected disk (in case A:...)
 	LD	HL,(commandAddress)
 	EX	DE,HL ; command address in d,e
 	CALL	NextNonBlankChar				; move to first non-blank character
 	EX	DE,HL 
 	LD	(fillFCBStart),HL					; in case of errors
 	EX	DE,HL 
 	POP		HL								; d,e has command, h,l has fcb address
 											; look for preceding file name A: B: ...
 	LD	A,(DE)
 	OR		A
 	JP	Z,FillSetCurrentDisk				; use current disk if empty command
 	SBC	A,040H							; ASCII_A-1
 	LD		B,A								; disk name held in b if : follows
 	INC		DE
 	LD	A,(DE)
 	CP		COLON
 	JP	Z,FillSetDiskName					; set disk name if :
 
 setcur:
 	DEC		DE								; back to first character of command
 
 FillSetCurrentDisk:
 	LD		 A,(currentDisk)
 	LD		(HL),A
 	JP		SetFileName
 
 ;set disk to name in register b
 FillSetDiskName:
 	LD		A,B
 	LD		(selectedDisk),A					; mark as disk selected
 	LD		(HL),B
 	INC		DE								; past the :
 ;set the file name field
 SetFileName:
 	LD		B,8								; file name length (max)
 SetFileName1:
 	CALL	NextDelimiter
 	JP	Z,PadTheName						; not a delimiter
 	INC		HL
 	CP		ASTERISK
 	JP	NZ,SetFileName2					; must be ?'s
 	LD		(HL),QMARK
 	JP		SetFileName3					; to dec count
 
 SetFileName2:
 	LD		(HL),A								; store character to fcb
 	INC		DE
 SetFileName3:
 	DEC		B								; count down length
 	JP	NZ,SetFileName1
 TruncateName:
 	CALL	NextDelimiter
 	JP	Z,SetTypeField					; set type field if delimiter
 	INC		DE
 	JP		TruncateName
 
 PadTheName:
 	INC		HL
 	LD		(HL),SPACE
 	DEC		B
 	JP	NZ,PadTheName
 SetTypeField:
 	LD		B,3
 	CP		PERIOD
 	JP	NZ,PadTypeField					; skip the type field if no .
 	INC		DE								; past the ., to the file type field
 SetTypeField1:
 	CALL	NextDelimiter
 	JP	Z,PadTypeField
 	INC		HL
 	CP		ASTERISK
 	JP	NZ,SetTypeField2
 	LD		(HL),QMARK							;since * specified
 	JP		SetTypeField3
 
 ;  not a *, so copy to type field
 SetTypeField2:
 	LD		(HL),A
 	INC		DE
 SetTypeField3:
 	DEC		B
 	JP	NZ,SetTypeField1
 											; end of type field, truncate the rest
 TruncateType:
 	CALL	NextDelimiter
 	JP	Z,FillRestofFCB
 	INC		DE
 	JP		TruncateType
 
 PadTypeField:
 	INC		HL
 	LD		(HL),SPACE
 	DEC		B
 	JP	NZ,PadTypeField
 ; fill end of the filename/filetype fill, save command address
 FillRestofFCB:
 ; fill the remaining fields for the fcb
 	LD		B,3
 FillRestofFCB1:
 	INC		HL
 	LD		(HL),0
 	DEC		B
 	JP	NZ,FillRestofFCB1
 	EX	DE,HL 
 	LD	(commandAddress),HL					; set new starting point
 ; recover the start address of the fcb and count ?'s
 	POP		HL
 	LD		BC,11							; b=0, c=8+3
 QuestionMarkCount:
 	INC		HL
 	LD		A,(HL)
 	CP		QMARK
 	JP	NZ,QuestionMarkCount1
 ; ? found, count it in b
 	INC		B
 QuestionMarkCount1:
 	DEC		C
 	JP	NZ,QuestionMarkCount
 ; number of ?'s in c, move to a and return with flags set
 	LD		A,B
 	OR		A
 	RET
 ;-----------------------------
 ;find the next non blank character in line pointed to by DE
 NextNonBlankChar:
 	LD	A,(DE)
 	OR		A
 	RET	Z; treat end of line as blank
 	CP		SPACE
 	RET	NZ
 	INC		DE
 	JP		NextNonBlankChar
 ;-----------------------------
 ;find thedelimiter in line pointed to by DE
 NextDelimiter:
 	LD	A,(DE)
 	OR		A
 	RET	Z; not the last element
 	CP		SPACE
 	JP	C,CommandError					; non graphic
 	RET	Z; treat blank as delimiter
 	CP		EQUAL_SIGN
 	RET	Z
 	CP		UNDER_SCORE						; left arrow ?
 	RET	Z
 	CP		PERIOD
 	RET	Z
 	CP		COLON
 	RET	Z
 	CP		SEMICOLON
 	RET	Z
 	CP		LESS_THAN
 	RET	Z
 	CP		GREATER_THAN
 	RET	Z
 	RET										; delimiter not found
 ;-----------------------------
 ; get number from the command line
 GetNumberFromCmdLine:
 	CALL	FillFCB0						; should be number
 	LD		 A,(selectedDisk)
 	OR		A
 	JP	NZ,CommandError					; cannot be prefixed
 ; convert the byte value in commandFCB to binary
 	LD		HL,commandFCB + 1
 	LD		BC,11							;(b=0, c=11)
 											; value accumulated in b, c counts name length to zero
 GetNumericValue:
 	LD		A,(HL)
 	CP		SPACE
 	JP	Z,GetNumericValue1
 ; more to scan, convert char to binary and add
 	INC		HL
 	SUB		ASCII_ZERO
 	CP		10
 	JP	NC,CommandError					; valid?
 	LD		D,A								; save value
 	LD		A,B								; mult by 10
 	AND		11100000B
 	JP	NZ,CommandError
 	LD		A,B								; recover value
 	RLCA
 	RLCA
 	RLCA										; *8
 	ADD		A,B
 	JP	C,CommandError
 	ADD		A,B
 	JP	C,CommandError					; *8+*2 = *10
 	ADD		A,D
 	JP	C,CommandError					 ; +digit
 	LD		B,A
 	DEC		C
 	JP	NZ,GetNumericValue					; for another digit
 	RET
 GetNumericValue1:							; conv1 end of digits, check for all blanks
 	LD		A,(HL)
 	CP		SPACE
 	JP	NZ,CommandError					;blanks?
 	INC		HL
 	DEC		C
 	JP	NZ,GetNumericValue1
 	LD		A,B								;recover value
 	RET
 ;-----------------------------
 ;-----------------------------
 ;intrinsic function names four characters each
 intrinsicFunctionNames:
 	DB		'DIR '
 	DB		'ERA '
 	DB		'TYPE'
 	DB		'SAVE'
 	DB		'REN '
 	DB		'USER'
 IntrinsicFunctionCount	EQU	(($-intrinsicFunctionNames)/iFunctionNameSize) + 1
 ;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
 
 ;-----------------------------
 ;look for intrinsic functions (commandFCB has been filled)
 IntrinsicFunction:
 	LD		HL,intrinsicFunctionNames
 	LD		C,0
 IntrinsicFunction1:
 	LD		A,C
 	CP		IntrinsicFunctionCount
 	RET	NC; exit if done
 	LD		DE,commandFCB+1					; beginning of name
 	LD		B,iFunctionNameSize				; length of match is in b
 IntrinsicFunction2:
 	LD	A,(DE)
 	CP		M								; match?
 	JP	NZ,IntrinsicFunction3				; skip if no match
 	INC 	DE
 	INC		HL
 	DEC		B
 	JP	NZ,IntrinsicFunction2				; loop while matching
 ; complete match on name, check for blank in fcb
 	LD	A,(DE)
 	CP		SPACE
 	JP	NZ,IntrinsicFunction4				; otherwise matched
 	LD		A,C
 	RET										; with intrinsic number in A
 
 IntrinsicFunction3:
 	INC		HL
 	DEC		B
 	JP	NZ,IntrinsicFunction3
 
 IntrinsicFunction4:							; try next intrinsic
 	INC		C
 	JP		IntrinsicFunction1			; for another round
 ;-----------------------------
 ;*****************************************************************
 ;************************ Utilities ******************************
 ;*****************************************************************
 ;-----------------------------
 PrintSpace:
 	LD		A,SPACE
 	JP		PrintSaveBC
 ;-----------------------------
 CrLf:
 	LD		A,CR
 	CALL	PrintSaveBC
 	LD		A,LF
 	JP		PrintSaveBC
 ;-----------------------------
 ;print character, but save b,c registers
 PrintSaveBC:
 	PUSH	BC
 	CALL	PrintChar
 	POP		BC
 	RET
 ;-----------------------------
 PrintChar:
 	LD		E,A
 	LD		C,fConsoleOut
 	JP		BDOSE
 ;-----------------------------
 ;print CRLF then null terminated string at (BC)
 PrintCrLfStringNull:
 	PUSH	BC
 	CALL	CrLf
 	POP		HL 								;now print the string
 ;print null terminated string at (HL)
 PrintStringNull:
 	LD		A,(HL)
 	OR		A
 	RET	Z; stop on 00
 	INC		HL
 	PUSH	HL								; ready for next
 	CALL	PrintChar
 	POP		HL								; character printed
 	JP		PrintStringNull 				;for
 ;-----------------------------
 ;print no file message
 PrintNoFile:
 	LD		BC,msgNoFile
 	JP		PrintCrLfStringNull
 
 msgNoFile: DB 'NO FILE',0
 ;-----------------------------
 ;move 3 characters from h,l to d,e addresses
 CopyHL2DE3:
 	LD		B,3
 CopyHL2DEforB:
 	LD		A,(HL)
 	LD	(DE),AE
 	INC		HL
 	INC		DE
 	DEC		B
 	JP	NZ,CopyHL2DEforB
 	RET
 ;-----------------------------
 ;return (HL) = (A) + (HL)
 AddA2HL:
 	ADD		A,L
 	LD		L,A
 	RET	NC
 	INC		H
 	RET
 ;-----------------------------
 ;DMABuffer + a + c to h,l followed by fetch
 GetByteAtAandCandDMA:
 	LD		HL,DMABuffer					; 0080H
 	ADD		A,C
 	CALL	AddA2HL
 	LD		A,(HL)
 	RET
 ;-----------------------------
 ;convert character in register A to upper case
 UpCase:
 	CP		061H
 	RET	C;return if below lower case a
 	CP		07BH
 	RET	NC;return if above lower case z
 	AND		05FH
 	RET
 ;-----------------------------
 ;-----------------------------
 ;*****************************************************************
 ;************************ Error messages ******************************
 ;*****************************************************************
 ;print the read error message
 PrintReadError:
 	LD		BC,msgReadErr
 	JP		PrintCrLfStringNull
 msgReadErr:
 	DB		'READ ERROR',0
 ;-----------------------------
 
 
 ;*****************************************************************
 ;-----------------------------
 ;error in command string
 ;starting at position;'fillFCBStart' and ending with first delimiter
 
 CommandError:
 	CALL	CrLf							; space to next line
 	LD	HL,(fillFCBStart)					; h,l address first to print
 CommandError1:								; print characters until blank or zero
 	LD		A,(HL)
 	CP		SPACE
 	JP	Z,CommandError2					; not blank
 	OR		A
 	JP	Z,CommandError2					; not zero, so print it
 	PUSH	HL
 	CALL	PrintChar
 	POP		HL
 	INC		HL
 	JP		CommandError1					; for another character
 CommandError2:								; print question mark,and delete sub file
 	LD		A,QMARK
 	CALL	PrintChar
 	CALL	CrLf
 	CALL	DeleteSubmitFile
 	JP		Ccp								; restart with next command
 ;--------------------------------------------------------
 ;reset disk
 ResetDisk:
 	LD		 A,(selectedDisk)
 	OR		A
 	RET	Z; no action if not selected
 	DEC		A
 	LD		HL,currentDisk
 	CP		M
 	RET	Z; same disk
 	LD		 A,(currentDisk)
 	JP		SelectDisk
 ;--------------------------------------------------------
 ;reset disk before end of command check
 ResetDiskAtCmdEnd:
 	CALL	ResetDisk
 ;end of intrinsic command
 EndCommand:
 	CALL	FillFCB0						; to check for garbage at end of line
 	LD		 A,(commandFCB) + 1
 	SUB		SPACE
 	LD		HL,selectedDisk
 	OR		M
 ; 0 in accumulator if no disk selected, and blank fcb
 	JP	NZ,CommandError
 	JP		Ccp
 ;*****************************************************************
 ;************************ CCP Commands ***************************
 ;*****************************************************************
 
 ;******************** Directory Listing ***************************
 ;Directory Listing
 ccpDirectory:
 	CALL	FillFCB0						; commandFCB gets file name
 	CALL	SetDisk4Cmd						; change disk drives if requested
 	LD		HL,commandFCB+1
 	LD		A,(HL)								; may be empty request
 	CP		SPACE
 	JP	NZ,ccpDir2							; skip fill of ??? if not blank
 											; set commandFCB to all ??? for current disk
 	LD		B,11							; length of fill ????????.???
 ccpDir1:
 	LD		(HL),QMARK
 	INC		HL
 	DEC		B
 	JP	NZ,ccpDir1
 ; not a blank request, must be in commandFCB
 ccpDir2:
 	LD		E,0
 	PUSH	DE								; E counts directory entries
 	CALL	Searc4CmdFcbFile				; first one has been found
 	CALL	Z,PrintNoFile						; not found message
 ccpDir3:
 	JP	Z,ccpDirEnd
 ; found, but may be system file
 	LD		 A,(directoryCount)					; get the location of the element
 	RRCA
 	RRCA
 	RRCA
 	AND		1100000B
 	LD		C,A
 ; c contains base index into DMABuffer for dir entry
 	LD		A,fcbSystemFileIndex			; System File Location in FCB
 	CALL	GetByteAtAandCandDMA			; value to A
 	RLA
 	JP	C,ccpDir7							; skip if system file c holds index into buffer
 ;  another fcb found, new line?
 	POP		DE								; get directory entry count (E)
 	LD		A,E
 	INC		E
 	PUSH	DE								; save dir entry count
 	AND		11B								; e=0,1,2,3,...new line if mod 4 = 0
 	PUSH	AF								; and save the test
 	JP	NZ,ccpDirHeader					; header on current line
 ; print the header drive with Colon ie A:
 	CALL	CrLf
 	PUSH	BC
 	CALL	GetSelectedDrive
 	POP		BC
 	ADD	A,ASCII_A
 	CALL	PrintSaveBC
 	LD		A,COLON
 	CALL	PrintSaveBC						; just printed drive with Colon ie A:
 	JP		ccpDirHeader1					; skip current line hdr
 
 ccpDirHeader:
 	CALL	PrintSpace						; after last one
 	LD		A,COLON
 	CALL	PrintSaveBC
 ccpDirHeader1:
 	CALL	PrintSpace
 ; compute position of name in buffer
 	LD		B,1								; start with first character of name
 ccpDir4:
 	LD		A,B
 	CALL	GetByteAtAandCandDMA			; DMABuffer+a+c fetched
 	AND		ASCII_MASK						; mask flags
 ; may delete trailing blanks
 	CP		SPACE
 	JP	NZ,ccpDir5							; check for blank type
 	POP		AF
 	PUSH	AF								; may be 3rd item
 	CP		3
 	JP	NZ,ccpDirSpace						; place blank at end if not
 	LD		A,9
 	CALL	GetByteAtAandCandDMA			; first char of type
 	AND		ASCII_MASK
 	CP		SPACE
 	JP	Z,ccpDir6
 ; not a blank in the file type field
 ccpDirSpace:
 	LD		A,SPACE							; restore trailing filename chr
 ccpDir5:
 	CALL	PrintSaveBC						; char printed
 	INC		B
 	LD		A,B
 	CP		12
 	JP	NC,ccpDir6
 											; check for break between names
 	CP		9
 	JP	NZ,ccpDir4							; for another char
 
 	CALL	PrintSpace						; print a blank between names
 	JP		ccpDir4
 
 ccpDir6:									; end of current entry
 	POP		AF								; discard the directory counter (mod 4)
 ccpDir7:
 	CALL	CheckForConsoleChar				; check for interrupt at keyboard
 	JP	NZ,ccpDirEnd						; abort directory search
 	CALL	SearchForNext
 	JP		ccpDir3							; for another entry
 ccpDirEnd:
 	POP		DE								; discard directory counter
 	JP		ResetDiskAtCmdEnd
 ;
 
 ;*****************************************************************
 ccpErase:
 	CALL	FillFCB0						; cannot be all ???'s
 	CP		11
 	JP	NZ,ccpEraseAll
 											; erasing all of the disk
 	LD		BC,msgEraseAll
 	CALL	PrintCrLfStringNull
 
 	CALL	ReadCommand
 	LD		HL,CommandLength
 	DEC		M
 	JP	NZ,Ccp ;bad input
 	INC		HL
 	LD		A,(HL)
 	CP		ASCII_Y
 	JP	NZ,Ccp
 ; ok, erase the entire diskette
 	INC		HL
 	LD	(commandAddress),HL					; otherwise error at ResetDiskAtCmdEnd
 ccpEraseAll:
 	CALL	SetDisk4Cmd
 	LD		DE,commandFCB
 	CALL	DeleteFile
 	INC		A								; 255 returned if not found
 	CALL	Z,PrintNoFile						; no file message if so
 	JP		ResetDiskAtCmdEnd
 ;
 msgEraseAll:
 	DB	'ALL (Y/N)?',0
 ;*****************************************************************
 ; Type file
 ccpType:
 	CALL	FillFCB0
 	JP	NZ,CommandError					; don't allow ?'s in file name
 	CALL	SetDisk4Cmd
 	CALL	OpenFile4CmdFCB					; open the file
 	JP	Z,ccpTypeError					; zero flag indicates not found
 ; file opened, read 'til eof
 	CALL	CrLf
 	LD		HL,bufferPointer
 	LD		(HL),255 							; read first buffer
 ccpType1:									; loop on bufferPointer
 	LD		HL,bufferPointer
 	LD		A,(HL)
 	CP		128								; end buffer
 	JP	C,ccpType2
 	PUSH	HL								; carry if 0,1,...,127
 ; read another buffer full
 	CALL	DiskReadCmdFCB
 	POP		HL								; recover address of bufferPointer
 	JP	NZ,ccpTypeEOF						; hard end of file
 	XOR		A
 	LD		(HL),A								; bufferPointer = 0
 ; read character at bufferPointer and print
 ccpType2:
 	INC		M								; bufferPointer = bufferPointer + 1
 	LD		HL,DMABuffer
 	CALL	AddA2HL							; h,l addresses char
 	LD		A,(HL)
 	CP		END_OF_FILE
 	JP	Z,ResetDiskAtCmdEnd
 	CALL	PrintChar
 	CALL	CheckForConsoleChar
 	JP	NZ,ResetDiskAtCmdEnd				; abort if break
 	JP		ccpType1						; for another character
 
 ccpTypeEOF:
 	DEC		A
 	JP	Z,ResetDiskAtCmdEnd
 	CALL	PrintReadError
 ccpTypeError:
 	CALL	ResetDisk
 	JP		CommandError
 ;*****************************************************************
 ; save save memory image
 ;*****************************************************************
 ccpSave:
 	CALL	GetNumberFromCmdLine			; value to register a
 	PUSH	AF								; save it for later
 											; should be followed by a file to save the memory image
 	CALL	FillFCB0
 	JP	NZ,CommandError					; cannot be ambiguous
 	CALL	SetDisk4Cmd						; may be a disk change
 	LD		DE,commandFCB
 	PUSH	DE
 	CALL	DeleteFile						; existing file removed
 	POP 	DE
 	CALL	MakeFile						; create a new file on disk
 	JP	Z,ccpSaveError					; no directory space
 	XOR		A
 	LD		(currentRecord),A					; clear next record field
 	POP		AF								; #pages to write is in a, change to #sectors
 	LD		L,A
 	LD		H,0
 	ADD		HL,HL
 
 	LD		DE,TPA							; h,l is sector count, d,e is load address
 ccpSave1:									; save0 check for sector count zero
 	LD		A,H
 	OR		L
 	JP	Z,ccpSave2						; may be completed
 	DEC		HL								; sector count = sector count - 1
 	PUSH	HL								; save it for next time around
 	LD		HL,cpmRecordSize
 	ADD		HL,DE
 	PUSH	HL								; next dma address saved
 	CALL	SetDMA							; current dma address set
 	LD		DE,commandFCB
 	CALL	DiskWrite
 	POP		DE
 	POP		HL								; dma address, sector count
 	JP	NZ,ccpSaveError					; may be disk full case
 	JP		ccpSave1						; for another sector
 
 ;  end of dump, close the file
 ccpSave2:
 	LD		DE,commandFCB
 	CALL	CloseFile
 	INC		A								; 255 becomes 00 if error
 	JP	NZ,ccpSaveExit						; for another command
 ccpSaveError:								; saverr must be full or read only disk
 	LD		BC,msgNoSpace
 	CALL	PrintCrLfStringNull
 ccpSaveExit:
 	CALL	SetDefaultDMA					; reset dma buffer
 	JP		ResetDiskAtCmdEnd
 
 msgNoSpace:
 	DB 'NO SPACE',0
 ;*****************************************************************
 ccpRename:
 	CALL	FillFCB0
 	JP	NZ,CommandError					; must be unambiguous
 	LD		 A,(selectedDisk)
 	PUSH	AF								; save for later compare
 	CALL	SetDisk4Cmd						; disk selected
 	CALL	Searc4CmdFcbFile				; is new name already there?
 	JP	NZ,ccpRenameError3
 ; file doesn't exist, move to second half of fcb
 	LD		HL,commandFCB
 	LD		DE,commandFCB + 16
 	LD		B,16
 	CALL	CopyHL2DEforB
 ; check for = or left arrow
 	LD	HL,(commandAddress)
 	EX	DE,HL 
 	CALL	NextNonBlankChar
 	CP		EQUAL_SIGN
 	JP	Z,ccpRename1						; ok if =
 	CP		LEFT_ARROW						; la
 	JP	NZ,ccpRenameError2
 ccpRename1:
 	EX	DE,HL 
 	INC		HL
 	LD	(commandAddress),HL					; past delimiter
 ; proper delimiter found
 	CALL	FillFCB0
 	JP	NZ,ccpRenameError2
 ; check for drive conflict
 	POP		AF
 	LD		B,A								; previous drive number
 	LD		HL,selectedDisk
 	LD		A,(HL)
 	OR		A
 	JP	Z,ccpRename2
 ; drive name was specified.  same one?
 	CP	B
 	LD	(HL),B
 	JP	NZ,ccpRenameError2
 ccpRename2:
 	LD		(HL),B								; store the name in case drives switched
 	XOR		A
 	LD		(commandFCB),A
 	CALL	Searc4CmdFcbFile				; is old file there?
 	JP	Z,ccpRenameError1
 ; everything is ok, rename the file
 	LD		DE,commandFCB
 	CALL	RenameFile
 	JP		ResetDiskAtCmdEnd
 
 ccpRenameError1:							; no file on disk
 	CALL	PrintNoFile
 	JP		ResetDiskAtCmdEnd
 ccpRenameError2:							; ambigous reference/name conflict
 	CALL	ResetDisk
 	JP		CommandError
 ccpRenameError3:							; file already exists
 	LD		BC,msgFileExists
 	CALL	PrintCrLfStringNull
 	JP		ResetDiskAtCmdEnd
 
 msgFileExists:
 	DB	'FILE EXISTS',0
 
 ;*****************************************************************
 ccpUser:
 	CALL	GetNumberFromCmdLine			; leaves the value in the accumulator
 	CP		16
 	JP	NC,CommandError					; must be between 0 and 15
 	LD		E,A								; save for SetUser call
 	LD		 A,(commandFCB) + 1
 	CP		SPACE
 	JP	Z,CommandError
 	CALL	SetUser 						;new user number set
 	JP		EndCommand
 ;*****************************************************************
 ;User defined function
 ;*****************************************************************
 ccpUserFunction:
 
 	LD		 A,(commandFCB) + 1
 	CP		SPACE
 	JP	NZ,ccpUserFunction1
 ; no file name, but may be disk switch
 	LD		 A,(selectedDisk)
 	OR		A
 	JP	Z,EndCommand						; no disk named if 0
 	DEC		A								; adjust so A=>0, B=>1, C=>2 ......
 	LD		(currentDisk),A						; update current Disk indicator
 	CALL	SetPage0CurDisk					; set user/disk
 	CALL	SelectDisk
 	JP		EndCommand
 
 ;  file name is present
 ccpUserFunction1:
 	LD		DE,commandFCB + 9
 	LD	A,(DE)
 	CP		SPACE
 	JP	NZ,CommandError					; type SPACE
 	PUSH	DE
 	CALL	SetDisk4Cmd
 	POP		DE
 	LD		HL,comFileType					; .com
 	CALL	CopyHL2DE3						; file type is set to .com
 	CALL	OpenFile4CmdFCB
 	JP	Z,ccpUserFunctionError1
 ; file opened properly, read it into memory
 	LD		HL,TPA							; transient program base
 ccpUserFunction2:
 	PUSH	HL 								;save dma address
 	EX	DE,HL 
 	CALL	SetDMA
 	LD		DE,commandFCB
 	CALL	DiskRead
 	JP	NZ,ccpUserFunction3
 ; sector loaded, set new dma address and compare
 	POP		HL
 	LD		DE,cpmRecordSize
 	ADD		HL,DE
 	LD		DE,CcpBoundary					; has the load overflowed?
 	LD		A,L
 	SUB		E
 	LD		A,H
 	SBC		A,D
 	JP	NC,ccpUserFunctionError2
 	JP		ccpUserFunction2				; for another sector
 
 ccpUserFunction3:
 	POP		HL
 	DEC		A
 	JP	NZ,ccpUserFunctionError2			; end file is 1
 	CALL	ResetDisk						; back to original disk
 	CALL	FillFCB0
 	LD		HL,selectedDisk
 	PUSH	HL
 	LD		A,(HL)
 	LD		(commandFCB),A						; drive number set
 	LD		A,16
 	CALL	FillFCB							; move entire fcb to memory
 	POP		HL
 	LD		A,(HL)
 	LD		(commandFCB + 16),A
 	XOR		A
 	LD		(currentRecord),A					; record number set to zero
 	LD		DE,FCB1							; default FCB in page 0
 	LD		HL,commandFCB
 	LD		B,33
 	CALL	CopyHL2DEforB
 ; move command line to buff
 	LD		HL,commandBuffer
 ccpUserFunction4:
 	LD		A,(HL)
 	OR		A
 	JP	Z,ccpUserFunction5
 	CP		SPACE
 	JP	Z,ccpUserFunction5
 	INC		HL
 	JP		ccpUserFunction4				; for another scan
 ; first blank position found
 ccpUserFunction5:
 	LD		B,0
 	LD		DE,DMABuffer + 1
 ; ready for the move
 ccpUserFunction6:
 	LD		A,(HL)
 	LD	(DE),AE
 	OR		A
 	JP	Z,ccpUserFunction7
 ;more to move
 	INC		B
 	INC		HL
 	INC		DE
 	JP		ccpUserFunction6
 ccpUserFunction7:							; B has character count
 	LD		A,B
 	LD		(DMABuffer),A
 	CALL	CrLf
 ; now go to the loaded program
 	CALL	SetDefaultDMA					; default dma
 	CALL	SaveUser						; user code saved
 ; low memory diska contains user code
 	CALL	TPA								; gone to the loaded program
 	LD		SP,Stack						; may come back here
 	CALL	SetPage0CurDisk
 	CALL	SelectDisk
 	JP		Ccp
 
 ccpUserFunctionError1:
 	CALL	ResetDisk
 	JP		CommandError
 
 ccpUserFunctionError2:						; cannot load the program
 	LD		BC,msgBadLoad
 	CALL	PrintCrLfStringNull
 	JP		ResetDiskAtCmdEnd
 
 msgBadLoad:
 	DB		'BAD LOAD',0
 comFileType:
 	DB		'COM' ;for com files
 ;
 
 ;*****************************************************************
 ;*****************************************************************
 ;change disks for this command, if requested
 SetDisk4Cmd:
 	XOR		A
 	LD		(commandFCB),A						; clear disk name from fcb
 	LD		 A,(selectedDisk)
 	OR		A
 	RET	Z; no action if not specified
 	DEC		A
 	LD		HL,currentDisk
 	CP		M
 	RET	Z;already selected
 	JP		SelectDisk
 ;*****************************************************************
 
 ;*****************************************************************
 ;************************ Data Area ******************************
 ;*****************************************************************
 ;	'submit' file control block
 submitFlag:			DB		00H				; 00 if no submit file, ff if submitting
 submitFCB:			DB		00H				; file name is $$$
 
 subModuleNumber:	DB		00H				; module number
 subRecordCount:		DB		00H				; record count filed
 subCurrentRecord:	DB		00H				; current record to read
 ;;
 ;;	command file control block
 commandFCB:			DS		32				; fields filled in later
 currentRecord:		DB		00H				; current record to read/write
 directoryCount:		DB		00H				; disk directory count (used for error codes)
 currentDisk:		DB		00H				; current disk
 selectedDisk:		DB		00H				; selected disk for current operation none=0, a=1, b=2 ...
 ;
 bufferPointer:		DB		00H				; buffer pointer
 ;------------------------------------
 fillFCBStart:		DW		0000H			; staddr starting address of current FillFCB request
 ;----------------------------
 ; (command executed initially if CommandLength non zero)
 
 MaxBufferLength:	DB		127				; maxlen max buffer length
 CommandLength:		DB		0				; comlen command length (filled in by dos)
 commandBuffer:								; combuf:
 					DB		'        '		; 8 character fill
 					DB		'        '		; 8 character fill
 					DB		'COPYRIGHT (C) 1979 DIGITAL RESEARCH  '; 38
 restOfCmdBuffer:
 					DS		cpmRecordSize-(restOfCmdBuffer-commandBuffer)
 commandAddress:		DW		commandBuffer	; comaddr address of next to char to scan
 
 endOfCommandBuffer:
 ;-------------------------------
 ;	DS	16									; 8 level stack
 				ORG		BDOSBase-10H
 Stack:										; stack
 
 
 
 
 
